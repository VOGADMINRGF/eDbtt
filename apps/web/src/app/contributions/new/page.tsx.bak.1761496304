// apps/web/src/app/contributions/new/page.tsx
"use client";

import React from "react";
import StanceSpectrum from "@/components/analyze/StanceSpectrum";
import ObjectionCollector from "@/components/analyze/ObjectionCollector";
import CounterSynth from "@/components/analyze/CounterSynth";
import NewsFeedPanel from "@/components/analyze/NewsFeedPanel";
import InPlaceHUD from "@/ui/InPlaceHUD";
// ClaimPanelsGate kannst du behalten – wir zeigen trotzdem erst, wenn sinnvoll
type Claim = { text: string; confidence?: number; meta?: any };

export default function ContributionNewPage() {
  // Input & Result
  const [text, setText] = React.useState<string>(
    typeof window !== "undefined"
      ? (new URLSearchParams(window.location.search).get("text") ?? "")
      : ""
  );
  const [claims, setClaims] = React.useState<Claim[]>([]);
  const [activeClaimIdx, setActiveClaimIdx] = React.useState<number>(0);

  // Panels erst nach explizitem Klick
  const [showPanels, setShowPanels] = React.useState(false);

  // UX / HUD
  const [analyzing, setAnalyzing] = React.useState<boolean>(false);
  const [hud, setHud] = React.useState<string[]>([]);
  const [errorMsg, setErrorMsg] = React.useState<string | null>(null);

  // === Guards gegen undefined ===
  const activeClaim: Claim | null = claims[activeClaimIdx] ?? null;
  const canShowPanels = showPanels && !analyzing && !!activeClaim?.text;

  React.useEffect(() => {
    if (activeClaimIdx > claims.length - 1) {
      setActiveClaimIdx(Math.max(0, claims.length - 1));
    }
  }, [claims.length, activeClaimIdx]);

  // --- Helpers --------------------------------------------------------------
  function pushHud(line: string) {
    setHud((h) => [...h.slice(-6), line]); // max 7 Zeilen
  }

  async function runAnalysis() {
    const t0 = Date.now();
    setAnalyzing(true);
    setErrorMsg(null);
    setClaims([]);
    setActiveClaimIdx(0);
    setShowPanels(false); // Panels zurücksetzen
    setHud([]);

    try {
      // 1) Vorprüfung
      pushHud("Vorprüfung: Text säubern & Parameter setzen …");
      const payload = { text: String(text || "").slice(0, 8000), maxClaims: 4 };

      // 2) Orchestrierung + Extraktion
      pushHud("Analyse: Modelle orchestrieren & Claim(s) extrahieren …");
      const res = await fetch("/api/contributions/analyze?mode=multi&clarify=1", {
        method: "POST",
        headers: { "content-type": "application/json" },
        body: JSON.stringify(payload),
      });

      const j = await res.json().catch(() => ({} as any));

      // 3) Ergebnis prüfen
      const apiClaims: Claim[] = Array.isArray(j?.claims) ? j.claims : [];
      const cleaned = apiClaims
        .map((c) => ({
          text: String((c as any)?.text ?? "").trim(),
          confidence: (c as any)?.confidence,
          meta: (c as any)?.meta,
        }))
        .filter((c) => c.text.length > 0);

      if (cleaned.length === 0) {
        if (text.trim()) {
          cleaned.push({ text: text.trim() });
          pushHud("Hinweis: Kein strukturierter Claim gefunden – Fallback verwendet.");
        } else {
          pushHud("Hinweis: Kein Inhalt – bitte Text eingeben.");
        }
      }

      setClaims(cleaned);
      setActiveClaimIdx(0);

      // 4) HUD Abschluss
      const took = ((Date.now() - t0) / 1000).toFixed(1);
      pushHud(`Fertig: ${cleaned.length} Claim(s) erkannt · ${took}s`);
    } catch (e: any) {
      const msg = String(e?.message || e);
      setErrorMsg(msg);
      pushHud("Fehler: " + msg);
    } finally {
      setAnalyzing(false);
    }
  }

  function goQuick() {
    const claimText = (activeClaim?.text || text || "").slice(0, 500);
    const u = new URL("/statements/new", window.location.origin);
    if (claimText) u.searchParams.set("text", claimText);
    window.location.href = u.toString();
  }

  // Einfügen direkt im Textfeld (Caret)
  const taRef = React.useRef<HTMLTextAreaElement | null>(null);
  const insertAtCaret = (snippet: string) => {
    const ta = taRef.current;
    if (!ta) { setText((t) => (t + (t.endsWith("\n") ? "" : "\n") + snippet)); return; }
    const start = ta.selectionStart ?? ta.value.length;
    const end   = ta.selectionEnd ?? ta.value.length;
    const next  = ta.value.slice(0, start) + snippet + ta.value.slice(end);
    setText(next);
    // Cursor ans Ende des Snippets
    requestAnimationFrame(() => {
      ta.focus();
      const pos = start + snippet.length;
      ta.setSelectionRange(pos, pos);
    });
  };

  return (
    <div className="container-vog">
      <h1 className="vog-head mb-4">Beitrag erstellen &amp; analysieren</h1>

      <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
        {/* linke Spalte: Eingabe + gated Panels */}
        <div className="lg:col-span-2 space-y-4">
          <div className="vog-card p-4 space-y-3">
            <textarea
              ref={taRef}
              className="w-full min-h-[200px] rounded-2xl border p-3"
              placeholder="Schreibe deinen Beitrag/These…"
              value={text}
              onChange={(e) => setText(e.target.value)}
            />

            {/* ➜ Klarstellungs-Leiste: direkt ins Textfeld einfügen */}
            <ClarifyInline onAdd={insertAtCaret} />

            {/* Inline-Fortschritt wie Chat */}
            <InPlaceHUD log={hud} analyzing={analyzing} />

            <div className="flex gap-2 items-center">
              <button
                className="vog-btn-pri"
                onClick={runAnalysis}
                disabled={!text || analyzing}
              >
                {analyzing ? "Analysiere…" : "Analyse starten"}
              </button>
              <button
                className="vog-btn"
                onClick={goQuick}
                disabled={!text}
                title="Direkt mit dem ersten Claim weiter"
              >
                Schnell-Flow
              </button>
            </div>

            {/* evtl. Fehlermeldung */}
            {errorMsg && <div className="text-sm text-red-600">{errorMsg}</div>}

            {/* Claim-Auswahl */}
            {claims.length > 1 && (
              <div className="pt-2">
                <div className="text-xs text-slate-500 mb-1">Gefundene Claims</div>
                <div className="flex flex-wrap gap-2">
                  {claims.map((c, i) => (
                    <button
                      key={i}
                      className={
                        "vog-chip " + (i === activeClaimIdx ? "ring-2 ring-sky-400" : "")
                      }
                      onClick={() => setActiveClaimIdx(i)}
                      title={c.text}
                    >
                      Claim {i + 1}
                    </button>
                  ))}
                </div>
              </div>
            )}

            {/* Weiter-Button schaltet die Panels frei */}
            {claims.length > 0 && !showPanels && (
              <div className="pt-2">
                <button className="vog-btn" onClick={() => setShowPanels(true)}>
                  Weiter: Alternativen, Einwände & Essenz anzeigen
                </button>
              </div>
            )}
          </div>

          {/* Ab hier „gated“ */}
          {canShowPanels && activeClaim && (activeClaim as any).text && (
  <>
    <StanceSpectrum claimText={(activeClaim as any).text} />
    <ObjectionCollector />
    <CounterSynth text={(activeClaim as any).text} />
  </>
)}
        </div>

        {/* rechte Spalte: Recherche – darf immer laufen */}
        <div className="space-y-3">
          <NewsFeedPanel
            topic={"Allgemein"}
            region={null}
            keywords={
              activeClaim?.text ? [activeClaim.text] : text ? [text] : []
            }
          />
          <div className="vog-card p-4 text-sm">
            <div className="font-semibold mb-1">Hinweis</div>
            Du kannst jederzeit abbrechen – <b>eDebatte</b> übernimmt auf Wunsch
            Redaktion &amp; Belege.
          </div>
        </div>
      </div>
    </div>
  );
}

/** Inline-Fragen: fügt klare, leicht verständliche Schnipsel direkt in den Text ein.
 *  Jede Gruppe hat auch „Unsicher“ und „Sonstiges“ (freier Eintrag).
 */
function ClarifyInline({ onAdd }: { onAdd: (snippet: string) => void }) {
  const add = (s: string) => onAdd((s.startsWith("\n") ? "" : "\n") + s);

  const askFree = (label: string, prefix: string) => {
    const v = window.prompt(label);
    if (v && v.trim()) add(`${prefix}${v.trim()}`);
  };

  return (
    <div className="space-y-2 text-sm">
      <div className="text-xs text-slate-500">Optional präzisieren (für bessere Ergebnisse):</div>

      {/* Ebene / Zuständigkeit */}
      <Row title="Ebene/Zuständigkeit">
        <Chip onClick={() => add("Ebene: EU")}>EU</Chip>
        <Chip onClick={() => add("Ebene: Bund")}>Bund</Chip>
        <Chip onClick={() => add("Ebene: Land")}>Land</Chip>
        <Chip onClick={() => add("Ebene: Kommune")}>Kommune</Chip>
        <Chip onClick={() => add("Ebene: unsicher")}>Unsicher</Chip>
        <Chip onClick={() => askFree("Welche andere Ebene?", "Ebene: ")}>Sonstiges…</Chip>
      </Row>

      {/* Ort/Region */}
      <Row title="Ort/Region">
        <Chip onClick={() => add("Ort: bundesweit")}>Bundesweit</Chip>
        <Chip onClick={() => askFree("Stadt/Region angeben:", "Ort: ")}>Stadt/Region…</Chip>
        <Chip onClick={() => add("Ort: unsicher")}>Unsicher</Chip>
      </Row>

      {/* Zeitraum */}
      <Row title="Zeitraum">
        <Chip onClick={() => add("Zeitraum: aktuell")}>Aktuell</Chip>
        <Chip onClick={() => add("Zeitraum: letzte 12 Monate")}>Letzte 12 Monate</Chip>
        <Chip onClick={() => add("Zeitraum: letzte 5 Jahre")}>Letzte 5 Jahre</Chip>
        <Chip onClick={() => add("Zeitraum: seit 1990")}>Seit 1990</Chip>
        <Chip onClick={() => add("Zeitraum: unsicher")}>Unsicher</Chip>
        <Chip onClick={() => askFree("Anderer Zeitraum:", "Zeitraum: ")}>Sonstiges…</Chip>
      </Row>

      {/* Betroffene */}
      <Row title="Betroffene">
        <Chip onClick={() => add("Betroffene: Bürger*innen")}>Bürger*innen</Chip>
        <Chip onClick={() => add("Betroffene: Unternehmen")}>Unternehmen</Chip>
        <Chip onClick={() => add("Betroffene: Staat/Verwaltung")}>Staat/Verwaltung</Chip>
        <Chip onClick={() => add("Betroffene: Kinder/Jugendliche")}>Kinder/Jugendliche</Chip>
        <Chip onClick={() => add("Betroffene: Rentner*innen")}>Rentner*innen</Chip>
        <Chip onClick={() => add("Betroffene: unsicher")}>Unsicher</Chip>
        <Chip onClick={() => askFree("Andere Gruppe:", "Betroffene: ")}>Sonstiges…</Chip>
      </Row>

      {/* Haltung (optional – hilft beim Spektrum) */}
      <Row title="Haltung">
        <Chip onClick={() => add("Haltung: pro")}>Pro</Chip>
        <Chip onClick={() => add("Haltung: contra")}>Contra</Chip>
        <Chip onClick={() => add("Haltung: neutral")}>Neutral</Chip>
        <Chip onClick={() => add("Haltung: unsicher")}>Unsicher</Chip>
      </Row>
    </div>
  );
}

function Row({ title, children }: { title: string; children: React.ReactNode }) {
  return (
    <div className="flex flex-col gap-1">
      <div className="text-[11px] uppercase tracking-wide text-slate-500">{title}</div>
      <div className="flex flex-wrap gap-2">{children}</div>
    </div>
  );
}

function Chip({ onClick, children }: { onClick?: () => void; children: React.ReactNode }) {
  return (
    <button
      type="button"
      onClick={onClick}
      className="vog-chip cursor-pointer"
    >
      {children}
    </button>
  );
}
