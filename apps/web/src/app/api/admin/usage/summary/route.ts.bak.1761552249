import { NextRequest, NextResponse } from "next/server";

export const runtime = "nodejs";
export const dynamic = "force-dynamic";

type Row = { ts:number, route:string, ms:number, ok:boolean, err?:string|null, model?:string|null, totalTokens?:number|null };

function summarize(rows:Row[]){
  const total = rows.length;
  const byRoute: Record<string,{c:number,avgMs:number,ok:number,err:number}> = {};
  let cost = 0;
  for(const r of rows){
    byRoute[r.route] ??= { c:0, avgMs:0, ok:0, err:0 };
    const b = byRoute[r.route];
    b.c++; b.avgMs += r.ms; if(r.ok) b.ok++; else b.err++;
    // simple SchÃ¤tzer (anpassbar)
    if(/analy/.test(r.route) && (r.totalTokens??0)>0) cost += (r.totalTokens!/1000)*0.002;
  }
  for(const k of Object.keys(byRoute)){ byRoute[k].avgMs = +(byRoute[k].avgMs / byRoute[k].c).toFixed(1); }
  return { total, byRoute, estCostUSD:+cost.toFixed(4) };
}

async function readRows():Promise<Row[]>{
  // 1) bevorzugt aus Metrics-Modul
  try{
    const m = await import("@/lib/metrics/usage");
    const fn = (m as any)?.readAll;
    if(typeof fn==="function"){ const rows = await fn(); if(Array.isArray(rows)) return rows; }
  }catch{}
  // 2) globaler Fallback
  const g:any = globalThis as any;
  return Array.isArray(g.__VOG_USAGE) ? g.__VOG_USAGE as Row[] : [];
}

export async function GET(){
  const rows = await readRows();
  return NextResponse.json({ ok:true, summary:summarize(rows), rows: rows.slice(-200) }, { status:200 });
}
export async function POST(req:NextRequest){
  return GET();
}
