/**
 * Client
 **/

import * as runtime from "./runtime/library.js";
import $Types = runtime.Types; // general types
import $Public = runtime.Types.Public;
import $Utils = runtime.Types.Utils;
import $Extensions = runtime.Types.Extensions;
import $Result = runtime.Types.Result;

export type PrismaPromise<T> = $Public.PrismaPromise<T>;

/**
 * Model Topic
 *
 */
export type Topic = $Result.DefaultSelection<Prisma.$TopicPayload>;
/**
 * Model Tag
 *
 */
export type Tag = $Result.DefaultSelection<Prisma.$TagPayload>;
/**
 * Model TopicTag
 *
 */
export type TopicTag = $Result.DefaultSelection<Prisma.$TopicTagPayload>;
/**
 * Model ItemTag
 *
 */
export type ItemTag = $Result.DefaultSelection<Prisma.$ItemTagPayload>;
/**
 * Model Region
 *
 */
export type Region = $Result.DefaultSelection<Prisma.$RegionPayload>;
/**
 * Model RegionClosure
 *
 */
export type RegionClosure =
  $Result.DefaultSelection<Prisma.$RegionClosurePayload>;
/**
 * Model ContentItem
 *
 */
export type ContentItem = $Result.DefaultSelection<Prisma.$ContentItemPayload>;
/**
 * Model AnswerOption
 *
 */
export type AnswerOption =
  $Result.DefaultSelection<Prisma.$AnswerOptionPayload>;
/**
 * Model FactcheckJob
 *
 */
export type FactcheckJob =
  $Result.DefaultSelection<Prisma.$FactcheckJobPayload>;
/**
 * Model FactcheckClaim
 *
 */
export type FactcheckClaim =
  $Result.DefaultSelection<Prisma.$FactcheckClaimPayload>;
/**
 * Model ProviderRun
 *
 */
export type ProviderRun = $Result.DefaultSelection<Prisma.$ProviderRunPayload>;
/**
 * Model ConsensusRun
 *
 */
export type ConsensusRun =
  $Result.DefaultSelection<Prisma.$ConsensusRunPayload>;
/**
 * Model Evidence
 *
 */
export type Evidence = $Result.DefaultSelection<Prisma.$EvidencePayload>;
/**
 * Model VerdictVersion
 *
 */
export type VerdictVersion =
  $Result.DefaultSelection<Prisma.$VerdictVersionPayload>;
/**
 * Model FactcheckResult
 *
 */
export type FactcheckResult =
  $Result.DefaultSelection<Prisma.$FactcheckResultPayload>;
/**
 * Model AuditLog
 *
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>;
/**
 * Model ExtractedUnit
 *
 */
export type ExtractedUnit =
  $Result.DefaultSelection<Prisma.$ExtractedUnitPayload>;
/**
 * Model Finding
 *
 */
export type Finding = $Result.DefaultSelection<Prisma.$FindingPayload>;
/**
 * Model AdminSettings
 *
 */
export type AdminSettings =
  $Result.DefaultSelection<Prisma.$AdminSettingsPayload>;

/**
 * Enums
 */
export namespace $Enums {
  export const ContentKind: {
    SWIPE: "SWIPE";
    EVENT: "EVENT";
    SUNDAY_POLL: "SUNDAY_POLL";
  };

  export type ContentKind = (typeof ContentKind)[keyof typeof ContentKind];

  export const PublishStatus: {
    draft: "draft";
    review: "review";
    published: "published";
    archived: "archived";
  };

  export type PublishStatus =
    (typeof PublishStatus)[keyof typeof PublishStatus];

  export const RegionMode: {
    AUTO: "AUTO";
    MANUAL: "MANUAL";
  };

  export type RegionMode = (typeof RegionMode)[keyof typeof RegionMode];

  export const Locale: {
    de: "de";
    en: "en";
    fr: "fr";
    it: "it";
    es: "es";
    pl: "pl";
    uk: "uk";
    ru: "ru";
    tr: "tr";
    hi: "hi";
    zh: "zh";
    ar: "ar";
  };

  export type Locale = (typeof Locale)[keyof typeof Locale];

  export const Stance: {
    FOR: "FOR";
    AGAINST: "AGAINST";
    NEUTRAL: "NEUTRAL";
  };

  export type Stance = (typeof Stance)[keyof typeof Stance];

  export const UnitKind: {
    claim: "claim";
    opinion: "opinion";
    policy: "policy";
    question: "question";
    prediction: "prediction";
  };

  export type UnitKind = (typeof UnitKind)[keyof typeof UnitKind];

  export const ReviewStatus: {
    OPEN: "OPEN";
    IN_PROGRESS: "IN_PROGRESS";
    VERIFIED: "VERIFIED";
    REFUTED: "REFUTED";
    MIXED: "MIXED";
    STALE: "STALE";
    ARCHIVED: "ARCHIVED";
  };

  export type ReviewStatus = (typeof ReviewStatus)[keyof typeof ReviewStatus];

  export const Interest: {
    interested: "interested";
    ignored: "ignored";
    undecided: "undecided";
  };

  export type Interest = (typeof Interest)[keyof typeof Interest];

  export const Triage: {
    none: "none";
    watchlist: "watchlist";
    escalate: "escalate";
  };

  export type Triage = (typeof Triage)[keyof typeof Triage];

  export const SourceKind: {
    USER: "USER";
    NEWS: "NEWS";
    SOCIAL: "SOCIAL";
    API: "API";
    SYSTEM: "SYSTEM";
  };

  export type SourceKind = (typeof SourceKind)[keyof typeof SourceKind];

  export const StreamKind: {
    EVENT: "EVENT";
    METRIC: "METRIC";
    LOG: "LOG";
  };

  export type StreamKind = (typeof StreamKind)[keyof typeof StreamKind];

  export const StreamStatus: {
    ACCEPTED: "ACCEPTED";
    APPLIED: "APPLIED";
    REJECTED: "REJECTED";
  };

  export type StreamStatus = (typeof StreamStatus)[keyof typeof StreamStatus];
}

export type ContentKind = $Enums.ContentKind;

export const ContentKind: typeof $Enums.ContentKind;

export type PublishStatus = $Enums.PublishStatus;

export const PublishStatus: typeof $Enums.PublishStatus;

export type RegionMode = $Enums.RegionMode;

export const RegionMode: typeof $Enums.RegionMode;

export type Locale = $Enums.Locale;

export const Locale: typeof $Enums.Locale;

export type Stance = $Enums.Stance;

export const Stance: typeof $Enums.Stance;

export type UnitKind = $Enums.UnitKind;

export const UnitKind: typeof $Enums.UnitKind;

export type ReviewStatus = $Enums.ReviewStatus;

export const ReviewStatus: typeof $Enums.ReviewStatus;

export type Interest = $Enums.Interest;

export const Interest: typeof $Enums.Interest;

export type Triage = $Enums.Triage;

export const Triage: typeof $Enums.Triage;

export type SourceKind = $Enums.SourceKind;

export const SourceKind: typeof $Enums.SourceKind;

export type StreamKind = $Enums.StreamKind;

export const StreamKind: typeof $Enums.StreamKind;

export type StreamStatus = $Enums.StreamStatus;

export const StreamStatus: typeof $Enums.StreamStatus;

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Topics
 * const topics = await prisma.topic.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = "log" extends keyof ClientOptions
    ? ClientOptions["log"] extends Array<Prisma.LogLevel | Prisma.LogDefinition>
      ? Prisma.GetEvents<ClientOptions["log"]>
      : never
    : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>["other"] };

  /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Topics
   * const topics = await prisma.topic.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(
    optionsArg?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>,
  );
  $on<V extends U>(
    eventType: V,
    callback: (
      event: V extends "query" ? Prisma.QueryEvent : Prisma.LogEvent,
    ) => void,
  ): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(
    arg: [...P],
  ): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>;

  $transaction<R>(
    fn: (
      prisma: Omit<PrismaClient, runtime.ITXClientDenyList>,
    ) => $Utils.JsPromise<R>,
    options?: { maxWait?: number; timeout?: number },
  ): $Utils.JsPromise<R>;

  /**
   * Executes a raw MongoDB command and returns the result of it.
   * @example
   * ```
   * const user = await prisma.$runCommandRaw({
   *   aggregate: 'User',
   *   pipeline: [{ $match: { name: 'Bob' } }, { $project: { email: true, _id: false } }],
   *   explain: false,
   * })
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $runCommandRaw(
    command: Prisma.InputJsonObject,
  ): Prisma.PrismaPromise<Prisma.JsonObject>;

  $extends: $Extensions.ExtendsHook<
    "extends",
    Prisma.TypeMapCb<ClientOptions>,
    ExtArgs,
    $Utils.Call<
      Prisma.TypeMapCb<ClientOptions>,
      {
        extArgs: ExtArgs;
      }
    >
  >;

  /**
   * `prisma.topic`: Exposes CRUD operations for the **Topic** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Topics
   * const topics = await prisma.topic.findMany()
   * ```
   */
  get topic(): Prisma.TopicDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tag`: Exposes CRUD operations for the **Tag** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Tags
   * const tags = await prisma.tag.findMany()
   * ```
   */
  get tag(): Prisma.TagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.topicTag`: Exposes CRUD operations for the **TopicTag** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more TopicTags
   * const topicTags = await prisma.topicTag.findMany()
   * ```
   */
  get topicTag(): Prisma.TopicTagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.itemTag`: Exposes CRUD operations for the **ItemTag** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more ItemTags
   * const itemTags = await prisma.itemTag.findMany()
   * ```
   */
  get itemTag(): Prisma.ItemTagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.region`: Exposes CRUD operations for the **Region** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Regions
   * const regions = await prisma.region.findMany()
   * ```
   */
  get region(): Prisma.RegionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.regionClosure`: Exposes CRUD operations for the **RegionClosure** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more RegionClosures
   * const regionClosures = await prisma.regionClosure.findMany()
   * ```
   */
  get regionClosure(): Prisma.RegionClosureDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contentItem`: Exposes CRUD operations for the **ContentItem** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more ContentItems
   * const contentItems = await prisma.contentItem.findMany()
   * ```
   */
  get contentItem(): Prisma.ContentItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.answerOption`: Exposes CRUD operations for the **AnswerOption** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more AnswerOptions
   * const answerOptions = await prisma.answerOption.findMany()
   * ```
   */
  get answerOption(): Prisma.AnswerOptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.factcheckJob`: Exposes CRUD operations for the **FactcheckJob** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more FactcheckJobs
   * const factcheckJobs = await prisma.factcheckJob.findMany()
   * ```
   */
  get factcheckJob(): Prisma.FactcheckJobDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.factcheckClaim`: Exposes CRUD operations for the **FactcheckClaim** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more FactcheckClaims
   * const factcheckClaims = await prisma.factcheckClaim.findMany()
   * ```
   */
  get factcheckClaim(): Prisma.FactcheckClaimDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.providerRun`: Exposes CRUD operations for the **ProviderRun** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more ProviderRuns
   * const providerRuns = await prisma.providerRun.findMany()
   * ```
   */
  get providerRun(): Prisma.ProviderRunDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.consensusRun`: Exposes CRUD operations for the **ConsensusRun** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more ConsensusRuns
   * const consensusRuns = await prisma.consensusRun.findMany()
   * ```
   */
  get consensusRun(): Prisma.ConsensusRunDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.evidence`: Exposes CRUD operations for the **Evidence** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Evidences
   * const evidences = await prisma.evidence.findMany()
   * ```
   */
  get evidence(): Prisma.EvidenceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.verdictVersion`: Exposes CRUD operations for the **VerdictVersion** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more VerdictVersions
   * const verdictVersions = await prisma.verdictVersion.findMany()
   * ```
   */
  get verdictVersion(): Prisma.VerdictVersionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.factcheckResult`: Exposes CRUD operations for the **FactcheckResult** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more FactcheckResults
   * const factcheckResults = await prisma.factcheckResult.findMany()
   * ```
   */
  get factcheckResult(): Prisma.FactcheckResultDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more AuditLogs
   * const auditLogs = await prisma.auditLog.findMany()
   * ```
   */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.extractedUnit`: Exposes CRUD operations for the **ExtractedUnit** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more ExtractedUnits
   * const extractedUnits = await prisma.extractedUnit.findMany()
   * ```
   */
  get extractedUnit(): Prisma.ExtractedUnitDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.finding`: Exposes CRUD operations for the **Finding** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Findings
   * const findings = await prisma.finding.findMany()
   * ```
   */
  get finding(): Prisma.FindingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.adminSettings`: Exposes CRUD operations for the **AdminSettings** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more AdminSettings
   * const adminSettings = await prisma.adminSettings.findMany()
   * ```
   */
  get adminSettings(): Prisma.AdminSettingsDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF;

  export type PrismaPromise<T> = $Public.PrismaPromise<T>;

  /**
   * Validator
   */
  export import validator = runtime.Public.validator;

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError;
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError;
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError;
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError;
  export import PrismaClientValidationError = runtime.PrismaClientValidationError;

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag;
  export import empty = runtime.empty;
  export import join = runtime.join;
  export import raw = runtime.raw;
  export import Sql = runtime.Sql;

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal;

  export type DecimalJsLike = runtime.DecimalJsLike;

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics;
  export type Metric<T> = runtime.Metric<T>;
  export type MetricHistogram = runtime.MetricHistogram;
  export type MetricHistogramBucket = runtime.MetricHistogramBucket;

  /**
   * Extensions
   */
  export import Extension = $Extensions.UserArgs;
  export import getExtensionContext = runtime.Extensions.getExtensionContext;
  export import Args = $Public.Args;
  export import Payload = $Public.Payload;
  export import Result = $Public.Result;
  export import Exact = $Public.Exact;

  /**
   * Prisma Client JS version: 6.16.2
   * Query Engine version: 1c57fdcd7e44b29b9313256c76699e91c3ac3c43
   */
  export type PrismaVersion = {
    client: string;
  };

  export const prismaVersion: PrismaVersion;

  /**
   * Utility Types
   */

  export import JsonObject = runtime.JsonObject;
  export import JsonArray = runtime.JsonArray;
  export import JsonValue = runtime.JsonValue;
  export import InputJsonObject = runtime.InputJsonObject;
  export import InputJsonArray = runtime.InputJsonArray;
  export import InputJsonValue = runtime.InputJsonValue;

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
     * Type of `Prisma.DbNull`.
     *
     * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
     *
     * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
     */
    class DbNull {
      private DbNull: never;
      private constructor();
    }

    /**
     * Type of `Prisma.JsonNull`.
     *
     * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
     *
     * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
     */
    class JsonNull {
      private JsonNull: never;
      private constructor();
    }

    /**
     * Type of `Prisma.AnyNull`.
     *
     * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
     *
     * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
     */
    class AnyNull {
      private AnyNull: never;
      private constructor();
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull;

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull;

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull;

  type SelectAndInclude = {
    select: any;
    include: any;
  };

  type SelectAndOmit = {
    select: any;
    omit: any;
  };

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> =
    T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<
    T extends (...args: any) => $Utils.JsPromise<any>,
  > = PromiseType<ReturnType<T>>;

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
    [P in K]: T[P];
  };

  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K;
  }[keyof T];

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K;
  };

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>;

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  } & (T extends SelectAndInclude
    ? "Please either choose `select` or `include`."
    : T extends SelectAndOmit
      ? "Please either choose `select` or `omit`."
      : {});

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  } & K;

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> = T extends object
    ? U extends object
      ? (Without<T, U> & U) | (Without<U, T> & T)
      : U
    : T;

  /**
   * Is T a Record?
   */
  type IsObject<T extends any> =
    T extends Array<any>
      ? False
      : T extends Date
        ? False
        : T extends Uint8Array
          ? False
          : T extends BigInt
            ? False
            : T extends object
              ? True
              : False;

  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T;

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O>; // With K possibilities
    }[K];

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>;

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<
    __Either<O, K>
  >;

  type _Either<O extends object, K extends Key, strict extends Boolean> = {
    1: EitherStrict<O, K>;
    0: EitherLoose<O, K>;
  }[strict];

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1,
  > = O extends unknown ? _Either<O, K, strict> : never;

  export type Union = any;

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K];
  } & {};

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never;

  export type Overwrite<O extends object, O1 extends object> = {
    [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<
    Overwrite<
      U,
      {
        [K in keyof U]-?: At<U, K>;
      }
    >
  >;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O
    ? O[K]
    : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown
    ? AtStrict<O, K>
    : never;
  export type At<
    O extends object,
    K extends Key,
    strict extends Boolean = 1,
  > = {
    1: AtStrict<O, K>;
    0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function
    ? A
    : {
        [K in keyof A]: A[K];
      } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
      ?
          | (K extends keyof O ? { [P in K]: O[P] } & O : O)
          | ({ [P in keyof O as P extends K ? P : never]-?: O[P] } & O)
      : never
  >;

  type _Strict<U, _U = U> = U extends unknown
    ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>>
    : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False;

  // /**
  // 1
  // */
  export type True = 1;

  /**
  0
  */
  export type False = 0;

  export type Not<B extends Boolean> = {
    0: 1;
    1: 0;
  }[B];

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
      ? 1
      : 0;

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >;

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0;
      1: 1;
    };
    1: {
      0: 1;
      1: 1;
    };
  }[B1][B2];

  export type Keys<U extends Union> = U extends unknown ? keyof U : never;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object
    ? {
        [P in keyof T]: P extends keyof O ? O[P] : never;
      }
    : never;

  type FieldPaths<
    T,
    U = Omit<T, "_avg" | "_sum" | "_count" | "_min" | "_max">,
  > = IsObject<T> extends True ? U : T;

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<"OR", K>, Extends<"AND", K>>,
      Extends<"NOT", K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<
            UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never
          >
        : never
      : {} extends FieldPaths<T[K]>
        ? never
        : K;
  }[keyof T];

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never;
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>;
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T;

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<
    T,
    K extends Enumerable<keyof T> | keyof T,
  > = Prisma__Pick<T, MaybeTupleToUnion<K>>;

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}`
    ? never
    : T;

  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>;

  type FieldRefInputType<Model, FieldType> = Model extends never
    ? never
    : FieldRef<Model, FieldType>;

  export const ModelName: {
    Topic: "Topic";
    Tag: "Tag";
    TopicTag: "TopicTag";
    ItemTag: "ItemTag";
    Region: "Region";
    RegionClosure: "RegionClosure";
    ContentItem: "ContentItem";
    AnswerOption: "AnswerOption";
    FactcheckJob: "FactcheckJob";
    FactcheckClaim: "FactcheckClaim";
    ProviderRun: "ProviderRun";
    ConsensusRun: "ConsensusRun";
    Evidence: "Evidence";
    VerdictVersion: "VerdictVersion";
    FactcheckResult: "FactcheckResult";
    AuditLog: "AuditLog";
    ExtractedUnit: "ExtractedUnit";
    Finding: "Finding";
    AdminSettings: "AdminSettings";
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName];

  export type Datasources = {
    db?: Datasource;
  };

  interface TypeMapCb<ClientOptions = {}>
    extends $Utils.Fn<
      { extArgs: $Extensions.InternalArgs },
      $Utils.Record<string, any>
    > {
    returns: Prisma.TypeMap<
      this["params"]["extArgs"],
      ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}
    >;
  }

  export type TypeMap<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > = {
    globalOmitOptions: {
      omit: GlobalOmitOptions;
    };
    meta: {
      modelProps:
        | "topic"
        | "tag"
        | "topicTag"
        | "itemTag"
        | "region"
        | "regionClosure"
        | "contentItem"
        | "answerOption"
        | "factcheckJob"
        | "factcheckClaim"
        | "providerRun"
        | "consensusRun"
        | "evidence"
        | "verdictVersion"
        | "factcheckResult"
        | "auditLog"
        | "extractedUnit"
        | "finding"
        | "adminSettings";
      txIsolationLevel: never;
    };
    model: {
      Topic: {
        payload: Prisma.$TopicPayload<ExtArgs>;
        fields: Prisma.TopicFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.TopicFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TopicPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.TopicFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TopicPayload>;
          };
          findFirst: {
            args: Prisma.TopicFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TopicPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.TopicFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TopicPayload>;
          };
          findMany: {
            args: Prisma.TopicFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TopicPayload>[];
          };
          create: {
            args: Prisma.TopicCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TopicPayload>;
          };
          createMany: {
            args: Prisma.TopicCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.TopicDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TopicPayload>;
          };
          update: {
            args: Prisma.TopicUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TopicPayload>;
          };
          deleteMany: {
            args: Prisma.TopicDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.TopicUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.TopicUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TopicPayload>;
          };
          aggregate: {
            args: Prisma.TopicAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateTopic>;
          };
          groupBy: {
            args: Prisma.TopicGroupByArgs<ExtArgs>;
            result: $Utils.Optional<TopicGroupByOutputType>[];
          };
          findRaw: {
            args: Prisma.TopicFindRawArgs<ExtArgs>;
            result: JsonObject;
          };
          aggregateRaw: {
            args: Prisma.TopicAggregateRawArgs<ExtArgs>;
            result: JsonObject;
          };
          count: {
            args: Prisma.TopicCountArgs<ExtArgs>;
            result: $Utils.Optional<TopicCountAggregateOutputType> | number;
          };
        };
      };
      Tag: {
        payload: Prisma.$TagPayload<ExtArgs>;
        fields: Prisma.TagFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.TagFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TagPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.TagFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TagPayload>;
          };
          findFirst: {
            args: Prisma.TagFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TagPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.TagFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TagPayload>;
          };
          findMany: {
            args: Prisma.TagFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[];
          };
          create: {
            args: Prisma.TagCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TagPayload>;
          };
          createMany: {
            args: Prisma.TagCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.TagDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TagPayload>;
          };
          update: {
            args: Prisma.TagUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TagPayload>;
          };
          deleteMany: {
            args: Prisma.TagDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.TagUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.TagUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TagPayload>;
          };
          aggregate: {
            args: Prisma.TagAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateTag>;
          };
          groupBy: {
            args: Prisma.TagGroupByArgs<ExtArgs>;
            result: $Utils.Optional<TagGroupByOutputType>[];
          };
          findRaw: {
            args: Prisma.TagFindRawArgs<ExtArgs>;
            result: JsonObject;
          };
          aggregateRaw: {
            args: Prisma.TagAggregateRawArgs<ExtArgs>;
            result: JsonObject;
          };
          count: {
            args: Prisma.TagCountArgs<ExtArgs>;
            result: $Utils.Optional<TagCountAggregateOutputType> | number;
          };
        };
      };
      TopicTag: {
        payload: Prisma.$TopicTagPayload<ExtArgs>;
        fields: Prisma.TopicTagFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.TopicTagFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TopicTagPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.TopicTagFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TopicTagPayload>;
          };
          findFirst: {
            args: Prisma.TopicTagFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TopicTagPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.TopicTagFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TopicTagPayload>;
          };
          findMany: {
            args: Prisma.TopicTagFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TopicTagPayload>[];
          };
          create: {
            args: Prisma.TopicTagCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TopicTagPayload>;
          };
          createMany: {
            args: Prisma.TopicTagCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.TopicTagDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TopicTagPayload>;
          };
          update: {
            args: Prisma.TopicTagUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TopicTagPayload>;
          };
          deleteMany: {
            args: Prisma.TopicTagDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.TopicTagUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.TopicTagUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TopicTagPayload>;
          };
          aggregate: {
            args: Prisma.TopicTagAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateTopicTag>;
          };
          groupBy: {
            args: Prisma.TopicTagGroupByArgs<ExtArgs>;
            result: $Utils.Optional<TopicTagGroupByOutputType>[];
          };
          findRaw: {
            args: Prisma.TopicTagFindRawArgs<ExtArgs>;
            result: JsonObject;
          };
          aggregateRaw: {
            args: Prisma.TopicTagAggregateRawArgs<ExtArgs>;
            result: JsonObject;
          };
          count: {
            args: Prisma.TopicTagCountArgs<ExtArgs>;
            result: $Utils.Optional<TopicTagCountAggregateOutputType> | number;
          };
        };
      };
      ItemTag: {
        payload: Prisma.$ItemTagPayload<ExtArgs>;
        fields: Prisma.ItemTagFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.ItemTagFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ItemTagPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.ItemTagFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ItemTagPayload>;
          };
          findFirst: {
            args: Prisma.ItemTagFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ItemTagPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.ItemTagFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ItemTagPayload>;
          };
          findMany: {
            args: Prisma.ItemTagFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ItemTagPayload>[];
          };
          create: {
            args: Prisma.ItemTagCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ItemTagPayload>;
          };
          createMany: {
            args: Prisma.ItemTagCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.ItemTagDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ItemTagPayload>;
          };
          update: {
            args: Prisma.ItemTagUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ItemTagPayload>;
          };
          deleteMany: {
            args: Prisma.ItemTagDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.ItemTagUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.ItemTagUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ItemTagPayload>;
          };
          aggregate: {
            args: Prisma.ItemTagAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateItemTag>;
          };
          groupBy: {
            args: Prisma.ItemTagGroupByArgs<ExtArgs>;
            result: $Utils.Optional<ItemTagGroupByOutputType>[];
          };
          findRaw: {
            args: Prisma.ItemTagFindRawArgs<ExtArgs>;
            result: JsonObject;
          };
          aggregateRaw: {
            args: Prisma.ItemTagAggregateRawArgs<ExtArgs>;
            result: JsonObject;
          };
          count: {
            args: Prisma.ItemTagCountArgs<ExtArgs>;
            result: $Utils.Optional<ItemTagCountAggregateOutputType> | number;
          };
        };
      };
      Region: {
        payload: Prisma.$RegionPayload<ExtArgs>;
        fields: Prisma.RegionFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.RegionFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RegionPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.RegionFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RegionPayload>;
          };
          findFirst: {
            args: Prisma.RegionFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RegionPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.RegionFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RegionPayload>;
          };
          findMany: {
            args: Prisma.RegionFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RegionPayload>[];
          };
          create: {
            args: Prisma.RegionCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RegionPayload>;
          };
          createMany: {
            args: Prisma.RegionCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.RegionDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RegionPayload>;
          };
          update: {
            args: Prisma.RegionUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RegionPayload>;
          };
          deleteMany: {
            args: Prisma.RegionDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.RegionUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.RegionUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RegionPayload>;
          };
          aggregate: {
            args: Prisma.RegionAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateRegion>;
          };
          groupBy: {
            args: Prisma.RegionGroupByArgs<ExtArgs>;
            result: $Utils.Optional<RegionGroupByOutputType>[];
          };
          findRaw: {
            args: Prisma.RegionFindRawArgs<ExtArgs>;
            result: JsonObject;
          };
          aggregateRaw: {
            args: Prisma.RegionAggregateRawArgs<ExtArgs>;
            result: JsonObject;
          };
          count: {
            args: Prisma.RegionCountArgs<ExtArgs>;
            result: $Utils.Optional<RegionCountAggregateOutputType> | number;
          };
        };
      };
      RegionClosure: {
        payload: Prisma.$RegionClosurePayload<ExtArgs>;
        fields: Prisma.RegionClosureFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.RegionClosureFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RegionClosurePayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.RegionClosureFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RegionClosurePayload>;
          };
          findFirst: {
            args: Prisma.RegionClosureFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RegionClosurePayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.RegionClosureFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RegionClosurePayload>;
          };
          findMany: {
            args: Prisma.RegionClosureFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RegionClosurePayload>[];
          };
          create: {
            args: Prisma.RegionClosureCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RegionClosurePayload>;
          };
          createMany: {
            args: Prisma.RegionClosureCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.RegionClosureDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RegionClosurePayload>;
          };
          update: {
            args: Prisma.RegionClosureUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RegionClosurePayload>;
          };
          deleteMany: {
            args: Prisma.RegionClosureDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.RegionClosureUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.RegionClosureUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RegionClosurePayload>;
          };
          aggregate: {
            args: Prisma.RegionClosureAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateRegionClosure>;
          };
          groupBy: {
            args: Prisma.RegionClosureGroupByArgs<ExtArgs>;
            result: $Utils.Optional<RegionClosureGroupByOutputType>[];
          };
          findRaw: {
            args: Prisma.RegionClosureFindRawArgs<ExtArgs>;
            result: JsonObject;
          };
          aggregateRaw: {
            args: Prisma.RegionClosureAggregateRawArgs<ExtArgs>;
            result: JsonObject;
          };
          count: {
            args: Prisma.RegionClosureCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<RegionClosureCountAggregateOutputType>
              | number;
          };
        };
      };
      ContentItem: {
        payload: Prisma.$ContentItemPayload<ExtArgs>;
        fields: Prisma.ContentItemFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.ContentItemFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ContentItemPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.ContentItemFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ContentItemPayload>;
          };
          findFirst: {
            args: Prisma.ContentItemFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ContentItemPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.ContentItemFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ContentItemPayload>;
          };
          findMany: {
            args: Prisma.ContentItemFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ContentItemPayload>[];
          };
          create: {
            args: Prisma.ContentItemCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ContentItemPayload>;
          };
          createMany: {
            args: Prisma.ContentItemCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.ContentItemDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ContentItemPayload>;
          };
          update: {
            args: Prisma.ContentItemUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ContentItemPayload>;
          };
          deleteMany: {
            args: Prisma.ContentItemDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.ContentItemUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.ContentItemUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ContentItemPayload>;
          };
          aggregate: {
            args: Prisma.ContentItemAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateContentItem>;
          };
          groupBy: {
            args: Prisma.ContentItemGroupByArgs<ExtArgs>;
            result: $Utils.Optional<ContentItemGroupByOutputType>[];
          };
          findRaw: {
            args: Prisma.ContentItemFindRawArgs<ExtArgs>;
            result: JsonObject;
          };
          aggregateRaw: {
            args: Prisma.ContentItemAggregateRawArgs<ExtArgs>;
            result: JsonObject;
          };
          count: {
            args: Prisma.ContentItemCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<ContentItemCountAggregateOutputType>
              | number;
          };
        };
      };
      AnswerOption: {
        payload: Prisma.$AnswerOptionPayload<ExtArgs>;
        fields: Prisma.AnswerOptionFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.AnswerOptionFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AnswerOptionPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.AnswerOptionFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AnswerOptionPayload>;
          };
          findFirst: {
            args: Prisma.AnswerOptionFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AnswerOptionPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.AnswerOptionFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AnswerOptionPayload>;
          };
          findMany: {
            args: Prisma.AnswerOptionFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AnswerOptionPayload>[];
          };
          create: {
            args: Prisma.AnswerOptionCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AnswerOptionPayload>;
          };
          createMany: {
            args: Prisma.AnswerOptionCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.AnswerOptionDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AnswerOptionPayload>;
          };
          update: {
            args: Prisma.AnswerOptionUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AnswerOptionPayload>;
          };
          deleteMany: {
            args: Prisma.AnswerOptionDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.AnswerOptionUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.AnswerOptionUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AnswerOptionPayload>;
          };
          aggregate: {
            args: Prisma.AnswerOptionAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateAnswerOption>;
          };
          groupBy: {
            args: Prisma.AnswerOptionGroupByArgs<ExtArgs>;
            result: $Utils.Optional<AnswerOptionGroupByOutputType>[];
          };
          findRaw: {
            args: Prisma.AnswerOptionFindRawArgs<ExtArgs>;
            result: JsonObject;
          };
          aggregateRaw: {
            args: Prisma.AnswerOptionAggregateRawArgs<ExtArgs>;
            result: JsonObject;
          };
          count: {
            args: Prisma.AnswerOptionCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<AnswerOptionCountAggregateOutputType>
              | number;
          };
        };
      };
      FactcheckJob: {
        payload: Prisma.$FactcheckJobPayload<ExtArgs>;
        fields: Prisma.FactcheckJobFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.FactcheckJobFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FactcheckJobPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.FactcheckJobFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FactcheckJobPayload>;
          };
          findFirst: {
            args: Prisma.FactcheckJobFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FactcheckJobPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.FactcheckJobFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FactcheckJobPayload>;
          };
          findMany: {
            args: Prisma.FactcheckJobFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FactcheckJobPayload>[];
          };
          create: {
            args: Prisma.FactcheckJobCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FactcheckJobPayload>;
          };
          createMany: {
            args: Prisma.FactcheckJobCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.FactcheckJobDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FactcheckJobPayload>;
          };
          update: {
            args: Prisma.FactcheckJobUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FactcheckJobPayload>;
          };
          deleteMany: {
            args: Prisma.FactcheckJobDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.FactcheckJobUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.FactcheckJobUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FactcheckJobPayload>;
          };
          aggregate: {
            args: Prisma.FactcheckJobAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateFactcheckJob>;
          };
          groupBy: {
            args: Prisma.FactcheckJobGroupByArgs<ExtArgs>;
            result: $Utils.Optional<FactcheckJobGroupByOutputType>[];
          };
          findRaw: {
            args: Prisma.FactcheckJobFindRawArgs<ExtArgs>;
            result: JsonObject;
          };
          aggregateRaw: {
            args: Prisma.FactcheckJobAggregateRawArgs<ExtArgs>;
            result: JsonObject;
          };
          count: {
            args: Prisma.FactcheckJobCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<FactcheckJobCountAggregateOutputType>
              | number;
          };
        };
      };
      FactcheckClaim: {
        payload: Prisma.$FactcheckClaimPayload<ExtArgs>;
        fields: Prisma.FactcheckClaimFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.FactcheckClaimFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FactcheckClaimPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.FactcheckClaimFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FactcheckClaimPayload>;
          };
          findFirst: {
            args: Prisma.FactcheckClaimFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FactcheckClaimPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.FactcheckClaimFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FactcheckClaimPayload>;
          };
          findMany: {
            args: Prisma.FactcheckClaimFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FactcheckClaimPayload>[];
          };
          create: {
            args: Prisma.FactcheckClaimCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FactcheckClaimPayload>;
          };
          createMany: {
            args: Prisma.FactcheckClaimCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.FactcheckClaimDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FactcheckClaimPayload>;
          };
          update: {
            args: Prisma.FactcheckClaimUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FactcheckClaimPayload>;
          };
          deleteMany: {
            args: Prisma.FactcheckClaimDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.FactcheckClaimUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.FactcheckClaimUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FactcheckClaimPayload>;
          };
          aggregate: {
            args: Prisma.FactcheckClaimAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateFactcheckClaim>;
          };
          groupBy: {
            args: Prisma.FactcheckClaimGroupByArgs<ExtArgs>;
            result: $Utils.Optional<FactcheckClaimGroupByOutputType>[];
          };
          findRaw: {
            args: Prisma.FactcheckClaimFindRawArgs<ExtArgs>;
            result: JsonObject;
          };
          aggregateRaw: {
            args: Prisma.FactcheckClaimAggregateRawArgs<ExtArgs>;
            result: JsonObject;
          };
          count: {
            args: Prisma.FactcheckClaimCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<FactcheckClaimCountAggregateOutputType>
              | number;
          };
        };
      };
      ProviderRun: {
        payload: Prisma.$ProviderRunPayload<ExtArgs>;
        fields: Prisma.ProviderRunFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.ProviderRunFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ProviderRunPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.ProviderRunFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ProviderRunPayload>;
          };
          findFirst: {
            args: Prisma.ProviderRunFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ProviderRunPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.ProviderRunFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ProviderRunPayload>;
          };
          findMany: {
            args: Prisma.ProviderRunFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ProviderRunPayload>[];
          };
          create: {
            args: Prisma.ProviderRunCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ProviderRunPayload>;
          };
          createMany: {
            args: Prisma.ProviderRunCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.ProviderRunDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ProviderRunPayload>;
          };
          update: {
            args: Prisma.ProviderRunUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ProviderRunPayload>;
          };
          deleteMany: {
            args: Prisma.ProviderRunDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.ProviderRunUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.ProviderRunUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ProviderRunPayload>;
          };
          aggregate: {
            args: Prisma.ProviderRunAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateProviderRun>;
          };
          groupBy: {
            args: Prisma.ProviderRunGroupByArgs<ExtArgs>;
            result: $Utils.Optional<ProviderRunGroupByOutputType>[];
          };
          findRaw: {
            args: Prisma.ProviderRunFindRawArgs<ExtArgs>;
            result: JsonObject;
          };
          aggregateRaw: {
            args: Prisma.ProviderRunAggregateRawArgs<ExtArgs>;
            result: JsonObject;
          };
          count: {
            args: Prisma.ProviderRunCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<ProviderRunCountAggregateOutputType>
              | number;
          };
        };
      };
      ConsensusRun: {
        payload: Prisma.$ConsensusRunPayload<ExtArgs>;
        fields: Prisma.ConsensusRunFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.ConsensusRunFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ConsensusRunPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.ConsensusRunFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ConsensusRunPayload>;
          };
          findFirst: {
            args: Prisma.ConsensusRunFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ConsensusRunPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.ConsensusRunFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ConsensusRunPayload>;
          };
          findMany: {
            args: Prisma.ConsensusRunFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ConsensusRunPayload>[];
          };
          create: {
            args: Prisma.ConsensusRunCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ConsensusRunPayload>;
          };
          createMany: {
            args: Prisma.ConsensusRunCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.ConsensusRunDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ConsensusRunPayload>;
          };
          update: {
            args: Prisma.ConsensusRunUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ConsensusRunPayload>;
          };
          deleteMany: {
            args: Prisma.ConsensusRunDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.ConsensusRunUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.ConsensusRunUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ConsensusRunPayload>;
          };
          aggregate: {
            args: Prisma.ConsensusRunAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateConsensusRun>;
          };
          groupBy: {
            args: Prisma.ConsensusRunGroupByArgs<ExtArgs>;
            result: $Utils.Optional<ConsensusRunGroupByOutputType>[];
          };
          findRaw: {
            args: Prisma.ConsensusRunFindRawArgs<ExtArgs>;
            result: JsonObject;
          };
          aggregateRaw: {
            args: Prisma.ConsensusRunAggregateRawArgs<ExtArgs>;
            result: JsonObject;
          };
          count: {
            args: Prisma.ConsensusRunCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<ConsensusRunCountAggregateOutputType>
              | number;
          };
        };
      };
      Evidence: {
        payload: Prisma.$EvidencePayload<ExtArgs>;
        fields: Prisma.EvidenceFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.EvidenceFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$EvidencePayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.EvidenceFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$EvidencePayload>;
          };
          findFirst: {
            args: Prisma.EvidenceFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$EvidencePayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.EvidenceFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$EvidencePayload>;
          };
          findMany: {
            args: Prisma.EvidenceFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$EvidencePayload>[];
          };
          create: {
            args: Prisma.EvidenceCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$EvidencePayload>;
          };
          createMany: {
            args: Prisma.EvidenceCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.EvidenceDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$EvidencePayload>;
          };
          update: {
            args: Prisma.EvidenceUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$EvidencePayload>;
          };
          deleteMany: {
            args: Prisma.EvidenceDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.EvidenceUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.EvidenceUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$EvidencePayload>;
          };
          aggregate: {
            args: Prisma.EvidenceAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateEvidence>;
          };
          groupBy: {
            args: Prisma.EvidenceGroupByArgs<ExtArgs>;
            result: $Utils.Optional<EvidenceGroupByOutputType>[];
          };
          findRaw: {
            args: Prisma.EvidenceFindRawArgs<ExtArgs>;
            result: JsonObject;
          };
          aggregateRaw: {
            args: Prisma.EvidenceAggregateRawArgs<ExtArgs>;
            result: JsonObject;
          };
          count: {
            args: Prisma.EvidenceCountArgs<ExtArgs>;
            result: $Utils.Optional<EvidenceCountAggregateOutputType> | number;
          };
        };
      };
      VerdictVersion: {
        payload: Prisma.$VerdictVersionPayload<ExtArgs>;
        fields: Prisma.VerdictVersionFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.VerdictVersionFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VerdictVersionPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.VerdictVersionFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VerdictVersionPayload>;
          };
          findFirst: {
            args: Prisma.VerdictVersionFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VerdictVersionPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.VerdictVersionFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VerdictVersionPayload>;
          };
          findMany: {
            args: Prisma.VerdictVersionFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VerdictVersionPayload>[];
          };
          create: {
            args: Prisma.VerdictVersionCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VerdictVersionPayload>;
          };
          createMany: {
            args: Prisma.VerdictVersionCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.VerdictVersionDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VerdictVersionPayload>;
          };
          update: {
            args: Prisma.VerdictVersionUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VerdictVersionPayload>;
          };
          deleteMany: {
            args: Prisma.VerdictVersionDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.VerdictVersionUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.VerdictVersionUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VerdictVersionPayload>;
          };
          aggregate: {
            args: Prisma.VerdictVersionAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateVerdictVersion>;
          };
          groupBy: {
            args: Prisma.VerdictVersionGroupByArgs<ExtArgs>;
            result: $Utils.Optional<VerdictVersionGroupByOutputType>[];
          };
          findRaw: {
            args: Prisma.VerdictVersionFindRawArgs<ExtArgs>;
            result: JsonObject;
          };
          aggregateRaw: {
            args: Prisma.VerdictVersionAggregateRawArgs<ExtArgs>;
            result: JsonObject;
          };
          count: {
            args: Prisma.VerdictVersionCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<VerdictVersionCountAggregateOutputType>
              | number;
          };
        };
      };
      FactcheckResult: {
        payload: Prisma.$FactcheckResultPayload<ExtArgs>;
        fields: Prisma.FactcheckResultFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.FactcheckResultFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FactcheckResultPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.FactcheckResultFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FactcheckResultPayload>;
          };
          findFirst: {
            args: Prisma.FactcheckResultFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FactcheckResultPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.FactcheckResultFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FactcheckResultPayload>;
          };
          findMany: {
            args: Prisma.FactcheckResultFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FactcheckResultPayload>[];
          };
          create: {
            args: Prisma.FactcheckResultCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FactcheckResultPayload>;
          };
          createMany: {
            args: Prisma.FactcheckResultCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.FactcheckResultDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FactcheckResultPayload>;
          };
          update: {
            args: Prisma.FactcheckResultUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FactcheckResultPayload>;
          };
          deleteMany: {
            args: Prisma.FactcheckResultDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.FactcheckResultUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.FactcheckResultUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FactcheckResultPayload>;
          };
          aggregate: {
            args: Prisma.FactcheckResultAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateFactcheckResult>;
          };
          groupBy: {
            args: Prisma.FactcheckResultGroupByArgs<ExtArgs>;
            result: $Utils.Optional<FactcheckResultGroupByOutputType>[];
          };
          findRaw: {
            args: Prisma.FactcheckResultFindRawArgs<ExtArgs>;
            result: JsonObject;
          };
          aggregateRaw: {
            args: Prisma.FactcheckResultAggregateRawArgs<ExtArgs>;
            result: JsonObject;
          };
          count: {
            args: Prisma.FactcheckResultCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<FactcheckResultCountAggregateOutputType>
              | number;
          };
        };
      };
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>;
        fields: Prisma.AuditLogFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>;
          };
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>;
          };
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[];
          };
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>;
          };
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>;
          };
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>;
          };
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>;
          };
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateAuditLog>;
          };
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>;
            result: $Utils.Optional<AuditLogGroupByOutputType>[];
          };
          findRaw: {
            args: Prisma.AuditLogFindRawArgs<ExtArgs>;
            result: JsonObject;
          };
          aggregateRaw: {
            args: Prisma.AuditLogAggregateRawArgs<ExtArgs>;
            result: JsonObject;
          };
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>;
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number;
          };
        };
      };
      ExtractedUnit: {
        payload: Prisma.$ExtractedUnitPayload<ExtArgs>;
        fields: Prisma.ExtractedUnitFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.ExtractedUnitFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ExtractedUnitPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.ExtractedUnitFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ExtractedUnitPayload>;
          };
          findFirst: {
            args: Prisma.ExtractedUnitFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ExtractedUnitPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.ExtractedUnitFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ExtractedUnitPayload>;
          };
          findMany: {
            args: Prisma.ExtractedUnitFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ExtractedUnitPayload>[];
          };
          create: {
            args: Prisma.ExtractedUnitCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ExtractedUnitPayload>;
          };
          createMany: {
            args: Prisma.ExtractedUnitCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.ExtractedUnitDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ExtractedUnitPayload>;
          };
          update: {
            args: Prisma.ExtractedUnitUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ExtractedUnitPayload>;
          };
          deleteMany: {
            args: Prisma.ExtractedUnitDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.ExtractedUnitUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.ExtractedUnitUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ExtractedUnitPayload>;
          };
          aggregate: {
            args: Prisma.ExtractedUnitAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateExtractedUnit>;
          };
          groupBy: {
            args: Prisma.ExtractedUnitGroupByArgs<ExtArgs>;
            result: $Utils.Optional<ExtractedUnitGroupByOutputType>[];
          };
          findRaw: {
            args: Prisma.ExtractedUnitFindRawArgs<ExtArgs>;
            result: JsonObject;
          };
          aggregateRaw: {
            args: Prisma.ExtractedUnitAggregateRawArgs<ExtArgs>;
            result: JsonObject;
          };
          count: {
            args: Prisma.ExtractedUnitCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<ExtractedUnitCountAggregateOutputType>
              | number;
          };
        };
      };
      Finding: {
        payload: Prisma.$FindingPayload<ExtArgs>;
        fields: Prisma.FindingFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.FindingFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FindingPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.FindingFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FindingPayload>;
          };
          findFirst: {
            args: Prisma.FindingFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FindingPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.FindingFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FindingPayload>;
          };
          findMany: {
            args: Prisma.FindingFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FindingPayload>[];
          };
          create: {
            args: Prisma.FindingCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FindingPayload>;
          };
          createMany: {
            args: Prisma.FindingCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.FindingDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FindingPayload>;
          };
          update: {
            args: Prisma.FindingUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FindingPayload>;
          };
          deleteMany: {
            args: Prisma.FindingDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.FindingUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.FindingUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FindingPayload>;
          };
          aggregate: {
            args: Prisma.FindingAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateFinding>;
          };
          groupBy: {
            args: Prisma.FindingGroupByArgs<ExtArgs>;
            result: $Utils.Optional<FindingGroupByOutputType>[];
          };
          findRaw: {
            args: Prisma.FindingFindRawArgs<ExtArgs>;
            result: JsonObject;
          };
          aggregateRaw: {
            args: Prisma.FindingAggregateRawArgs<ExtArgs>;
            result: JsonObject;
          };
          count: {
            args: Prisma.FindingCountArgs<ExtArgs>;
            result: $Utils.Optional<FindingCountAggregateOutputType> | number;
          };
        };
      };
      AdminSettings: {
        payload: Prisma.$AdminSettingsPayload<ExtArgs>;
        fields: Prisma.AdminSettingsFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.AdminSettingsFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AdminSettingsPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.AdminSettingsFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AdminSettingsPayload>;
          };
          findFirst: {
            args: Prisma.AdminSettingsFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AdminSettingsPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.AdminSettingsFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AdminSettingsPayload>;
          };
          findMany: {
            args: Prisma.AdminSettingsFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AdminSettingsPayload>[];
          };
          create: {
            args: Prisma.AdminSettingsCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AdminSettingsPayload>;
          };
          createMany: {
            args: Prisma.AdminSettingsCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.AdminSettingsDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AdminSettingsPayload>;
          };
          update: {
            args: Prisma.AdminSettingsUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AdminSettingsPayload>;
          };
          deleteMany: {
            args: Prisma.AdminSettingsDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.AdminSettingsUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.AdminSettingsUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AdminSettingsPayload>;
          };
          aggregate: {
            args: Prisma.AdminSettingsAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateAdminSettings>;
          };
          groupBy: {
            args: Prisma.AdminSettingsGroupByArgs<ExtArgs>;
            result: $Utils.Optional<AdminSettingsGroupByOutputType>[];
          };
          findRaw: {
            args: Prisma.AdminSettingsFindRawArgs<ExtArgs>;
            result: JsonObject;
          };
          aggregateRaw: {
            args: Prisma.AdminSettingsAggregateRawArgs<ExtArgs>;
            result: JsonObject;
          };
          count: {
            args: Prisma.AdminSettingsCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<AdminSettingsCountAggregateOutputType>
              | number;
          };
        };
      };
    };
  } & {
    other: {
      payload: any;
      operations: {
        $runCommandRaw: {
          args: Prisma.InputJsonObject;
          result: Prisma.JsonObject;
        };
      };
    };
  };
  export const defineExtension: $Extensions.ExtendsHook<
    "define",
    Prisma.TypeMapCb,
    $Extensions.DefaultArgs
  >;
  export type DefaultPrismaClient = PrismaClient;
  export type ErrorFormat = "pretty" | "colorless" | "minimal";
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources;
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string;
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat;
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     *
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     *
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     *
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[];
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number;
      timeout?: number;
    };
    /**
     * Global configuration for omitting model fields by default.
     *
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig;
  }
  export type GlobalOmitConfig = {
    topic?: TopicOmit;
    tag?: TagOmit;
    topicTag?: TopicTagOmit;
    itemTag?: ItemTagOmit;
    region?: RegionOmit;
    regionClosure?: RegionClosureOmit;
    contentItem?: ContentItemOmit;
    answerOption?: AnswerOptionOmit;
    factcheckJob?: FactcheckJobOmit;
    factcheckClaim?: FactcheckClaimOmit;
    providerRun?: ProviderRunOmit;
    consensusRun?: ConsensusRunOmit;
    evidence?: EvidenceOmit;
    verdictVersion?: VerdictVersionOmit;
    factcheckResult?: FactcheckResultOmit;
    auditLog?: AuditLogOmit;
    extractedUnit?: ExtractedUnitOmit;
    finding?: FindingOmit;
    adminSettings?: AdminSettingsOmit;
  };

  /* Types for Logging */
  export type LogLevel = "info" | "query" | "warn" | "error";
  export type LogDefinition = {
    level: LogLevel;
    emit: "stdout" | "event";
  };

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T["level"] : T
  >;

  export type GetEvents<T extends any[]> =
    T extends Array<LogLevel | LogDefinition> ? GetLogType<T[number]> : never;

  export type QueryEvent = {
    timestamp: Date;
    query: string;
    params: string;
    duration: number;
    target: string;
  };

  export type LogEvent = {
    timestamp: Date;
    message: string;
    target: string;
  };
  /* End Types for Logging */

  export type PrismaAction =
    | "findUnique"
    | "findUniqueOrThrow"
    | "findMany"
    | "findFirst"
    | "findFirstOrThrow"
    | "create"
    | "createMany"
    | "createManyAndReturn"
    | "update"
    | "updateMany"
    | "updateManyAndReturn"
    | "upsert"
    | "delete"
    | "deleteMany"
    | "executeRaw"
    | "queryRaw"
    | "aggregate"
    | "count"
    | "runCommandRaw"
    | "findRaw"
    | "groupBy";

  // tested in getLogLevel.test.ts
  export function getLogLevel(
    log: Array<LogLevel | LogDefinition>,
  ): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<
    Prisma.DefaultPrismaClient,
    runtime.ITXClientDenyList
  >;

  export type Datasource = {
    url?: string;
  };

  /**
   * Count Types
   */

  /**
   * Count Type TopicCountOutputType
   */

  export type TopicCountOutputType = {
    items: number;
    tags: number;
  };

  export type TopicCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    items?: boolean | TopicCountOutputTypeCountItemsArgs;
    tags?: boolean | TopicCountOutputTypeCountTagsArgs;
  };

  // Custom InputTypes
  /**
   * TopicCountOutputType without action
   */
  export type TopicCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TopicCountOutputType
     */
    select?: TopicCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * TopicCountOutputType without action
   */
  export type TopicCountOutputTypeCountItemsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ContentItemWhereInput;
  };

  /**
   * TopicCountOutputType without action
   */
  export type TopicCountOutputTypeCountTagsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: TopicTagWhereInput;
  };

  /**
   * Count Type TagCountOutputType
   */

  export type TagCountOutputType = {
    topics: number;
    items: number;
  };

  export type TagCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    topics?: boolean | TagCountOutputTypeCountTopicsArgs;
    items?: boolean | TagCountOutputTypeCountItemsArgs;
  };

  // Custom InputTypes
  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TagCountOutputType
     */
    select?: TagCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeCountTopicsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: TopicTagWhereInput;
  };

  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeCountItemsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ItemTagWhereInput;
  };

  /**
   * Count Type RegionCountOutputType
   */

  export type RegionCountOutputType = {
    children: number;
    itemsManual: number;
    itemsEffective: number;
    ancestors: number;
    descendants: number;
  };

  export type RegionCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    children?: boolean | RegionCountOutputTypeCountChildrenArgs;
    itemsManual?: boolean | RegionCountOutputTypeCountItemsManualArgs;
    itemsEffective?: boolean | RegionCountOutputTypeCountItemsEffectiveArgs;
    ancestors?: boolean | RegionCountOutputTypeCountAncestorsArgs;
    descendants?: boolean | RegionCountOutputTypeCountDescendantsArgs;
  };

  // Custom InputTypes
  /**
   * RegionCountOutputType without action
   */
  export type RegionCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the RegionCountOutputType
     */
    select?: RegionCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * RegionCountOutputType without action
   */
  export type RegionCountOutputTypeCountChildrenArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: RegionWhereInput;
  };

  /**
   * RegionCountOutputType without action
   */
  export type RegionCountOutputTypeCountItemsManualArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ContentItemWhereInput;
  };

  /**
   * RegionCountOutputType without action
   */
  export type RegionCountOutputTypeCountItemsEffectiveArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ContentItemWhereInput;
  };

  /**
   * RegionCountOutputType without action
   */
  export type RegionCountOutputTypeCountAncestorsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: RegionClosureWhereInput;
  };

  /**
   * RegionCountOutputType without action
   */
  export type RegionCountOutputTypeCountDescendantsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: RegionClosureWhereInput;
  };

  /**
   * Count Type ContentItemCountOutputType
   */

  export type ContentItemCountOutputType = {
    units: number;
    answerOptions: number;
    tags: number;
  };

  export type ContentItemCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    units?: boolean | ContentItemCountOutputTypeCountUnitsArgs;
    answerOptions?: boolean | ContentItemCountOutputTypeCountAnswerOptionsArgs;
    tags?: boolean | ContentItemCountOutputTypeCountTagsArgs;
  };

  // Custom InputTypes
  /**
   * ContentItemCountOutputType without action
   */
  export type ContentItemCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ContentItemCountOutputType
     */
    select?: ContentItemCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * ContentItemCountOutputType without action
   */
  export type ContentItemCountOutputTypeCountUnitsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ExtractedUnitWhereInput;
  };

  /**
   * ContentItemCountOutputType without action
   */
  export type ContentItemCountOutputTypeCountAnswerOptionsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: AnswerOptionWhereInput;
  };

  /**
   * ContentItemCountOutputType without action
   */
  export type ContentItemCountOutputTypeCountTagsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ItemTagWhereInput;
  };

  /**
   * Count Type FactcheckJobCountOutputType
   */

  export type FactcheckJobCountOutputType = {
    claims: number;
    results: number;
  };

  export type FactcheckJobCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    claims?: boolean | FactcheckJobCountOutputTypeCountClaimsArgs;
    results?: boolean | FactcheckJobCountOutputTypeCountResultsArgs;
  };

  // Custom InputTypes
  /**
   * FactcheckJobCountOutputType without action
   */
  export type FactcheckJobCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactcheckJobCountOutputType
     */
    select?: FactcheckJobCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * FactcheckJobCountOutputType without action
   */
  export type FactcheckJobCountOutputTypeCountClaimsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: FactcheckClaimWhereInput;
  };

  /**
   * FactcheckJobCountOutputType without action
   */
  export type FactcheckJobCountOutputTypeCountResultsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: FactcheckResultWhereInput;
  };

  /**
   * Count Type FactcheckClaimCountOutputType
   */

  export type FactcheckClaimCountOutputType = {
    providerRuns: number;
    evidences: number;
    verdictVersions: number;
    units: number;
  };

  export type FactcheckClaimCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    providerRuns?: boolean | FactcheckClaimCountOutputTypeCountProviderRunsArgs;
    evidences?: boolean | FactcheckClaimCountOutputTypeCountEvidencesArgs;
    verdictVersions?:
      | boolean
      | FactcheckClaimCountOutputTypeCountVerdictVersionsArgs;
    units?: boolean | FactcheckClaimCountOutputTypeCountUnitsArgs;
  };

  // Custom InputTypes
  /**
   * FactcheckClaimCountOutputType without action
   */
  export type FactcheckClaimCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactcheckClaimCountOutputType
     */
    select?: FactcheckClaimCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * FactcheckClaimCountOutputType without action
   */
  export type FactcheckClaimCountOutputTypeCountProviderRunsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ProviderRunWhereInput;
  };

  /**
   * FactcheckClaimCountOutputType without action
   */
  export type FactcheckClaimCountOutputTypeCountEvidencesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: EvidenceWhereInput;
  };

  /**
   * FactcheckClaimCountOutputType without action
   */
  export type FactcheckClaimCountOutputTypeCountVerdictVersionsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: VerdictVersionWhereInput;
  };

  /**
   * FactcheckClaimCountOutputType without action
   */
  export type FactcheckClaimCountOutputTypeCountUnitsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ExtractedUnitWhereInput;
  };

  /**
   * Models
   */

  /**
   * Model Topic
   */

  export type AggregateTopic = {
    _count: TopicCountAggregateOutputType | null;
    _min: TopicMinAggregateOutputType | null;
    _max: TopicMaxAggregateOutputType | null;
  };

  export type TopicMinAggregateOutputType = {
    id: string | null;
    slug: string | null;
    title: string | null;
    description: string | null;
    locale: $Enums.Locale | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type TopicMaxAggregateOutputType = {
    id: string | null;
    slug: string | null;
    title: string | null;
    description: string | null;
    locale: $Enums.Locale | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type TopicCountAggregateOutputType = {
    id: number;
    slug: number;
    title: number;
    description: number;
    locale: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type TopicMinAggregateInputType = {
    id?: true;
    slug?: true;
    title?: true;
    description?: true;
    locale?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type TopicMaxAggregateInputType = {
    id?: true;
    slug?: true;
    title?: true;
    description?: true;
    locale?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type TopicCountAggregateInputType = {
    id?: true;
    slug?: true;
    title?: true;
    description?: true;
    locale?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type TopicAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Topic to aggregate.
     */
    where?: TopicWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Topics to fetch.
     */
    orderBy?: TopicOrderByWithRelationInput | TopicOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: TopicWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Topics from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Topics.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Topics
     **/
    _count?: true | TopicCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: TopicMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: TopicMaxAggregateInputType;
  };

  export type GetTopicAggregateType<T extends TopicAggregateArgs> = {
    [P in keyof T & keyof AggregateTopic]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTopic[P]>
      : GetScalarType<T[P], AggregateTopic[P]>;
  };

  export type TopicGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: TopicWhereInput;
    orderBy?:
      | TopicOrderByWithAggregationInput
      | TopicOrderByWithAggregationInput[];
    by: TopicScalarFieldEnum[] | TopicScalarFieldEnum;
    having?: TopicScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: TopicCountAggregateInputType | true;
    _min?: TopicMinAggregateInputType;
    _max?: TopicMaxAggregateInputType;
  };

  export type TopicGroupByOutputType = {
    id: string;
    slug: string;
    title: string;
    description: string | null;
    locale: $Enums.Locale;
    createdAt: Date;
    updatedAt: Date;
    _count: TopicCountAggregateOutputType | null;
    _min: TopicMinAggregateOutputType | null;
    _max: TopicMaxAggregateOutputType | null;
  };

  type GetTopicGroupByPayload<T extends TopicGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<TopicGroupByOutputType, T["by"]> & {
          [P in keyof T & keyof TopicGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TopicGroupByOutputType[P]>
            : GetScalarType<T[P], TopicGroupByOutputType[P]>;
        }
      >
    >;

  export type TopicSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      slug?: boolean;
      title?: boolean;
      description?: boolean;
      locale?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      items?: boolean | Topic$itemsArgs<ExtArgs>;
      tags?: boolean | Topic$tagsArgs<ExtArgs>;
      _count?: boolean | TopicCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["topic"]
  >;

  export type TopicSelectScalar = {
    id?: boolean;
    slug?: boolean;
    title?: boolean;
    description?: boolean;
    locale?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type TopicOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | "id"
    | "slug"
    | "title"
    | "description"
    | "locale"
    | "createdAt"
    | "updatedAt",
    ExtArgs["result"]["topic"]
  >;
  export type TopicInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    items?: boolean | Topic$itemsArgs<ExtArgs>;
    tags?: boolean | Topic$tagsArgs<ExtArgs>;
    _count?: boolean | TopicCountOutputTypeDefaultArgs<ExtArgs>;
  };

  export type $TopicPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "Topic";
    objects: {
      items: Prisma.$ContentItemPayload<ExtArgs>[];
      tags: Prisma.$TopicTagPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        slug: string;
        title: string;
        description: string | null;
        locale: $Enums.Locale;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs["result"]["topic"]
    >;
    composites: {};
  };

  type TopicGetPayload<
    S extends boolean | null | undefined | TopicDefaultArgs,
  > = $Result.GetResult<Prisma.$TopicPayload, S>;

  type TopicCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<TopicFindManyArgs, "select" | "include" | "distinct" | "omit"> & {
    select?: TopicCountAggregateInputType | true;
  };

  export interface TopicDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["Topic"];
      meta: { name: "Topic" };
    };
    /**
     * Find zero or one Topic that matches the filter.
     * @param {TopicFindUniqueArgs} args - Arguments to find a Topic
     * @example
     * // Get one Topic
     * const topic = await prisma.topic.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TopicFindUniqueArgs>(
      args: SelectSubset<T, TopicFindUniqueArgs<ExtArgs>>,
    ): Prisma__TopicClient<
      $Result.GetResult<
        Prisma.$TopicPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Topic that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TopicFindUniqueOrThrowArgs} args - Arguments to find a Topic
     * @example
     * // Get one Topic
     * const topic = await prisma.topic.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TopicFindUniqueOrThrowArgs>(
      args: SelectSubset<T, TopicFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__TopicClient<
      $Result.GetResult<
        Prisma.$TopicPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Topic that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicFindFirstArgs} args - Arguments to find a Topic
     * @example
     * // Get one Topic
     * const topic = await prisma.topic.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TopicFindFirstArgs>(
      args?: SelectSubset<T, TopicFindFirstArgs<ExtArgs>>,
    ): Prisma__TopicClient<
      $Result.GetResult<
        Prisma.$TopicPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Topic that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicFindFirstOrThrowArgs} args - Arguments to find a Topic
     * @example
     * // Get one Topic
     * const topic = await prisma.topic.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TopicFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TopicFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__TopicClient<
      $Result.GetResult<
        Prisma.$TopicPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Topics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Topics
     * const topics = await prisma.topic.findMany()
     *
     * // Get first 10 Topics
     * const topics = await prisma.topic.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const topicWithIdOnly = await prisma.topic.findMany({ select: { id: true } })
     *
     */
    findMany<T extends TopicFindManyArgs>(
      args?: SelectSubset<T, TopicFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$TopicPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Topic.
     * @param {TopicCreateArgs} args - Arguments to create a Topic.
     * @example
     * // Create one Topic
     * const Topic = await prisma.topic.create({
     *   data: {
     *     // ... data to create a Topic
     *   }
     * })
     *
     */
    create<T extends TopicCreateArgs>(
      args: SelectSubset<T, TopicCreateArgs<ExtArgs>>,
    ): Prisma__TopicClient<
      $Result.GetResult<
        Prisma.$TopicPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Topics.
     * @param {TopicCreateManyArgs} args - Arguments to create many Topics.
     * @example
     * // Create many Topics
     * const topic = await prisma.topic.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends TopicCreateManyArgs>(
      args?: SelectSubset<T, TopicCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a Topic.
     * @param {TopicDeleteArgs} args - Arguments to delete one Topic.
     * @example
     * // Delete one Topic
     * const Topic = await prisma.topic.delete({
     *   where: {
     *     // ... filter to delete one Topic
     *   }
     * })
     *
     */
    delete<T extends TopicDeleteArgs>(
      args: SelectSubset<T, TopicDeleteArgs<ExtArgs>>,
    ): Prisma__TopicClient<
      $Result.GetResult<
        Prisma.$TopicPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Topic.
     * @param {TopicUpdateArgs} args - Arguments to update one Topic.
     * @example
     * // Update one Topic
     * const topic = await prisma.topic.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends TopicUpdateArgs>(
      args: SelectSubset<T, TopicUpdateArgs<ExtArgs>>,
    ): Prisma__TopicClient<
      $Result.GetResult<
        Prisma.$TopicPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Topics.
     * @param {TopicDeleteManyArgs} args - Arguments to filter Topics to delete.
     * @example
     * // Delete a few Topics
     * const { count } = await prisma.topic.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends TopicDeleteManyArgs>(
      args?: SelectSubset<T, TopicDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Topics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Topics
     * const topic = await prisma.topic.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends TopicUpdateManyArgs>(
      args: SelectSubset<T, TopicUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one Topic.
     * @param {TopicUpsertArgs} args - Arguments to update or create a Topic.
     * @example
     * // Update or create a Topic
     * const topic = await prisma.topic.upsert({
     *   create: {
     *     // ... data to create a Topic
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Topic we want to update
     *   }
     * })
     */
    upsert<T extends TopicUpsertArgs>(
      args: SelectSubset<T, TopicUpsertArgs<ExtArgs>>,
    ): Prisma__TopicClient<
      $Result.GetResult<
        Prisma.$TopicPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Topics that matches the filter.
     * @param {TopicFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const topic = await prisma.topic.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: TopicFindRawArgs): Prisma.PrismaPromise<JsonObject>;

    /**
     * Perform aggregation operations on a Topic.
     * @param {TopicAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const topic = await prisma.topic.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(
      args?: TopicAggregateRawArgs,
    ): Prisma.PrismaPromise<JsonObject>;

    /**
     * Count the number of Topics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicCountArgs} args - Arguments to filter Topics to count.
     * @example
     * // Count the number of Topics
     * const count = await prisma.topic.count({
     *   where: {
     *     // ... the filter for the Topics we want to count
     *   }
     * })
     **/
    count<T extends TopicCountArgs>(
      args?: Subset<T, TopicCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], TopicCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Topic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends TopicAggregateArgs>(
      args: Subset<T, TopicAggregateArgs>,
    ): Prisma.PrismaPromise<GetTopicAggregateType<T>>;

    /**
     * Group by Topic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends TopicGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TopicGroupByArgs["orderBy"] }
        : { orderBy?: TopicGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, TopicGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetTopicGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Topic model
     */
    readonly fields: TopicFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Topic.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TopicClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    items<T extends Topic$itemsArgs<ExtArgs> = {}>(
      args?: Subset<T, Topic$itemsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$ContentItemPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    tags<T extends Topic$tagsArgs<ExtArgs> = {}>(
      args?: Subset<T, Topic$tagsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$TopicTagPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Topic model
   */
  interface TopicFieldRefs {
    readonly id: FieldRef<"Topic", "String">;
    readonly slug: FieldRef<"Topic", "String">;
    readonly title: FieldRef<"Topic", "String">;
    readonly description: FieldRef<"Topic", "String">;
    readonly locale: FieldRef<"Topic", "Locale">;
    readonly createdAt: FieldRef<"Topic", "DateTime">;
    readonly updatedAt: FieldRef<"Topic", "DateTime">;
  }

  // Custom InputTypes
  /**
   * Topic findUnique
   */
  export type TopicFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Topic
     */
    omit?: TopicOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null;
    /**
     * Filter, which Topic to fetch.
     */
    where: TopicWhereUniqueInput;
  };

  /**
   * Topic findUniqueOrThrow
   */
  export type TopicFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Topic
     */
    omit?: TopicOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null;
    /**
     * Filter, which Topic to fetch.
     */
    where: TopicWhereUniqueInput;
  };

  /**
   * Topic findFirst
   */
  export type TopicFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Topic
     */
    omit?: TopicOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null;
    /**
     * Filter, which Topic to fetch.
     */
    where?: TopicWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Topics to fetch.
     */
    orderBy?: TopicOrderByWithRelationInput | TopicOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Topics.
     */
    cursor?: TopicWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Topics from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Topics.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Topics.
     */
    distinct?: TopicScalarFieldEnum | TopicScalarFieldEnum[];
  };

  /**
   * Topic findFirstOrThrow
   */
  export type TopicFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Topic
     */
    omit?: TopicOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null;
    /**
     * Filter, which Topic to fetch.
     */
    where?: TopicWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Topics to fetch.
     */
    orderBy?: TopicOrderByWithRelationInput | TopicOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Topics.
     */
    cursor?: TopicWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Topics from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Topics.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Topics.
     */
    distinct?: TopicScalarFieldEnum | TopicScalarFieldEnum[];
  };

  /**
   * Topic findMany
   */
  export type TopicFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Topic
     */
    omit?: TopicOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null;
    /**
     * Filter, which Topics to fetch.
     */
    where?: TopicWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Topics to fetch.
     */
    orderBy?: TopicOrderByWithRelationInput | TopicOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Topics.
     */
    cursor?: TopicWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Topics from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Topics.
     */
    skip?: number;
    distinct?: TopicScalarFieldEnum | TopicScalarFieldEnum[];
  };

  /**
   * Topic create
   */
  export type TopicCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Topic
     */
    omit?: TopicOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null;
    /**
     * The data needed to create a Topic.
     */
    data: XOR<TopicCreateInput, TopicUncheckedCreateInput>;
  };

  /**
   * Topic createMany
   */
  export type TopicCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Topics.
     */
    data: TopicCreateManyInput | TopicCreateManyInput[];
  };

  /**
   * Topic update
   */
  export type TopicUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Topic
     */
    omit?: TopicOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null;
    /**
     * The data needed to update a Topic.
     */
    data: XOR<TopicUpdateInput, TopicUncheckedUpdateInput>;
    /**
     * Choose, which Topic to update.
     */
    where: TopicWhereUniqueInput;
  };

  /**
   * Topic updateMany
   */
  export type TopicUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Topics.
     */
    data: XOR<TopicUpdateManyMutationInput, TopicUncheckedUpdateManyInput>;
    /**
     * Filter which Topics to update
     */
    where?: TopicWhereInput;
    /**
     * Limit how many Topics to update.
     */
    limit?: number;
  };

  /**
   * Topic upsert
   */
  export type TopicUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Topic
     */
    omit?: TopicOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null;
    /**
     * The filter to search for the Topic to update in case it exists.
     */
    where: TopicWhereUniqueInput;
    /**
     * In case the Topic found by the `where` argument doesn't exist, create a new Topic with this data.
     */
    create: XOR<TopicCreateInput, TopicUncheckedCreateInput>;
    /**
     * In case the Topic was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TopicUpdateInput, TopicUncheckedUpdateInput>;
  };

  /**
   * Topic delete
   */
  export type TopicDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Topic
     */
    omit?: TopicOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null;
    /**
     * Filter which Topic to delete.
     */
    where: TopicWhereUniqueInput;
  };

  /**
   * Topic deleteMany
   */
  export type TopicDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Topics to delete
     */
    where?: TopicWhereInput;
    /**
     * Limit how many Topics to delete.
     */
    limit?: number;
  };

  /**
   * Topic findRaw
   */
  export type TopicFindRawArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue;
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue;
  };

  /**
   * Topic aggregateRaw
   */
  export type TopicAggregateRawArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[];
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue;
  };

  /**
   * Topic.items
   */
  export type Topic$itemsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ContentItem
     */
    select?: ContentItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ContentItem
     */
    omit?: ContentItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentItemInclude<ExtArgs> | null;
    where?: ContentItemWhereInput;
    orderBy?:
      | ContentItemOrderByWithRelationInput
      | ContentItemOrderByWithRelationInput[];
    cursor?: ContentItemWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ContentItemScalarFieldEnum | ContentItemScalarFieldEnum[];
  };

  /**
   * Topic.tags
   */
  export type Topic$tagsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TopicTag
     */
    select?: TopicTagSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TopicTag
     */
    omit?: TopicTagOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicTagInclude<ExtArgs> | null;
    where?: TopicTagWhereInput;
    orderBy?:
      | TopicTagOrderByWithRelationInput
      | TopicTagOrderByWithRelationInput[];
    cursor?: TopicTagWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: TopicTagScalarFieldEnum | TopicTagScalarFieldEnum[];
  };

  /**
   * Topic without action
   */
  export type TopicDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Topic
     */
    omit?: TopicOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null;
  };

  /**
   * Model Tag
   */

  export type AggregateTag = {
    _count: TagCountAggregateOutputType | null;
    _min: TagMinAggregateOutputType | null;
    _max: TagMaxAggregateOutputType | null;
  };

  export type TagMinAggregateOutputType = {
    id: string | null;
    slug: string | null;
    label: string | null;
  };

  export type TagMaxAggregateOutputType = {
    id: string | null;
    slug: string | null;
    label: string | null;
  };

  export type TagCountAggregateOutputType = {
    id: number;
    slug: number;
    label: number;
    _all: number;
  };

  export type TagMinAggregateInputType = {
    id?: true;
    slug?: true;
    label?: true;
  };

  export type TagMaxAggregateInputType = {
    id?: true;
    slug?: true;
    label?: true;
  };

  export type TagCountAggregateInputType = {
    id?: true;
    slug?: true;
    label?: true;
    _all?: true;
  };

  export type TagAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Tag to aggregate.
     */
    where?: TagWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: TagWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Tags.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Tags
     **/
    _count?: true | TagCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: TagMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: TagMaxAggregateInputType;
  };

  export type GetTagAggregateType<T extends TagAggregateArgs> = {
    [P in keyof T & keyof AggregateTag]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTag[P]>
      : GetScalarType<T[P], AggregateTag[P]>;
  };

  export type TagGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: TagWhereInput;
    orderBy?: TagOrderByWithAggregationInput | TagOrderByWithAggregationInput[];
    by: TagScalarFieldEnum[] | TagScalarFieldEnum;
    having?: TagScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: TagCountAggregateInputType | true;
    _min?: TagMinAggregateInputType;
    _max?: TagMaxAggregateInputType;
  };

  export type TagGroupByOutputType = {
    id: string;
    slug: string;
    label: string;
    _count: TagCountAggregateOutputType | null;
    _min: TagMinAggregateOutputType | null;
    _max: TagMaxAggregateOutputType | null;
  };

  type GetTagGroupByPayload<T extends TagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TagGroupByOutputType, T["by"]> & {
        [P in keyof T & keyof TagGroupByOutputType]: P extends "_count"
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], TagGroupByOutputType[P]>
          : GetScalarType<T[P], TagGroupByOutputType[P]>;
      }
    >
  >;

  export type TagSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      slug?: boolean;
      label?: boolean;
      topics?: boolean | Tag$topicsArgs<ExtArgs>;
      items?: boolean | Tag$itemsArgs<ExtArgs>;
      _count?: boolean | TagCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["tag"]
  >;

  export type TagSelectScalar = {
    id?: boolean;
    slug?: boolean;
    label?: boolean;
  };

  export type TagOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<"id" | "slug" | "label", ExtArgs["result"]["tag"]>;
  export type TagInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    topics?: boolean | Tag$topicsArgs<ExtArgs>;
    items?: boolean | Tag$itemsArgs<ExtArgs>;
    _count?: boolean | TagCountOutputTypeDefaultArgs<ExtArgs>;
  };

  export type $TagPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "Tag";
    objects: {
      topics: Prisma.$TopicTagPayload<ExtArgs>[];
      items: Prisma.$ItemTagPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        slug: string;
        label: string;
      },
      ExtArgs["result"]["tag"]
    >;
    composites: {};
  };

  type TagGetPayload<S extends boolean | null | undefined | TagDefaultArgs> =
    $Result.GetResult<Prisma.$TagPayload, S>;

  type TagCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<TagFindManyArgs, "select" | "include" | "distinct" | "omit"> & {
    select?: TagCountAggregateInputType | true;
  };

  export interface TagDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["Tag"];
      meta: { name: "Tag" };
    };
    /**
     * Find zero or one Tag that matches the filter.
     * @param {TagFindUniqueArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TagFindUniqueArgs>(
      args: SelectSubset<T, TagFindUniqueArgs<ExtArgs>>,
    ): Prisma__TagClient<
      $Result.GetResult<
        Prisma.$TagPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Tag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TagFindUniqueOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TagFindUniqueOrThrowArgs>(
      args: SelectSubset<T, TagFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__TagClient<
      $Result.GetResult<
        Prisma.$TagPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Tag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TagFindFirstArgs>(
      args?: SelectSubset<T, TagFindFirstArgs<ExtArgs>>,
    ): Prisma__TagClient<
      $Result.GetResult<
        Prisma.$TagPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Tag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TagFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TagFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__TagClient<
      $Result.GetResult<
        Prisma.$TagPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tags
     * const tags = await prisma.tag.findMany()
     *
     * // Get first 10 Tags
     * const tags = await prisma.tag.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const tagWithIdOnly = await prisma.tag.findMany({ select: { id: true } })
     *
     */
    findMany<T extends TagFindManyArgs>(
      args?: SelectSubset<T, TagFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$TagPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Tag.
     * @param {TagCreateArgs} args - Arguments to create a Tag.
     * @example
     * // Create one Tag
     * const Tag = await prisma.tag.create({
     *   data: {
     *     // ... data to create a Tag
     *   }
     * })
     *
     */
    create<T extends TagCreateArgs>(
      args: SelectSubset<T, TagCreateArgs<ExtArgs>>,
    ): Prisma__TagClient<
      $Result.GetResult<
        Prisma.$TagPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Tags.
     * @param {TagCreateManyArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tag = await prisma.tag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends TagCreateManyArgs>(
      args?: SelectSubset<T, TagCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a Tag.
     * @param {TagDeleteArgs} args - Arguments to delete one Tag.
     * @example
     * // Delete one Tag
     * const Tag = await prisma.tag.delete({
     *   where: {
     *     // ... filter to delete one Tag
     *   }
     * })
     *
     */
    delete<T extends TagDeleteArgs>(
      args: SelectSubset<T, TagDeleteArgs<ExtArgs>>,
    ): Prisma__TagClient<
      $Result.GetResult<
        Prisma.$TagPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Tag.
     * @param {TagUpdateArgs} args - Arguments to update one Tag.
     * @example
     * // Update one Tag
     * const tag = await prisma.tag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends TagUpdateArgs>(
      args: SelectSubset<T, TagUpdateArgs<ExtArgs>>,
    ): Prisma__TagClient<
      $Result.GetResult<
        Prisma.$TagPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Tags.
     * @param {TagDeleteManyArgs} args - Arguments to filter Tags to delete.
     * @example
     * // Delete a few Tags
     * const { count } = await prisma.tag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends TagDeleteManyArgs>(
      args?: SelectSubset<T, TagDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tags
     * const tag = await prisma.tag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends TagUpdateManyArgs>(
      args: SelectSubset<T, TagUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one Tag.
     * @param {TagUpsertArgs} args - Arguments to update or create a Tag.
     * @example
     * // Update or create a Tag
     * const tag = await prisma.tag.upsert({
     *   create: {
     *     // ... data to create a Tag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tag we want to update
     *   }
     * })
     */
    upsert<T extends TagUpsertArgs>(
      args: SelectSubset<T, TagUpsertArgs<ExtArgs>>,
    ): Prisma__TagClient<
      $Result.GetResult<
        Prisma.$TagPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Tags that matches the filter.
     * @param {TagFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const tag = await prisma.tag.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: TagFindRawArgs): Prisma.PrismaPromise<JsonObject>;

    /**
     * Perform aggregation operations on a Tag.
     * @param {TagAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const tag = await prisma.tag.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: TagAggregateRawArgs): Prisma.PrismaPromise<JsonObject>;

    /**
     * Count the number of Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagCountArgs} args - Arguments to filter Tags to count.
     * @example
     * // Count the number of Tags
     * const count = await prisma.tag.count({
     *   where: {
     *     // ... the filter for the Tags we want to count
     *   }
     * })
     **/
    count<T extends TagCountArgs>(
      args?: Subset<T, TagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], TagCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends TagAggregateArgs>(
      args: Subset<T, TagAggregateArgs>,
    ): Prisma.PrismaPromise<GetTagAggregateType<T>>;

    /**
     * Group by Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends TagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TagGroupByArgs["orderBy"] }
        : { orderBy?: TagGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, TagGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetTagGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Tag model
     */
    readonly fields: TagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TagClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    topics<T extends Tag$topicsArgs<ExtArgs> = {}>(
      args?: Subset<T, Tag$topicsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$TopicTagPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    items<T extends Tag$itemsArgs<ExtArgs> = {}>(
      args?: Subset<T, Tag$itemsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$ItemTagPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Tag model
   */
  interface TagFieldRefs {
    readonly id: FieldRef<"Tag", "String">;
    readonly slug: FieldRef<"Tag", "String">;
    readonly label: FieldRef<"Tag", "String">;
  }

  // Custom InputTypes
  /**
   * Tag findUnique
   */
  export type TagFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null;
    /**
     * Filter, which Tag to fetch.
     */
    where: TagWhereUniqueInput;
  };

  /**
   * Tag findUniqueOrThrow
   */
  export type TagFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null;
    /**
     * Filter, which Tag to fetch.
     */
    where: TagWhereUniqueInput;
  };

  /**
   * Tag findFirst
   */
  export type TagFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null;
    /**
     * Filter, which Tag to fetch.
     */
    where?: TagWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Tags.
     */
    cursor?: TagWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Tags.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[];
  };

  /**
   * Tag findFirstOrThrow
   */
  export type TagFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null;
    /**
     * Filter, which Tag to fetch.
     */
    where?: TagWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Tags.
     */
    cursor?: TagWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Tags.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[];
  };

  /**
   * Tag findMany
   */
  export type TagFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null;
    /**
     * Filter, which Tags to fetch.
     */
    where?: TagWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Tags.
     */
    cursor?: TagWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Tags.
     */
    skip?: number;
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[];
  };

  /**
   * Tag create
   */
  export type TagCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null;
    /**
     * The data needed to create a Tag.
     */
    data: XOR<TagCreateInput, TagUncheckedCreateInput>;
  };

  /**
   * Tag createMany
   */
  export type TagCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Tags.
     */
    data: TagCreateManyInput | TagCreateManyInput[];
  };

  /**
   * Tag update
   */
  export type TagUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null;
    /**
     * The data needed to update a Tag.
     */
    data: XOR<TagUpdateInput, TagUncheckedUpdateInput>;
    /**
     * Choose, which Tag to update.
     */
    where: TagWhereUniqueInput;
  };

  /**
   * Tag updateMany
   */
  export type TagUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Tags.
     */
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyInput>;
    /**
     * Filter which Tags to update
     */
    where?: TagWhereInput;
    /**
     * Limit how many Tags to update.
     */
    limit?: number;
  };

  /**
   * Tag upsert
   */
  export type TagUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null;
    /**
     * The filter to search for the Tag to update in case it exists.
     */
    where: TagWhereUniqueInput;
    /**
     * In case the Tag found by the `where` argument doesn't exist, create a new Tag with this data.
     */
    create: XOR<TagCreateInput, TagUncheckedCreateInput>;
    /**
     * In case the Tag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TagUpdateInput, TagUncheckedUpdateInput>;
  };

  /**
   * Tag delete
   */
  export type TagDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null;
    /**
     * Filter which Tag to delete.
     */
    where: TagWhereUniqueInput;
  };

  /**
   * Tag deleteMany
   */
  export type TagDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Tags to delete
     */
    where?: TagWhereInput;
    /**
     * Limit how many Tags to delete.
     */
    limit?: number;
  };

  /**
   * Tag findRaw
   */
  export type TagFindRawArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue;
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue;
  };

  /**
   * Tag aggregateRaw
   */
  export type TagAggregateRawArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[];
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue;
  };

  /**
   * Tag.topics
   */
  export type Tag$topicsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TopicTag
     */
    select?: TopicTagSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TopicTag
     */
    omit?: TopicTagOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicTagInclude<ExtArgs> | null;
    where?: TopicTagWhereInput;
    orderBy?:
      | TopicTagOrderByWithRelationInput
      | TopicTagOrderByWithRelationInput[];
    cursor?: TopicTagWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: TopicTagScalarFieldEnum | TopicTagScalarFieldEnum[];
  };

  /**
   * Tag.items
   */
  export type Tag$itemsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ItemTag
     */
    select?: ItemTagSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ItemTag
     */
    omit?: ItemTagOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemTagInclude<ExtArgs> | null;
    where?: ItemTagWhereInput;
    orderBy?:
      | ItemTagOrderByWithRelationInput
      | ItemTagOrderByWithRelationInput[];
    cursor?: ItemTagWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ItemTagScalarFieldEnum | ItemTagScalarFieldEnum[];
  };

  /**
   * Tag without action
   */
  export type TagDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null;
  };

  /**
   * Model TopicTag
   */

  export type AggregateTopicTag = {
    _count: TopicTagCountAggregateOutputType | null;
    _min: TopicTagMinAggregateOutputType | null;
    _max: TopicTagMaxAggregateOutputType | null;
  };

  export type TopicTagMinAggregateOutputType = {
    id: string | null;
    topicId: string | null;
    tagId: string | null;
  };

  export type TopicTagMaxAggregateOutputType = {
    id: string | null;
    topicId: string | null;
    tagId: string | null;
  };

  export type TopicTagCountAggregateOutputType = {
    id: number;
    topicId: number;
    tagId: number;
    _all: number;
  };

  export type TopicTagMinAggregateInputType = {
    id?: true;
    topicId?: true;
    tagId?: true;
  };

  export type TopicTagMaxAggregateInputType = {
    id?: true;
    topicId?: true;
    tagId?: true;
  };

  export type TopicTagCountAggregateInputType = {
    id?: true;
    topicId?: true;
    tagId?: true;
    _all?: true;
  };

  export type TopicTagAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which TopicTag to aggregate.
     */
    where?: TopicTagWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of TopicTags to fetch.
     */
    orderBy?:
      | TopicTagOrderByWithRelationInput
      | TopicTagOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: TopicTagWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` TopicTags from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` TopicTags.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned TopicTags
     **/
    _count?: true | TopicTagCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: TopicTagMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: TopicTagMaxAggregateInputType;
  };

  export type GetTopicTagAggregateType<T extends TopicTagAggregateArgs> = {
    [P in keyof T & keyof AggregateTopicTag]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTopicTag[P]>
      : GetScalarType<T[P], AggregateTopicTag[P]>;
  };

  export type TopicTagGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: TopicTagWhereInput;
    orderBy?:
      | TopicTagOrderByWithAggregationInput
      | TopicTagOrderByWithAggregationInput[];
    by: TopicTagScalarFieldEnum[] | TopicTagScalarFieldEnum;
    having?: TopicTagScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: TopicTagCountAggregateInputType | true;
    _min?: TopicTagMinAggregateInputType;
    _max?: TopicTagMaxAggregateInputType;
  };

  export type TopicTagGroupByOutputType = {
    id: string;
    topicId: string;
    tagId: string;
    _count: TopicTagCountAggregateOutputType | null;
    _min: TopicTagMinAggregateOutputType | null;
    _max: TopicTagMaxAggregateOutputType | null;
  };

  type GetTopicTagGroupByPayload<T extends TopicTagGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<TopicTagGroupByOutputType, T["by"]> & {
          [P in keyof T & keyof TopicTagGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TopicTagGroupByOutputType[P]>
            : GetScalarType<T[P], TopicTagGroupByOutputType[P]>;
        }
      >
    >;

  export type TopicTagSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      topicId?: boolean;
      tagId?: boolean;
      topic?: boolean | TopicDefaultArgs<ExtArgs>;
      tag?: boolean | TagDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["topicTag"]
  >;

  export type TopicTagSelectScalar = {
    id?: boolean;
    topicId?: boolean;
    tagId?: boolean;
  };

  export type TopicTagOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    "id" | "topicId" | "tagId",
    ExtArgs["result"]["topicTag"]
  >;
  export type TopicTagInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    topic?: boolean | TopicDefaultArgs<ExtArgs>;
    tag?: boolean | TagDefaultArgs<ExtArgs>;
  };

  export type $TopicTagPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "TopicTag";
    objects: {
      topic: Prisma.$TopicPayload<ExtArgs>;
      tag: Prisma.$TagPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        topicId: string;
        tagId: string;
      },
      ExtArgs["result"]["topicTag"]
    >;
    composites: {};
  };

  type TopicTagGetPayload<
    S extends boolean | null | undefined | TopicTagDefaultArgs,
  > = $Result.GetResult<Prisma.$TopicTagPayload, S>;

  type TopicTagCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<TopicTagFindManyArgs, "select" | "include" | "distinct" | "omit"> & {
    select?: TopicTagCountAggregateInputType | true;
  };

  export interface TopicTagDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["TopicTag"];
      meta: { name: "TopicTag" };
    };
    /**
     * Find zero or one TopicTag that matches the filter.
     * @param {TopicTagFindUniqueArgs} args - Arguments to find a TopicTag
     * @example
     * // Get one TopicTag
     * const topicTag = await prisma.topicTag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TopicTagFindUniqueArgs>(
      args: SelectSubset<T, TopicTagFindUniqueArgs<ExtArgs>>,
    ): Prisma__TopicTagClient<
      $Result.GetResult<
        Prisma.$TopicTagPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one TopicTag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TopicTagFindUniqueOrThrowArgs} args - Arguments to find a TopicTag
     * @example
     * // Get one TopicTag
     * const topicTag = await prisma.topicTag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TopicTagFindUniqueOrThrowArgs>(
      args: SelectSubset<T, TopicTagFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__TopicTagClient<
      $Result.GetResult<
        Prisma.$TopicTagPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first TopicTag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicTagFindFirstArgs} args - Arguments to find a TopicTag
     * @example
     * // Get one TopicTag
     * const topicTag = await prisma.topicTag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TopicTagFindFirstArgs>(
      args?: SelectSubset<T, TopicTagFindFirstArgs<ExtArgs>>,
    ): Prisma__TopicTagClient<
      $Result.GetResult<
        Prisma.$TopicTagPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first TopicTag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicTagFindFirstOrThrowArgs} args - Arguments to find a TopicTag
     * @example
     * // Get one TopicTag
     * const topicTag = await prisma.topicTag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TopicTagFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TopicTagFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__TopicTagClient<
      $Result.GetResult<
        Prisma.$TopicTagPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more TopicTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicTagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TopicTags
     * const topicTags = await prisma.topicTag.findMany()
     *
     * // Get first 10 TopicTags
     * const topicTags = await prisma.topicTag.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const topicTagWithIdOnly = await prisma.topicTag.findMany({ select: { id: true } })
     *
     */
    findMany<T extends TopicTagFindManyArgs>(
      args?: SelectSubset<T, TopicTagFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$TopicTagPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a TopicTag.
     * @param {TopicTagCreateArgs} args - Arguments to create a TopicTag.
     * @example
     * // Create one TopicTag
     * const TopicTag = await prisma.topicTag.create({
     *   data: {
     *     // ... data to create a TopicTag
     *   }
     * })
     *
     */
    create<T extends TopicTagCreateArgs>(
      args: SelectSubset<T, TopicTagCreateArgs<ExtArgs>>,
    ): Prisma__TopicTagClient<
      $Result.GetResult<
        Prisma.$TopicTagPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many TopicTags.
     * @param {TopicTagCreateManyArgs} args - Arguments to create many TopicTags.
     * @example
     * // Create many TopicTags
     * const topicTag = await prisma.topicTag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends TopicTagCreateManyArgs>(
      args?: SelectSubset<T, TopicTagCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a TopicTag.
     * @param {TopicTagDeleteArgs} args - Arguments to delete one TopicTag.
     * @example
     * // Delete one TopicTag
     * const TopicTag = await prisma.topicTag.delete({
     *   where: {
     *     // ... filter to delete one TopicTag
     *   }
     * })
     *
     */
    delete<T extends TopicTagDeleteArgs>(
      args: SelectSubset<T, TopicTagDeleteArgs<ExtArgs>>,
    ): Prisma__TopicTagClient<
      $Result.GetResult<
        Prisma.$TopicTagPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one TopicTag.
     * @param {TopicTagUpdateArgs} args - Arguments to update one TopicTag.
     * @example
     * // Update one TopicTag
     * const topicTag = await prisma.topicTag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends TopicTagUpdateArgs>(
      args: SelectSubset<T, TopicTagUpdateArgs<ExtArgs>>,
    ): Prisma__TopicTagClient<
      $Result.GetResult<
        Prisma.$TopicTagPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more TopicTags.
     * @param {TopicTagDeleteManyArgs} args - Arguments to filter TopicTags to delete.
     * @example
     * // Delete a few TopicTags
     * const { count } = await prisma.topicTag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends TopicTagDeleteManyArgs>(
      args?: SelectSubset<T, TopicTagDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more TopicTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicTagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TopicTags
     * const topicTag = await prisma.topicTag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends TopicTagUpdateManyArgs>(
      args: SelectSubset<T, TopicTagUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one TopicTag.
     * @param {TopicTagUpsertArgs} args - Arguments to update or create a TopicTag.
     * @example
     * // Update or create a TopicTag
     * const topicTag = await prisma.topicTag.upsert({
     *   create: {
     *     // ... data to create a TopicTag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TopicTag we want to update
     *   }
     * })
     */
    upsert<T extends TopicTagUpsertArgs>(
      args: SelectSubset<T, TopicTagUpsertArgs<ExtArgs>>,
    ): Prisma__TopicTagClient<
      $Result.GetResult<
        Prisma.$TopicTagPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more TopicTags that matches the filter.
     * @param {TopicTagFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const topicTag = await prisma.topicTag.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: TopicTagFindRawArgs): Prisma.PrismaPromise<JsonObject>;

    /**
     * Perform aggregation operations on a TopicTag.
     * @param {TopicTagAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const topicTag = await prisma.topicTag.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(
      args?: TopicTagAggregateRawArgs,
    ): Prisma.PrismaPromise<JsonObject>;

    /**
     * Count the number of TopicTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicTagCountArgs} args - Arguments to filter TopicTags to count.
     * @example
     * // Count the number of TopicTags
     * const count = await prisma.topicTag.count({
     *   where: {
     *     // ... the filter for the TopicTags we want to count
     *   }
     * })
     **/
    count<T extends TopicTagCountArgs>(
      args?: Subset<T, TopicTagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], TopicTagCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a TopicTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicTagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends TopicTagAggregateArgs>(
      args: Subset<T, TopicTagAggregateArgs>,
    ): Prisma.PrismaPromise<GetTopicTagAggregateType<T>>;

    /**
     * Group by TopicTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicTagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends TopicTagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TopicTagGroupByArgs["orderBy"] }
        : { orderBy?: TopicTagGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, TopicTagGroupByArgs, OrderByArg> &
        InputErrors,
    ): {} extends InputErrors
      ? GetTopicTagGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the TopicTag model
     */
    readonly fields: TopicTagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TopicTag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TopicTagClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    topic<T extends TopicDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, TopicDefaultArgs<ExtArgs>>,
    ): Prisma__TopicClient<
      | $Result.GetResult<
          Prisma.$TopicPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    tag<T extends TagDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, TagDefaultArgs<ExtArgs>>,
    ): Prisma__TagClient<
      | $Result.GetResult<
          Prisma.$TagPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the TopicTag model
   */
  interface TopicTagFieldRefs {
    readonly id: FieldRef<"TopicTag", "String">;
    readonly topicId: FieldRef<"TopicTag", "String">;
    readonly tagId: FieldRef<"TopicTag", "String">;
  }

  // Custom InputTypes
  /**
   * TopicTag findUnique
   */
  export type TopicTagFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TopicTag
     */
    select?: TopicTagSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TopicTag
     */
    omit?: TopicTagOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicTagInclude<ExtArgs> | null;
    /**
     * Filter, which TopicTag to fetch.
     */
    where: TopicTagWhereUniqueInput;
  };

  /**
   * TopicTag findUniqueOrThrow
   */
  export type TopicTagFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TopicTag
     */
    select?: TopicTagSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TopicTag
     */
    omit?: TopicTagOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicTagInclude<ExtArgs> | null;
    /**
     * Filter, which TopicTag to fetch.
     */
    where: TopicTagWhereUniqueInput;
  };

  /**
   * TopicTag findFirst
   */
  export type TopicTagFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TopicTag
     */
    select?: TopicTagSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TopicTag
     */
    omit?: TopicTagOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicTagInclude<ExtArgs> | null;
    /**
     * Filter, which TopicTag to fetch.
     */
    where?: TopicTagWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of TopicTags to fetch.
     */
    orderBy?:
      | TopicTagOrderByWithRelationInput
      | TopicTagOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for TopicTags.
     */
    cursor?: TopicTagWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` TopicTags from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` TopicTags.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of TopicTags.
     */
    distinct?: TopicTagScalarFieldEnum | TopicTagScalarFieldEnum[];
  };

  /**
   * TopicTag findFirstOrThrow
   */
  export type TopicTagFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TopicTag
     */
    select?: TopicTagSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TopicTag
     */
    omit?: TopicTagOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicTagInclude<ExtArgs> | null;
    /**
     * Filter, which TopicTag to fetch.
     */
    where?: TopicTagWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of TopicTags to fetch.
     */
    orderBy?:
      | TopicTagOrderByWithRelationInput
      | TopicTagOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for TopicTags.
     */
    cursor?: TopicTagWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` TopicTags from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` TopicTags.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of TopicTags.
     */
    distinct?: TopicTagScalarFieldEnum | TopicTagScalarFieldEnum[];
  };

  /**
   * TopicTag findMany
   */
  export type TopicTagFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TopicTag
     */
    select?: TopicTagSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TopicTag
     */
    omit?: TopicTagOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicTagInclude<ExtArgs> | null;
    /**
     * Filter, which TopicTags to fetch.
     */
    where?: TopicTagWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of TopicTags to fetch.
     */
    orderBy?:
      | TopicTagOrderByWithRelationInput
      | TopicTagOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing TopicTags.
     */
    cursor?: TopicTagWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` TopicTags from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` TopicTags.
     */
    skip?: number;
    distinct?: TopicTagScalarFieldEnum | TopicTagScalarFieldEnum[];
  };

  /**
   * TopicTag create
   */
  export type TopicTagCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TopicTag
     */
    select?: TopicTagSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TopicTag
     */
    omit?: TopicTagOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicTagInclude<ExtArgs> | null;
    /**
     * The data needed to create a TopicTag.
     */
    data: XOR<TopicTagCreateInput, TopicTagUncheckedCreateInput>;
  };

  /**
   * TopicTag createMany
   */
  export type TopicTagCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many TopicTags.
     */
    data: TopicTagCreateManyInput | TopicTagCreateManyInput[];
  };

  /**
   * TopicTag update
   */
  export type TopicTagUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TopicTag
     */
    select?: TopicTagSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TopicTag
     */
    omit?: TopicTagOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicTagInclude<ExtArgs> | null;
    /**
     * The data needed to update a TopicTag.
     */
    data: XOR<TopicTagUpdateInput, TopicTagUncheckedUpdateInput>;
    /**
     * Choose, which TopicTag to update.
     */
    where: TopicTagWhereUniqueInput;
  };

  /**
   * TopicTag updateMany
   */
  export type TopicTagUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update TopicTags.
     */
    data: XOR<
      TopicTagUpdateManyMutationInput,
      TopicTagUncheckedUpdateManyInput
    >;
    /**
     * Filter which TopicTags to update
     */
    where?: TopicTagWhereInput;
    /**
     * Limit how many TopicTags to update.
     */
    limit?: number;
  };

  /**
   * TopicTag upsert
   */
  export type TopicTagUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TopicTag
     */
    select?: TopicTagSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TopicTag
     */
    omit?: TopicTagOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicTagInclude<ExtArgs> | null;
    /**
     * The filter to search for the TopicTag to update in case it exists.
     */
    where: TopicTagWhereUniqueInput;
    /**
     * In case the TopicTag found by the `where` argument doesn't exist, create a new TopicTag with this data.
     */
    create: XOR<TopicTagCreateInput, TopicTagUncheckedCreateInput>;
    /**
     * In case the TopicTag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TopicTagUpdateInput, TopicTagUncheckedUpdateInput>;
  };

  /**
   * TopicTag delete
   */
  export type TopicTagDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TopicTag
     */
    select?: TopicTagSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TopicTag
     */
    omit?: TopicTagOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicTagInclude<ExtArgs> | null;
    /**
     * Filter which TopicTag to delete.
     */
    where: TopicTagWhereUniqueInput;
  };

  /**
   * TopicTag deleteMany
   */
  export type TopicTagDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which TopicTags to delete
     */
    where?: TopicTagWhereInput;
    /**
     * Limit how many TopicTags to delete.
     */
    limit?: number;
  };

  /**
   * TopicTag findRaw
   */
  export type TopicTagFindRawArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue;
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue;
  };

  /**
   * TopicTag aggregateRaw
   */
  export type TopicTagAggregateRawArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[];
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue;
  };

  /**
   * TopicTag without action
   */
  export type TopicTagDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TopicTag
     */
    select?: TopicTagSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TopicTag
     */
    omit?: TopicTagOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicTagInclude<ExtArgs> | null;
  };

  /**
   * Model ItemTag
   */

  export type AggregateItemTag = {
    _count: ItemTagCountAggregateOutputType | null;
    _min: ItemTagMinAggregateOutputType | null;
    _max: ItemTagMaxAggregateOutputType | null;
  };

  export type ItemTagMinAggregateOutputType = {
    id: string | null;
    itemId: string | null;
    tagId: string | null;
  };

  export type ItemTagMaxAggregateOutputType = {
    id: string | null;
    itemId: string | null;
    tagId: string | null;
  };

  export type ItemTagCountAggregateOutputType = {
    id: number;
    itemId: number;
    tagId: number;
    _all: number;
  };

  export type ItemTagMinAggregateInputType = {
    id?: true;
    itemId?: true;
    tagId?: true;
  };

  export type ItemTagMaxAggregateInputType = {
    id?: true;
    itemId?: true;
    tagId?: true;
  };

  export type ItemTagCountAggregateInputType = {
    id?: true;
    itemId?: true;
    tagId?: true;
    _all?: true;
  };

  export type ItemTagAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which ItemTag to aggregate.
     */
    where?: ItemTagWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ItemTags to fetch.
     */
    orderBy?:
      | ItemTagOrderByWithRelationInput
      | ItemTagOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: ItemTagWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ItemTags from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ItemTags.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned ItemTags
     **/
    _count?: true | ItemTagCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: ItemTagMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: ItemTagMaxAggregateInputType;
  };

  export type GetItemTagAggregateType<T extends ItemTagAggregateArgs> = {
    [P in keyof T & keyof AggregateItemTag]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateItemTag[P]>
      : GetScalarType<T[P], AggregateItemTag[P]>;
  };

  export type ItemTagGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ItemTagWhereInput;
    orderBy?:
      | ItemTagOrderByWithAggregationInput
      | ItemTagOrderByWithAggregationInput[];
    by: ItemTagScalarFieldEnum[] | ItemTagScalarFieldEnum;
    having?: ItemTagScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: ItemTagCountAggregateInputType | true;
    _min?: ItemTagMinAggregateInputType;
    _max?: ItemTagMaxAggregateInputType;
  };

  export type ItemTagGroupByOutputType = {
    id: string;
    itemId: string;
    tagId: string;
    _count: ItemTagCountAggregateOutputType | null;
    _min: ItemTagMinAggregateOutputType | null;
    _max: ItemTagMaxAggregateOutputType | null;
  };

  type GetItemTagGroupByPayload<T extends ItemTagGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<ItemTagGroupByOutputType, T["by"]> & {
          [P in keyof T & keyof ItemTagGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ItemTagGroupByOutputType[P]>
            : GetScalarType<T[P], ItemTagGroupByOutputType[P]>;
        }
      >
    >;

  export type ItemTagSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      itemId?: boolean;
      tagId?: boolean;
      item?: boolean | ContentItemDefaultArgs<ExtArgs>;
      tag?: boolean | TagDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["itemTag"]
  >;

  export type ItemTagSelectScalar = {
    id?: boolean;
    itemId?: boolean;
    tagId?: boolean;
  };

  export type ItemTagOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    "id" | "itemId" | "tagId",
    ExtArgs["result"]["itemTag"]
  >;
  export type ItemTagInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    item?: boolean | ContentItemDefaultArgs<ExtArgs>;
    tag?: boolean | TagDefaultArgs<ExtArgs>;
  };

  export type $ItemTagPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "ItemTag";
    objects: {
      item: Prisma.$ContentItemPayload<ExtArgs>;
      tag: Prisma.$TagPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        itemId: string;
        tagId: string;
      },
      ExtArgs["result"]["itemTag"]
    >;
    composites: {};
  };

  type ItemTagGetPayload<
    S extends boolean | null | undefined | ItemTagDefaultArgs,
  > = $Result.GetResult<Prisma.$ItemTagPayload, S>;

  type ItemTagCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<ItemTagFindManyArgs, "select" | "include" | "distinct" | "omit"> & {
    select?: ItemTagCountAggregateInputType | true;
  };

  export interface ItemTagDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["ItemTag"];
      meta: { name: "ItemTag" };
    };
    /**
     * Find zero or one ItemTag that matches the filter.
     * @param {ItemTagFindUniqueArgs} args - Arguments to find a ItemTag
     * @example
     * // Get one ItemTag
     * const itemTag = await prisma.itemTag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ItemTagFindUniqueArgs>(
      args: SelectSubset<T, ItemTagFindUniqueArgs<ExtArgs>>,
    ): Prisma__ItemTagClient<
      $Result.GetResult<
        Prisma.$ItemTagPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one ItemTag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ItemTagFindUniqueOrThrowArgs} args - Arguments to find a ItemTag
     * @example
     * // Get one ItemTag
     * const itemTag = await prisma.itemTag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ItemTagFindUniqueOrThrowArgs>(
      args: SelectSubset<T, ItemTagFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__ItemTagClient<
      $Result.GetResult<
        Prisma.$ItemTagPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first ItemTag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemTagFindFirstArgs} args - Arguments to find a ItemTag
     * @example
     * // Get one ItemTag
     * const itemTag = await prisma.itemTag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ItemTagFindFirstArgs>(
      args?: SelectSubset<T, ItemTagFindFirstArgs<ExtArgs>>,
    ): Prisma__ItemTagClient<
      $Result.GetResult<
        Prisma.$ItemTagPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first ItemTag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemTagFindFirstOrThrowArgs} args - Arguments to find a ItemTag
     * @example
     * // Get one ItemTag
     * const itemTag = await prisma.itemTag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ItemTagFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ItemTagFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__ItemTagClient<
      $Result.GetResult<
        Prisma.$ItemTagPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more ItemTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemTagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ItemTags
     * const itemTags = await prisma.itemTag.findMany()
     *
     * // Get first 10 ItemTags
     * const itemTags = await prisma.itemTag.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const itemTagWithIdOnly = await prisma.itemTag.findMany({ select: { id: true } })
     *
     */
    findMany<T extends ItemTagFindManyArgs>(
      args?: SelectSubset<T, ItemTagFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ItemTagPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a ItemTag.
     * @param {ItemTagCreateArgs} args - Arguments to create a ItemTag.
     * @example
     * // Create one ItemTag
     * const ItemTag = await prisma.itemTag.create({
     *   data: {
     *     // ... data to create a ItemTag
     *   }
     * })
     *
     */
    create<T extends ItemTagCreateArgs>(
      args: SelectSubset<T, ItemTagCreateArgs<ExtArgs>>,
    ): Prisma__ItemTagClient<
      $Result.GetResult<
        Prisma.$ItemTagPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many ItemTags.
     * @param {ItemTagCreateManyArgs} args - Arguments to create many ItemTags.
     * @example
     * // Create many ItemTags
     * const itemTag = await prisma.itemTag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends ItemTagCreateManyArgs>(
      args?: SelectSubset<T, ItemTagCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a ItemTag.
     * @param {ItemTagDeleteArgs} args - Arguments to delete one ItemTag.
     * @example
     * // Delete one ItemTag
     * const ItemTag = await prisma.itemTag.delete({
     *   where: {
     *     // ... filter to delete one ItemTag
     *   }
     * })
     *
     */
    delete<T extends ItemTagDeleteArgs>(
      args: SelectSubset<T, ItemTagDeleteArgs<ExtArgs>>,
    ): Prisma__ItemTagClient<
      $Result.GetResult<
        Prisma.$ItemTagPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one ItemTag.
     * @param {ItemTagUpdateArgs} args - Arguments to update one ItemTag.
     * @example
     * // Update one ItemTag
     * const itemTag = await prisma.itemTag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends ItemTagUpdateArgs>(
      args: SelectSubset<T, ItemTagUpdateArgs<ExtArgs>>,
    ): Prisma__ItemTagClient<
      $Result.GetResult<
        Prisma.$ItemTagPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more ItemTags.
     * @param {ItemTagDeleteManyArgs} args - Arguments to filter ItemTags to delete.
     * @example
     * // Delete a few ItemTags
     * const { count } = await prisma.itemTag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends ItemTagDeleteManyArgs>(
      args?: SelectSubset<T, ItemTagDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more ItemTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemTagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ItemTags
     * const itemTag = await prisma.itemTag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends ItemTagUpdateManyArgs>(
      args: SelectSubset<T, ItemTagUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one ItemTag.
     * @param {ItemTagUpsertArgs} args - Arguments to update or create a ItemTag.
     * @example
     * // Update or create a ItemTag
     * const itemTag = await prisma.itemTag.upsert({
     *   create: {
     *     // ... data to create a ItemTag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ItemTag we want to update
     *   }
     * })
     */
    upsert<T extends ItemTagUpsertArgs>(
      args: SelectSubset<T, ItemTagUpsertArgs<ExtArgs>>,
    ): Prisma__ItemTagClient<
      $Result.GetResult<
        Prisma.$ItemTagPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more ItemTags that matches the filter.
     * @param {ItemTagFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const itemTag = await prisma.itemTag.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: ItemTagFindRawArgs): Prisma.PrismaPromise<JsonObject>;

    /**
     * Perform aggregation operations on a ItemTag.
     * @param {ItemTagAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const itemTag = await prisma.itemTag.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(
      args?: ItemTagAggregateRawArgs,
    ): Prisma.PrismaPromise<JsonObject>;

    /**
     * Count the number of ItemTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemTagCountArgs} args - Arguments to filter ItemTags to count.
     * @example
     * // Count the number of ItemTags
     * const count = await prisma.itemTag.count({
     *   where: {
     *     // ... the filter for the ItemTags we want to count
     *   }
     * })
     **/
    count<T extends ItemTagCountArgs>(
      args?: Subset<T, ItemTagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], ItemTagCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a ItemTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemTagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends ItemTagAggregateArgs>(
      args: Subset<T, ItemTagAggregateArgs>,
    ): Prisma.PrismaPromise<GetItemTagAggregateType<T>>;

    /**
     * Group by ItemTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemTagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends ItemTagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ItemTagGroupByArgs["orderBy"] }
        : { orderBy?: ItemTagGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, ItemTagGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetItemTagGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the ItemTag model
     */
    readonly fields: ItemTagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ItemTag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ItemTagClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    item<T extends ContentItemDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, ContentItemDefaultArgs<ExtArgs>>,
    ): Prisma__ContentItemClient<
      | $Result.GetResult<
          Prisma.$ContentItemPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    tag<T extends TagDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, TagDefaultArgs<ExtArgs>>,
    ): Prisma__TagClient<
      | $Result.GetResult<
          Prisma.$TagPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the ItemTag model
   */
  interface ItemTagFieldRefs {
    readonly id: FieldRef<"ItemTag", "String">;
    readonly itemId: FieldRef<"ItemTag", "String">;
    readonly tagId: FieldRef<"ItemTag", "String">;
  }

  // Custom InputTypes
  /**
   * ItemTag findUnique
   */
  export type ItemTagFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ItemTag
     */
    select?: ItemTagSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ItemTag
     */
    omit?: ItemTagOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemTagInclude<ExtArgs> | null;
    /**
     * Filter, which ItemTag to fetch.
     */
    where: ItemTagWhereUniqueInput;
  };

  /**
   * ItemTag findUniqueOrThrow
   */
  export type ItemTagFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ItemTag
     */
    select?: ItemTagSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ItemTag
     */
    omit?: ItemTagOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemTagInclude<ExtArgs> | null;
    /**
     * Filter, which ItemTag to fetch.
     */
    where: ItemTagWhereUniqueInput;
  };

  /**
   * ItemTag findFirst
   */
  export type ItemTagFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ItemTag
     */
    select?: ItemTagSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ItemTag
     */
    omit?: ItemTagOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemTagInclude<ExtArgs> | null;
    /**
     * Filter, which ItemTag to fetch.
     */
    where?: ItemTagWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ItemTags to fetch.
     */
    orderBy?:
      | ItemTagOrderByWithRelationInput
      | ItemTagOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ItemTags.
     */
    cursor?: ItemTagWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ItemTags from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ItemTags.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ItemTags.
     */
    distinct?: ItemTagScalarFieldEnum | ItemTagScalarFieldEnum[];
  };

  /**
   * ItemTag findFirstOrThrow
   */
  export type ItemTagFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ItemTag
     */
    select?: ItemTagSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ItemTag
     */
    omit?: ItemTagOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemTagInclude<ExtArgs> | null;
    /**
     * Filter, which ItemTag to fetch.
     */
    where?: ItemTagWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ItemTags to fetch.
     */
    orderBy?:
      | ItemTagOrderByWithRelationInput
      | ItemTagOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ItemTags.
     */
    cursor?: ItemTagWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ItemTags from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ItemTags.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ItemTags.
     */
    distinct?: ItemTagScalarFieldEnum | ItemTagScalarFieldEnum[];
  };

  /**
   * ItemTag findMany
   */
  export type ItemTagFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ItemTag
     */
    select?: ItemTagSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ItemTag
     */
    omit?: ItemTagOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemTagInclude<ExtArgs> | null;
    /**
     * Filter, which ItemTags to fetch.
     */
    where?: ItemTagWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ItemTags to fetch.
     */
    orderBy?:
      | ItemTagOrderByWithRelationInput
      | ItemTagOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing ItemTags.
     */
    cursor?: ItemTagWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ItemTags from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ItemTags.
     */
    skip?: number;
    distinct?: ItemTagScalarFieldEnum | ItemTagScalarFieldEnum[];
  };

  /**
   * ItemTag create
   */
  export type ItemTagCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ItemTag
     */
    select?: ItemTagSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ItemTag
     */
    omit?: ItemTagOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemTagInclude<ExtArgs> | null;
    /**
     * The data needed to create a ItemTag.
     */
    data: XOR<ItemTagCreateInput, ItemTagUncheckedCreateInput>;
  };

  /**
   * ItemTag createMany
   */
  export type ItemTagCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many ItemTags.
     */
    data: ItemTagCreateManyInput | ItemTagCreateManyInput[];
  };

  /**
   * ItemTag update
   */
  export type ItemTagUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ItemTag
     */
    select?: ItemTagSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ItemTag
     */
    omit?: ItemTagOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemTagInclude<ExtArgs> | null;
    /**
     * The data needed to update a ItemTag.
     */
    data: XOR<ItemTagUpdateInput, ItemTagUncheckedUpdateInput>;
    /**
     * Choose, which ItemTag to update.
     */
    where: ItemTagWhereUniqueInput;
  };

  /**
   * ItemTag updateMany
   */
  export type ItemTagUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update ItemTags.
     */
    data: XOR<ItemTagUpdateManyMutationInput, ItemTagUncheckedUpdateManyInput>;
    /**
     * Filter which ItemTags to update
     */
    where?: ItemTagWhereInput;
    /**
     * Limit how many ItemTags to update.
     */
    limit?: number;
  };

  /**
   * ItemTag upsert
   */
  export type ItemTagUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ItemTag
     */
    select?: ItemTagSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ItemTag
     */
    omit?: ItemTagOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemTagInclude<ExtArgs> | null;
    /**
     * The filter to search for the ItemTag to update in case it exists.
     */
    where: ItemTagWhereUniqueInput;
    /**
     * In case the ItemTag found by the `where` argument doesn't exist, create a new ItemTag with this data.
     */
    create: XOR<ItemTagCreateInput, ItemTagUncheckedCreateInput>;
    /**
     * In case the ItemTag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ItemTagUpdateInput, ItemTagUncheckedUpdateInput>;
  };

  /**
   * ItemTag delete
   */
  export type ItemTagDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ItemTag
     */
    select?: ItemTagSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ItemTag
     */
    omit?: ItemTagOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemTagInclude<ExtArgs> | null;
    /**
     * Filter which ItemTag to delete.
     */
    where: ItemTagWhereUniqueInput;
  };

  /**
   * ItemTag deleteMany
   */
  export type ItemTagDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which ItemTags to delete
     */
    where?: ItemTagWhereInput;
    /**
     * Limit how many ItemTags to delete.
     */
    limit?: number;
  };

  /**
   * ItemTag findRaw
   */
  export type ItemTagFindRawArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue;
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue;
  };

  /**
   * ItemTag aggregateRaw
   */
  export type ItemTagAggregateRawArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[];
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue;
  };

  /**
   * ItemTag without action
   */
  export type ItemTagDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ItemTag
     */
    select?: ItemTagSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ItemTag
     */
    omit?: ItemTagOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemTagInclude<ExtArgs> | null;
  };

  /**
   * Model Region
   */

  export type AggregateRegion = {
    _count: RegionCountAggregateOutputType | null;
    _avg: RegionAvgAggregateOutputType | null;
    _sum: RegionSumAggregateOutputType | null;
    _min: RegionMinAggregateOutputType | null;
    _max: RegionMaxAggregateOutputType | null;
  };

  export type RegionAvgAggregateOutputType = {
    level: number | null;
  };

  export type RegionSumAggregateOutputType = {
    level: number | null;
  };

  export type RegionMinAggregateOutputType = {
    id: string | null;
    code: string | null;
    name: string | null;
    level: number | null;
    parentId: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type RegionMaxAggregateOutputType = {
    id: string | null;
    code: string | null;
    name: string | null;
    level: number | null;
    parentId: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type RegionCountAggregateOutputType = {
    id: number;
    code: number;
    name: number;
    level: number;
    parentId: number;
    meta: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type RegionAvgAggregateInputType = {
    level?: true;
  };

  export type RegionSumAggregateInputType = {
    level?: true;
  };

  export type RegionMinAggregateInputType = {
    id?: true;
    code?: true;
    name?: true;
    level?: true;
    parentId?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type RegionMaxAggregateInputType = {
    id?: true;
    code?: true;
    name?: true;
    level?: true;
    parentId?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type RegionCountAggregateInputType = {
    id?: true;
    code?: true;
    name?: true;
    level?: true;
    parentId?: true;
    meta?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type RegionAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Region to aggregate.
     */
    where?: RegionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Regions to fetch.
     */
    orderBy?: RegionOrderByWithRelationInput | RegionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: RegionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Regions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Regions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Regions
     **/
    _count?: true | RegionCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: RegionAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: RegionSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: RegionMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: RegionMaxAggregateInputType;
  };

  export type GetRegionAggregateType<T extends RegionAggregateArgs> = {
    [P in keyof T & keyof AggregateRegion]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRegion[P]>
      : GetScalarType<T[P], AggregateRegion[P]>;
  };

  export type RegionGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: RegionWhereInput;
    orderBy?:
      | RegionOrderByWithAggregationInput
      | RegionOrderByWithAggregationInput[];
    by: RegionScalarFieldEnum[] | RegionScalarFieldEnum;
    having?: RegionScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: RegionCountAggregateInputType | true;
    _avg?: RegionAvgAggregateInputType;
    _sum?: RegionSumAggregateInputType;
    _min?: RegionMinAggregateInputType;
    _max?: RegionMaxAggregateInputType;
  };

  export type RegionGroupByOutputType = {
    id: string;
    code: string;
    name: string;
    level: number;
    parentId: string | null;
    meta: JsonValue | null;
    createdAt: Date;
    updatedAt: Date;
    _count: RegionCountAggregateOutputType | null;
    _avg: RegionAvgAggregateOutputType | null;
    _sum: RegionSumAggregateOutputType | null;
    _min: RegionMinAggregateOutputType | null;
    _max: RegionMaxAggregateOutputType | null;
  };

  type GetRegionGroupByPayload<T extends RegionGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<RegionGroupByOutputType, T["by"]> & {
          [P in keyof T & keyof RegionGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RegionGroupByOutputType[P]>
            : GetScalarType<T[P], RegionGroupByOutputType[P]>;
        }
      >
    >;

  export type RegionSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      code?: boolean;
      name?: boolean;
      level?: boolean;
      parentId?: boolean;
      meta?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      parent?: boolean | Region$parentArgs<ExtArgs>;
      children?: boolean | Region$childrenArgs<ExtArgs>;
      itemsManual?: boolean | Region$itemsManualArgs<ExtArgs>;
      itemsEffective?: boolean | Region$itemsEffectiveArgs<ExtArgs>;
      ancestors?: boolean | Region$ancestorsArgs<ExtArgs>;
      descendants?: boolean | Region$descendantsArgs<ExtArgs>;
      _count?: boolean | RegionCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["region"]
  >;

  export type RegionSelectScalar = {
    id?: boolean;
    code?: boolean;
    name?: boolean;
    level?: boolean;
    parentId?: boolean;
    meta?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type RegionOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | "id"
    | "code"
    | "name"
    | "level"
    | "parentId"
    | "meta"
    | "createdAt"
    | "updatedAt",
    ExtArgs["result"]["region"]
  >;
  export type RegionInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    parent?: boolean | Region$parentArgs<ExtArgs>;
    children?: boolean | Region$childrenArgs<ExtArgs>;
    itemsManual?: boolean | Region$itemsManualArgs<ExtArgs>;
    itemsEffective?: boolean | Region$itemsEffectiveArgs<ExtArgs>;
    ancestors?: boolean | Region$ancestorsArgs<ExtArgs>;
    descendants?: boolean | Region$descendantsArgs<ExtArgs>;
    _count?: boolean | RegionCountOutputTypeDefaultArgs<ExtArgs>;
  };

  export type $RegionPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "Region";
    objects: {
      parent: Prisma.$RegionPayload<ExtArgs> | null;
      children: Prisma.$RegionPayload<ExtArgs>[];
      itemsManual: Prisma.$ContentItemPayload<ExtArgs>[];
      itemsEffective: Prisma.$ContentItemPayload<ExtArgs>[];
      ancestors: Prisma.$RegionClosurePayload<ExtArgs>[];
      descendants: Prisma.$RegionClosurePayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        code: string;
        name: string;
        level: number;
        parentId: string | null;
        meta: Prisma.JsonValue | null;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs["result"]["region"]
    >;
    composites: {};
  };

  type RegionGetPayload<
    S extends boolean | null | undefined | RegionDefaultArgs,
  > = $Result.GetResult<Prisma.$RegionPayload, S>;

  type RegionCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<RegionFindManyArgs, "select" | "include" | "distinct" | "omit"> & {
    select?: RegionCountAggregateInputType | true;
  };

  export interface RegionDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["Region"];
      meta: { name: "Region" };
    };
    /**
     * Find zero or one Region that matches the filter.
     * @param {RegionFindUniqueArgs} args - Arguments to find a Region
     * @example
     * // Get one Region
     * const region = await prisma.region.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RegionFindUniqueArgs>(
      args: SelectSubset<T, RegionFindUniqueArgs<ExtArgs>>,
    ): Prisma__RegionClient<
      $Result.GetResult<
        Prisma.$RegionPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Region that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RegionFindUniqueOrThrowArgs} args - Arguments to find a Region
     * @example
     * // Get one Region
     * const region = await prisma.region.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RegionFindUniqueOrThrowArgs>(
      args: SelectSubset<T, RegionFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__RegionClient<
      $Result.GetResult<
        Prisma.$RegionPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Region that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionFindFirstArgs} args - Arguments to find a Region
     * @example
     * // Get one Region
     * const region = await prisma.region.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RegionFindFirstArgs>(
      args?: SelectSubset<T, RegionFindFirstArgs<ExtArgs>>,
    ): Prisma__RegionClient<
      $Result.GetResult<
        Prisma.$RegionPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Region that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionFindFirstOrThrowArgs} args - Arguments to find a Region
     * @example
     * // Get one Region
     * const region = await prisma.region.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RegionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, RegionFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__RegionClient<
      $Result.GetResult<
        Prisma.$RegionPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Regions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Regions
     * const regions = await prisma.region.findMany()
     *
     * // Get first 10 Regions
     * const regions = await prisma.region.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const regionWithIdOnly = await prisma.region.findMany({ select: { id: true } })
     *
     */
    findMany<T extends RegionFindManyArgs>(
      args?: SelectSubset<T, RegionFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$RegionPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Region.
     * @param {RegionCreateArgs} args - Arguments to create a Region.
     * @example
     * // Create one Region
     * const Region = await prisma.region.create({
     *   data: {
     *     // ... data to create a Region
     *   }
     * })
     *
     */
    create<T extends RegionCreateArgs>(
      args: SelectSubset<T, RegionCreateArgs<ExtArgs>>,
    ): Prisma__RegionClient<
      $Result.GetResult<
        Prisma.$RegionPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Regions.
     * @param {RegionCreateManyArgs} args - Arguments to create many Regions.
     * @example
     * // Create many Regions
     * const region = await prisma.region.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends RegionCreateManyArgs>(
      args?: SelectSubset<T, RegionCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a Region.
     * @param {RegionDeleteArgs} args - Arguments to delete one Region.
     * @example
     * // Delete one Region
     * const Region = await prisma.region.delete({
     *   where: {
     *     // ... filter to delete one Region
     *   }
     * })
     *
     */
    delete<T extends RegionDeleteArgs>(
      args: SelectSubset<T, RegionDeleteArgs<ExtArgs>>,
    ): Prisma__RegionClient<
      $Result.GetResult<
        Prisma.$RegionPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Region.
     * @param {RegionUpdateArgs} args - Arguments to update one Region.
     * @example
     * // Update one Region
     * const region = await prisma.region.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends RegionUpdateArgs>(
      args: SelectSubset<T, RegionUpdateArgs<ExtArgs>>,
    ): Prisma__RegionClient<
      $Result.GetResult<
        Prisma.$RegionPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Regions.
     * @param {RegionDeleteManyArgs} args - Arguments to filter Regions to delete.
     * @example
     * // Delete a few Regions
     * const { count } = await prisma.region.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends RegionDeleteManyArgs>(
      args?: SelectSubset<T, RegionDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Regions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Regions
     * const region = await prisma.region.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends RegionUpdateManyArgs>(
      args: SelectSubset<T, RegionUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one Region.
     * @param {RegionUpsertArgs} args - Arguments to update or create a Region.
     * @example
     * // Update or create a Region
     * const region = await prisma.region.upsert({
     *   create: {
     *     // ... data to create a Region
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Region we want to update
     *   }
     * })
     */
    upsert<T extends RegionUpsertArgs>(
      args: SelectSubset<T, RegionUpsertArgs<ExtArgs>>,
    ): Prisma__RegionClient<
      $Result.GetResult<
        Prisma.$RegionPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Regions that matches the filter.
     * @param {RegionFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const region = await prisma.region.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: RegionFindRawArgs): Prisma.PrismaPromise<JsonObject>;

    /**
     * Perform aggregation operations on a Region.
     * @param {RegionAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const region = await prisma.region.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(
      args?: RegionAggregateRawArgs,
    ): Prisma.PrismaPromise<JsonObject>;

    /**
     * Count the number of Regions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionCountArgs} args - Arguments to filter Regions to count.
     * @example
     * // Count the number of Regions
     * const count = await prisma.region.count({
     *   where: {
     *     // ... the filter for the Regions we want to count
     *   }
     * })
     **/
    count<T extends RegionCountArgs>(
      args?: Subset<T, RegionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], RegionCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Region.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends RegionAggregateArgs>(
      args: Subset<T, RegionAggregateArgs>,
    ): Prisma.PrismaPromise<GetRegionAggregateType<T>>;

    /**
     * Group by Region.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends RegionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RegionGroupByArgs["orderBy"] }
        : { orderBy?: RegionGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, RegionGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetRegionGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Region model
     */
    readonly fields: RegionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Region.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RegionClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    parent<T extends Region$parentArgs<ExtArgs> = {}>(
      args?: Subset<T, Region$parentArgs<ExtArgs>>,
    ): Prisma__RegionClient<
      $Result.GetResult<
        Prisma.$RegionPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    children<T extends Region$childrenArgs<ExtArgs> = {}>(
      args?: Subset<T, Region$childrenArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$RegionPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    itemsManual<T extends Region$itemsManualArgs<ExtArgs> = {}>(
      args?: Subset<T, Region$itemsManualArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$ContentItemPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    itemsEffective<T extends Region$itemsEffectiveArgs<ExtArgs> = {}>(
      args?: Subset<T, Region$itemsEffectiveArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$ContentItemPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    ancestors<T extends Region$ancestorsArgs<ExtArgs> = {}>(
      args?: Subset<T, Region$ancestorsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$RegionClosurePayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    descendants<T extends Region$descendantsArgs<ExtArgs> = {}>(
      args?: Subset<T, Region$descendantsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$RegionClosurePayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Region model
   */
  interface RegionFieldRefs {
    readonly id: FieldRef<"Region", "String">;
    readonly code: FieldRef<"Region", "String">;
    readonly name: FieldRef<"Region", "String">;
    readonly level: FieldRef<"Region", "Int">;
    readonly parentId: FieldRef<"Region", "String">;
    readonly meta: FieldRef<"Region", "Json">;
    readonly createdAt: FieldRef<"Region", "DateTime">;
    readonly updatedAt: FieldRef<"Region", "DateTime">;
  }

  // Custom InputTypes
  /**
   * Region findUnique
   */
  export type RegionFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Region
     */
    omit?: RegionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null;
    /**
     * Filter, which Region to fetch.
     */
    where: RegionWhereUniqueInput;
  };

  /**
   * Region findUniqueOrThrow
   */
  export type RegionFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Region
     */
    omit?: RegionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null;
    /**
     * Filter, which Region to fetch.
     */
    where: RegionWhereUniqueInput;
  };

  /**
   * Region findFirst
   */
  export type RegionFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Region
     */
    omit?: RegionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null;
    /**
     * Filter, which Region to fetch.
     */
    where?: RegionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Regions to fetch.
     */
    orderBy?: RegionOrderByWithRelationInput | RegionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Regions.
     */
    cursor?: RegionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Regions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Regions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Regions.
     */
    distinct?: RegionScalarFieldEnum | RegionScalarFieldEnum[];
  };

  /**
   * Region findFirstOrThrow
   */
  export type RegionFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Region
     */
    omit?: RegionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null;
    /**
     * Filter, which Region to fetch.
     */
    where?: RegionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Regions to fetch.
     */
    orderBy?: RegionOrderByWithRelationInput | RegionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Regions.
     */
    cursor?: RegionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Regions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Regions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Regions.
     */
    distinct?: RegionScalarFieldEnum | RegionScalarFieldEnum[];
  };

  /**
   * Region findMany
   */
  export type RegionFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Region
     */
    omit?: RegionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null;
    /**
     * Filter, which Regions to fetch.
     */
    where?: RegionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Regions to fetch.
     */
    orderBy?: RegionOrderByWithRelationInput | RegionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Regions.
     */
    cursor?: RegionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Regions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Regions.
     */
    skip?: number;
    distinct?: RegionScalarFieldEnum | RegionScalarFieldEnum[];
  };

  /**
   * Region create
   */
  export type RegionCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Region
     */
    omit?: RegionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null;
    /**
     * The data needed to create a Region.
     */
    data: XOR<RegionCreateInput, RegionUncheckedCreateInput>;
  };

  /**
   * Region createMany
   */
  export type RegionCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Regions.
     */
    data: RegionCreateManyInput | RegionCreateManyInput[];
  };

  /**
   * Region update
   */
  export type RegionUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Region
     */
    omit?: RegionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null;
    /**
     * The data needed to update a Region.
     */
    data: XOR<RegionUpdateInput, RegionUncheckedUpdateInput>;
    /**
     * Choose, which Region to update.
     */
    where: RegionWhereUniqueInput;
  };

  /**
   * Region updateMany
   */
  export type RegionUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Regions.
     */
    data: XOR<RegionUpdateManyMutationInput, RegionUncheckedUpdateManyInput>;
    /**
     * Filter which Regions to update
     */
    where?: RegionWhereInput;
    /**
     * Limit how many Regions to update.
     */
    limit?: number;
  };

  /**
   * Region upsert
   */
  export type RegionUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Region
     */
    omit?: RegionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null;
    /**
     * The filter to search for the Region to update in case it exists.
     */
    where: RegionWhereUniqueInput;
    /**
     * In case the Region found by the `where` argument doesn't exist, create a new Region with this data.
     */
    create: XOR<RegionCreateInput, RegionUncheckedCreateInput>;
    /**
     * In case the Region was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RegionUpdateInput, RegionUncheckedUpdateInput>;
  };

  /**
   * Region delete
   */
  export type RegionDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Region
     */
    omit?: RegionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null;
    /**
     * Filter which Region to delete.
     */
    where: RegionWhereUniqueInput;
  };

  /**
   * Region deleteMany
   */
  export type RegionDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Regions to delete
     */
    where?: RegionWhereInput;
    /**
     * Limit how many Regions to delete.
     */
    limit?: number;
  };

  /**
   * Region findRaw
   */
  export type RegionFindRawArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue;
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue;
  };

  /**
   * Region aggregateRaw
   */
  export type RegionAggregateRawArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[];
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue;
  };

  /**
   * Region.parent
   */
  export type Region$parentArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Region
     */
    omit?: RegionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null;
    where?: RegionWhereInput;
  };

  /**
   * Region.children
   */
  export type Region$childrenArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Region
     */
    omit?: RegionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null;
    where?: RegionWhereInput;
    orderBy?: RegionOrderByWithRelationInput | RegionOrderByWithRelationInput[];
    cursor?: RegionWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: RegionScalarFieldEnum | RegionScalarFieldEnum[];
  };

  /**
   * Region.itemsManual
   */
  export type Region$itemsManualArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ContentItem
     */
    select?: ContentItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ContentItem
     */
    omit?: ContentItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentItemInclude<ExtArgs> | null;
    where?: ContentItemWhereInput;
    orderBy?:
      | ContentItemOrderByWithRelationInput
      | ContentItemOrderByWithRelationInput[];
    cursor?: ContentItemWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ContentItemScalarFieldEnum | ContentItemScalarFieldEnum[];
  };

  /**
   * Region.itemsEffective
   */
  export type Region$itemsEffectiveArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ContentItem
     */
    select?: ContentItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ContentItem
     */
    omit?: ContentItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentItemInclude<ExtArgs> | null;
    where?: ContentItemWhereInput;
    orderBy?:
      | ContentItemOrderByWithRelationInput
      | ContentItemOrderByWithRelationInput[];
    cursor?: ContentItemWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ContentItemScalarFieldEnum | ContentItemScalarFieldEnum[];
  };

  /**
   * Region.ancestors
   */
  export type Region$ancestorsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the RegionClosure
     */
    select?: RegionClosureSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the RegionClosure
     */
    omit?: RegionClosureOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionClosureInclude<ExtArgs> | null;
    where?: RegionClosureWhereInput;
    orderBy?:
      | RegionClosureOrderByWithRelationInput
      | RegionClosureOrderByWithRelationInput[];
    cursor?: RegionClosureWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: RegionClosureScalarFieldEnum | RegionClosureScalarFieldEnum[];
  };

  /**
   * Region.descendants
   */
  export type Region$descendantsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the RegionClosure
     */
    select?: RegionClosureSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the RegionClosure
     */
    omit?: RegionClosureOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionClosureInclude<ExtArgs> | null;
    where?: RegionClosureWhereInput;
    orderBy?:
      | RegionClosureOrderByWithRelationInput
      | RegionClosureOrderByWithRelationInput[];
    cursor?: RegionClosureWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: RegionClosureScalarFieldEnum | RegionClosureScalarFieldEnum[];
  };

  /**
   * Region without action
   */
  export type RegionDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Region
     */
    omit?: RegionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null;
  };

  /**
   * Model RegionClosure
   */

  export type AggregateRegionClosure = {
    _count: RegionClosureCountAggregateOutputType | null;
    _avg: RegionClosureAvgAggregateOutputType | null;
    _sum: RegionClosureSumAggregateOutputType | null;
    _min: RegionClosureMinAggregateOutputType | null;
    _max: RegionClosureMaxAggregateOutputType | null;
  };

  export type RegionClosureAvgAggregateOutputType = {
    depth: number | null;
  };

  export type RegionClosureSumAggregateOutputType = {
    depth: number | null;
  };

  export type RegionClosureMinAggregateOutputType = {
    id: string | null;
    ancestorId: string | null;
    descendantId: string | null;
    depth: number | null;
  };

  export type RegionClosureMaxAggregateOutputType = {
    id: string | null;
    ancestorId: string | null;
    descendantId: string | null;
    depth: number | null;
  };

  export type RegionClosureCountAggregateOutputType = {
    id: number;
    ancestorId: number;
    descendantId: number;
    depth: number;
    _all: number;
  };

  export type RegionClosureAvgAggregateInputType = {
    depth?: true;
  };

  export type RegionClosureSumAggregateInputType = {
    depth?: true;
  };

  export type RegionClosureMinAggregateInputType = {
    id?: true;
    ancestorId?: true;
    descendantId?: true;
    depth?: true;
  };

  export type RegionClosureMaxAggregateInputType = {
    id?: true;
    ancestorId?: true;
    descendantId?: true;
    depth?: true;
  };

  export type RegionClosureCountAggregateInputType = {
    id?: true;
    ancestorId?: true;
    descendantId?: true;
    depth?: true;
    _all?: true;
  };

  export type RegionClosureAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which RegionClosure to aggregate.
     */
    where?: RegionClosureWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of RegionClosures to fetch.
     */
    orderBy?:
      | RegionClosureOrderByWithRelationInput
      | RegionClosureOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: RegionClosureWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` RegionClosures from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` RegionClosures.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned RegionClosures
     **/
    _count?: true | RegionClosureCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: RegionClosureAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: RegionClosureSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: RegionClosureMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: RegionClosureMaxAggregateInputType;
  };

  export type GetRegionClosureAggregateType<
    T extends RegionClosureAggregateArgs,
  > = {
    [P in keyof T & keyof AggregateRegionClosure]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRegionClosure[P]>
      : GetScalarType<T[P], AggregateRegionClosure[P]>;
  };

  export type RegionClosureGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: RegionClosureWhereInput;
    orderBy?:
      | RegionClosureOrderByWithAggregationInput
      | RegionClosureOrderByWithAggregationInput[];
    by: RegionClosureScalarFieldEnum[] | RegionClosureScalarFieldEnum;
    having?: RegionClosureScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: RegionClosureCountAggregateInputType | true;
    _avg?: RegionClosureAvgAggregateInputType;
    _sum?: RegionClosureSumAggregateInputType;
    _min?: RegionClosureMinAggregateInputType;
    _max?: RegionClosureMaxAggregateInputType;
  };

  export type RegionClosureGroupByOutputType = {
    id: string;
    ancestorId: string;
    descendantId: string;
    depth: number;
    _count: RegionClosureCountAggregateOutputType | null;
    _avg: RegionClosureAvgAggregateOutputType | null;
    _sum: RegionClosureSumAggregateOutputType | null;
    _min: RegionClosureMinAggregateOutputType | null;
    _max: RegionClosureMaxAggregateOutputType | null;
  };

  type GetRegionClosureGroupByPayload<T extends RegionClosureGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<RegionClosureGroupByOutputType, T["by"]> & {
          [P in keyof T &
            keyof RegionClosureGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RegionClosureGroupByOutputType[P]>
            : GetScalarType<T[P], RegionClosureGroupByOutputType[P]>;
        }
      >
    >;

  export type RegionClosureSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      ancestorId?: boolean;
      descendantId?: boolean;
      depth?: boolean;
      ancestor?: boolean | RegionDefaultArgs<ExtArgs>;
      descendant?: boolean | RegionDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["regionClosure"]
  >;

  export type RegionClosureSelectScalar = {
    id?: boolean;
    ancestorId?: boolean;
    descendantId?: boolean;
    depth?: boolean;
  };

  export type RegionClosureOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    "id" | "ancestorId" | "descendantId" | "depth",
    ExtArgs["result"]["regionClosure"]
  >;
  export type RegionClosureInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    ancestor?: boolean | RegionDefaultArgs<ExtArgs>;
    descendant?: boolean | RegionDefaultArgs<ExtArgs>;
  };

  export type $RegionClosurePayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "RegionClosure";
    objects: {
      ancestor: Prisma.$RegionPayload<ExtArgs>;
      descendant: Prisma.$RegionPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        ancestorId: string;
        descendantId: string;
        depth: number;
      },
      ExtArgs["result"]["regionClosure"]
    >;
    composites: {};
  };

  type RegionClosureGetPayload<
    S extends boolean | null | undefined | RegionClosureDefaultArgs,
  > = $Result.GetResult<Prisma.$RegionClosurePayload, S>;

  type RegionClosureCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    RegionClosureFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: RegionClosureCountAggregateInputType | true;
  };

  export interface RegionClosureDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["RegionClosure"];
      meta: { name: "RegionClosure" };
    };
    /**
     * Find zero or one RegionClosure that matches the filter.
     * @param {RegionClosureFindUniqueArgs} args - Arguments to find a RegionClosure
     * @example
     * // Get one RegionClosure
     * const regionClosure = await prisma.regionClosure.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RegionClosureFindUniqueArgs>(
      args: SelectSubset<T, RegionClosureFindUniqueArgs<ExtArgs>>,
    ): Prisma__RegionClosureClient<
      $Result.GetResult<
        Prisma.$RegionClosurePayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one RegionClosure that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RegionClosureFindUniqueOrThrowArgs} args - Arguments to find a RegionClosure
     * @example
     * // Get one RegionClosure
     * const regionClosure = await prisma.regionClosure.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RegionClosureFindUniqueOrThrowArgs>(
      args: SelectSubset<T, RegionClosureFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__RegionClosureClient<
      $Result.GetResult<
        Prisma.$RegionClosurePayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first RegionClosure that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionClosureFindFirstArgs} args - Arguments to find a RegionClosure
     * @example
     * // Get one RegionClosure
     * const regionClosure = await prisma.regionClosure.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RegionClosureFindFirstArgs>(
      args?: SelectSubset<T, RegionClosureFindFirstArgs<ExtArgs>>,
    ): Prisma__RegionClosureClient<
      $Result.GetResult<
        Prisma.$RegionClosurePayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first RegionClosure that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionClosureFindFirstOrThrowArgs} args - Arguments to find a RegionClosure
     * @example
     * // Get one RegionClosure
     * const regionClosure = await prisma.regionClosure.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RegionClosureFindFirstOrThrowArgs>(
      args?: SelectSubset<T, RegionClosureFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__RegionClosureClient<
      $Result.GetResult<
        Prisma.$RegionClosurePayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more RegionClosures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionClosureFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RegionClosures
     * const regionClosures = await prisma.regionClosure.findMany()
     *
     * // Get first 10 RegionClosures
     * const regionClosures = await prisma.regionClosure.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const regionClosureWithIdOnly = await prisma.regionClosure.findMany({ select: { id: true } })
     *
     */
    findMany<T extends RegionClosureFindManyArgs>(
      args?: SelectSubset<T, RegionClosureFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$RegionClosurePayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a RegionClosure.
     * @param {RegionClosureCreateArgs} args - Arguments to create a RegionClosure.
     * @example
     * // Create one RegionClosure
     * const RegionClosure = await prisma.regionClosure.create({
     *   data: {
     *     // ... data to create a RegionClosure
     *   }
     * })
     *
     */
    create<T extends RegionClosureCreateArgs>(
      args: SelectSubset<T, RegionClosureCreateArgs<ExtArgs>>,
    ): Prisma__RegionClosureClient<
      $Result.GetResult<
        Prisma.$RegionClosurePayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many RegionClosures.
     * @param {RegionClosureCreateManyArgs} args - Arguments to create many RegionClosures.
     * @example
     * // Create many RegionClosures
     * const regionClosure = await prisma.regionClosure.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends RegionClosureCreateManyArgs>(
      args?: SelectSubset<T, RegionClosureCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a RegionClosure.
     * @param {RegionClosureDeleteArgs} args - Arguments to delete one RegionClosure.
     * @example
     * // Delete one RegionClosure
     * const RegionClosure = await prisma.regionClosure.delete({
     *   where: {
     *     // ... filter to delete one RegionClosure
     *   }
     * })
     *
     */
    delete<T extends RegionClosureDeleteArgs>(
      args: SelectSubset<T, RegionClosureDeleteArgs<ExtArgs>>,
    ): Prisma__RegionClosureClient<
      $Result.GetResult<
        Prisma.$RegionClosurePayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one RegionClosure.
     * @param {RegionClosureUpdateArgs} args - Arguments to update one RegionClosure.
     * @example
     * // Update one RegionClosure
     * const regionClosure = await prisma.regionClosure.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends RegionClosureUpdateArgs>(
      args: SelectSubset<T, RegionClosureUpdateArgs<ExtArgs>>,
    ): Prisma__RegionClosureClient<
      $Result.GetResult<
        Prisma.$RegionClosurePayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more RegionClosures.
     * @param {RegionClosureDeleteManyArgs} args - Arguments to filter RegionClosures to delete.
     * @example
     * // Delete a few RegionClosures
     * const { count } = await prisma.regionClosure.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends RegionClosureDeleteManyArgs>(
      args?: SelectSubset<T, RegionClosureDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more RegionClosures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionClosureUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RegionClosures
     * const regionClosure = await prisma.regionClosure.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends RegionClosureUpdateManyArgs>(
      args: SelectSubset<T, RegionClosureUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one RegionClosure.
     * @param {RegionClosureUpsertArgs} args - Arguments to update or create a RegionClosure.
     * @example
     * // Update or create a RegionClosure
     * const regionClosure = await prisma.regionClosure.upsert({
     *   create: {
     *     // ... data to create a RegionClosure
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RegionClosure we want to update
     *   }
     * })
     */
    upsert<T extends RegionClosureUpsertArgs>(
      args: SelectSubset<T, RegionClosureUpsertArgs<ExtArgs>>,
    ): Prisma__RegionClosureClient<
      $Result.GetResult<
        Prisma.$RegionClosurePayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more RegionClosures that matches the filter.
     * @param {RegionClosureFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const regionClosure = await prisma.regionClosure.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: RegionClosureFindRawArgs): Prisma.PrismaPromise<JsonObject>;

    /**
     * Perform aggregation operations on a RegionClosure.
     * @param {RegionClosureAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const regionClosure = await prisma.regionClosure.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(
      args?: RegionClosureAggregateRawArgs,
    ): Prisma.PrismaPromise<JsonObject>;

    /**
     * Count the number of RegionClosures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionClosureCountArgs} args - Arguments to filter RegionClosures to count.
     * @example
     * // Count the number of RegionClosures
     * const count = await prisma.regionClosure.count({
     *   where: {
     *     // ... the filter for the RegionClosures we want to count
     *   }
     * })
     **/
    count<T extends RegionClosureCountArgs>(
      args?: Subset<T, RegionClosureCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], RegionClosureCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a RegionClosure.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionClosureAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends RegionClosureAggregateArgs>(
      args: Subset<T, RegionClosureAggregateArgs>,
    ): Prisma.PrismaPromise<GetRegionClosureAggregateType<T>>;

    /**
     * Group by RegionClosure.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionClosureGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends RegionClosureGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RegionClosureGroupByArgs["orderBy"] }
        : { orderBy?: RegionClosureGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, RegionClosureGroupByArgs, OrderByArg> &
        InputErrors,
    ): {} extends InputErrors
      ? GetRegionClosureGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the RegionClosure model
     */
    readonly fields: RegionClosureFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RegionClosure.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RegionClosureClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    ancestor<T extends RegionDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, RegionDefaultArgs<ExtArgs>>,
    ): Prisma__RegionClient<
      | $Result.GetResult<
          Prisma.$RegionPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    descendant<T extends RegionDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, RegionDefaultArgs<ExtArgs>>,
    ): Prisma__RegionClient<
      | $Result.GetResult<
          Prisma.$RegionPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the RegionClosure model
   */
  interface RegionClosureFieldRefs {
    readonly id: FieldRef<"RegionClosure", "String">;
    readonly ancestorId: FieldRef<"RegionClosure", "String">;
    readonly descendantId: FieldRef<"RegionClosure", "String">;
    readonly depth: FieldRef<"RegionClosure", "Int">;
  }

  // Custom InputTypes
  /**
   * RegionClosure findUnique
   */
  export type RegionClosureFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the RegionClosure
     */
    select?: RegionClosureSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the RegionClosure
     */
    omit?: RegionClosureOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionClosureInclude<ExtArgs> | null;
    /**
     * Filter, which RegionClosure to fetch.
     */
    where: RegionClosureWhereUniqueInput;
  };

  /**
   * RegionClosure findUniqueOrThrow
   */
  export type RegionClosureFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the RegionClosure
     */
    select?: RegionClosureSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the RegionClosure
     */
    omit?: RegionClosureOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionClosureInclude<ExtArgs> | null;
    /**
     * Filter, which RegionClosure to fetch.
     */
    where: RegionClosureWhereUniqueInput;
  };

  /**
   * RegionClosure findFirst
   */
  export type RegionClosureFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the RegionClosure
     */
    select?: RegionClosureSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the RegionClosure
     */
    omit?: RegionClosureOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionClosureInclude<ExtArgs> | null;
    /**
     * Filter, which RegionClosure to fetch.
     */
    where?: RegionClosureWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of RegionClosures to fetch.
     */
    orderBy?:
      | RegionClosureOrderByWithRelationInput
      | RegionClosureOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for RegionClosures.
     */
    cursor?: RegionClosureWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` RegionClosures from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` RegionClosures.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of RegionClosures.
     */
    distinct?: RegionClosureScalarFieldEnum | RegionClosureScalarFieldEnum[];
  };

  /**
   * RegionClosure findFirstOrThrow
   */
  export type RegionClosureFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the RegionClosure
     */
    select?: RegionClosureSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the RegionClosure
     */
    omit?: RegionClosureOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionClosureInclude<ExtArgs> | null;
    /**
     * Filter, which RegionClosure to fetch.
     */
    where?: RegionClosureWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of RegionClosures to fetch.
     */
    orderBy?:
      | RegionClosureOrderByWithRelationInput
      | RegionClosureOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for RegionClosures.
     */
    cursor?: RegionClosureWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` RegionClosures from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` RegionClosures.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of RegionClosures.
     */
    distinct?: RegionClosureScalarFieldEnum | RegionClosureScalarFieldEnum[];
  };

  /**
   * RegionClosure findMany
   */
  export type RegionClosureFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the RegionClosure
     */
    select?: RegionClosureSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the RegionClosure
     */
    omit?: RegionClosureOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionClosureInclude<ExtArgs> | null;
    /**
     * Filter, which RegionClosures to fetch.
     */
    where?: RegionClosureWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of RegionClosures to fetch.
     */
    orderBy?:
      | RegionClosureOrderByWithRelationInput
      | RegionClosureOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing RegionClosures.
     */
    cursor?: RegionClosureWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` RegionClosures from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` RegionClosures.
     */
    skip?: number;
    distinct?: RegionClosureScalarFieldEnum | RegionClosureScalarFieldEnum[];
  };

  /**
   * RegionClosure create
   */
  export type RegionClosureCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the RegionClosure
     */
    select?: RegionClosureSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the RegionClosure
     */
    omit?: RegionClosureOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionClosureInclude<ExtArgs> | null;
    /**
     * The data needed to create a RegionClosure.
     */
    data: XOR<RegionClosureCreateInput, RegionClosureUncheckedCreateInput>;
  };

  /**
   * RegionClosure createMany
   */
  export type RegionClosureCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many RegionClosures.
     */
    data: RegionClosureCreateManyInput | RegionClosureCreateManyInput[];
  };

  /**
   * RegionClosure update
   */
  export type RegionClosureUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the RegionClosure
     */
    select?: RegionClosureSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the RegionClosure
     */
    omit?: RegionClosureOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionClosureInclude<ExtArgs> | null;
    /**
     * The data needed to update a RegionClosure.
     */
    data: XOR<RegionClosureUpdateInput, RegionClosureUncheckedUpdateInput>;
    /**
     * Choose, which RegionClosure to update.
     */
    where: RegionClosureWhereUniqueInput;
  };

  /**
   * RegionClosure updateMany
   */
  export type RegionClosureUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update RegionClosures.
     */
    data: XOR<
      RegionClosureUpdateManyMutationInput,
      RegionClosureUncheckedUpdateManyInput
    >;
    /**
     * Filter which RegionClosures to update
     */
    where?: RegionClosureWhereInput;
    /**
     * Limit how many RegionClosures to update.
     */
    limit?: number;
  };

  /**
   * RegionClosure upsert
   */
  export type RegionClosureUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the RegionClosure
     */
    select?: RegionClosureSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the RegionClosure
     */
    omit?: RegionClosureOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionClosureInclude<ExtArgs> | null;
    /**
     * The filter to search for the RegionClosure to update in case it exists.
     */
    where: RegionClosureWhereUniqueInput;
    /**
     * In case the RegionClosure found by the `where` argument doesn't exist, create a new RegionClosure with this data.
     */
    create: XOR<RegionClosureCreateInput, RegionClosureUncheckedCreateInput>;
    /**
     * In case the RegionClosure was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RegionClosureUpdateInput, RegionClosureUncheckedUpdateInput>;
  };

  /**
   * RegionClosure delete
   */
  export type RegionClosureDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the RegionClosure
     */
    select?: RegionClosureSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the RegionClosure
     */
    omit?: RegionClosureOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionClosureInclude<ExtArgs> | null;
    /**
     * Filter which RegionClosure to delete.
     */
    where: RegionClosureWhereUniqueInput;
  };

  /**
   * RegionClosure deleteMany
   */
  export type RegionClosureDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which RegionClosures to delete
     */
    where?: RegionClosureWhereInput;
    /**
     * Limit how many RegionClosures to delete.
     */
    limit?: number;
  };

  /**
   * RegionClosure findRaw
   */
  export type RegionClosureFindRawArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue;
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue;
  };

  /**
   * RegionClosure aggregateRaw
   */
  export type RegionClosureAggregateRawArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[];
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue;
  };

  /**
   * RegionClosure without action
   */
  export type RegionClosureDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the RegionClosure
     */
    select?: RegionClosureSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the RegionClosure
     */
    omit?: RegionClosureOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionClosureInclude<ExtArgs> | null;
  };

  /**
   * Model ContentItem
   */

  export type AggregateContentItem = {
    _count: ContentItemCountAggregateOutputType | null;
    _avg: ContentItemAvgAggregateOutputType | null;
    _sum: ContentItemSumAggregateOutputType | null;
    _min: ContentItemMinAggregateOutputType | null;
    _max: ContentItemMaxAggregateOutputType | null;
  };

  export type ContentItemAvgAggregateOutputType = {
    sortOrder: number | null;
  };

  export type ContentItemSumAggregateOutputType = {
    sortOrder: number | null;
  };

  export type ContentItemMinAggregateOutputType = {
    id: string | null;
    kind: $Enums.ContentKind | null;
    topicId: string | null;
    locale: $Enums.Locale | null;
    title: string | null;
    text: string | null;
    richText: string | null;
    sortOrder: number | null;
    status: $Enums.PublishStatus | null;
    authorName: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    publishAt: Date | null;
    expireAt: Date | null;
    regionMode: $Enums.RegionMode | null;
    regionManualId: string | null;
    regionEffectiveId: string | null;
  };

  export type ContentItemMaxAggregateOutputType = {
    id: string | null;
    kind: $Enums.ContentKind | null;
    topicId: string | null;
    locale: $Enums.Locale | null;
    title: string | null;
    text: string | null;
    richText: string | null;
    sortOrder: number | null;
    status: $Enums.PublishStatus | null;
    authorName: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    publishAt: Date | null;
    expireAt: Date | null;
    regionMode: $Enums.RegionMode | null;
    regionManualId: string | null;
    regionEffectiveId: string | null;
  };

  export type ContentItemCountAggregateOutputType = {
    id: number;
    kind: number;
    topicId: number;
    locale: number;
    title: number;
    text: number;
    richText: number;
    sortOrder: number;
    status: number;
    authorName: number;
    createdAt: number;
    updatedAt: number;
    publishAt: number;
    expireAt: number;
    regionMode: number;
    regionManualId: number;
    regionAuto: number;
    regionEffectiveId: number;
    validation: number;
    meta: number;
    _all: number;
  };

  export type ContentItemAvgAggregateInputType = {
    sortOrder?: true;
  };

  export type ContentItemSumAggregateInputType = {
    sortOrder?: true;
  };

  export type ContentItemMinAggregateInputType = {
    id?: true;
    kind?: true;
    topicId?: true;
    locale?: true;
    title?: true;
    text?: true;
    richText?: true;
    sortOrder?: true;
    status?: true;
    authorName?: true;
    createdAt?: true;
    updatedAt?: true;
    publishAt?: true;
    expireAt?: true;
    regionMode?: true;
    regionManualId?: true;
    regionEffectiveId?: true;
  };

  export type ContentItemMaxAggregateInputType = {
    id?: true;
    kind?: true;
    topicId?: true;
    locale?: true;
    title?: true;
    text?: true;
    richText?: true;
    sortOrder?: true;
    status?: true;
    authorName?: true;
    createdAt?: true;
    updatedAt?: true;
    publishAt?: true;
    expireAt?: true;
    regionMode?: true;
    regionManualId?: true;
    regionEffectiveId?: true;
  };

  export type ContentItemCountAggregateInputType = {
    id?: true;
    kind?: true;
    topicId?: true;
    locale?: true;
    title?: true;
    text?: true;
    richText?: true;
    sortOrder?: true;
    status?: true;
    authorName?: true;
    createdAt?: true;
    updatedAt?: true;
    publishAt?: true;
    expireAt?: true;
    regionMode?: true;
    regionManualId?: true;
    regionAuto?: true;
    regionEffectiveId?: true;
    validation?: true;
    meta?: true;
    _all?: true;
  };

  export type ContentItemAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which ContentItem to aggregate.
     */
    where?: ContentItemWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ContentItems to fetch.
     */
    orderBy?:
      | ContentItemOrderByWithRelationInput
      | ContentItemOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: ContentItemWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ContentItems from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ContentItems.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned ContentItems
     **/
    _count?: true | ContentItemCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: ContentItemAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: ContentItemSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: ContentItemMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: ContentItemMaxAggregateInputType;
  };

  export type GetContentItemAggregateType<T extends ContentItemAggregateArgs> =
    {
      [P in keyof T & keyof AggregateContentItem]: P extends "_count" | "count"
        ? T[P] extends true
          ? number
          : GetScalarType<T[P], AggregateContentItem[P]>
        : GetScalarType<T[P], AggregateContentItem[P]>;
    };

  export type ContentItemGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ContentItemWhereInput;
    orderBy?:
      | ContentItemOrderByWithAggregationInput
      | ContentItemOrderByWithAggregationInput[];
    by: ContentItemScalarFieldEnum[] | ContentItemScalarFieldEnum;
    having?: ContentItemScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: ContentItemCountAggregateInputType | true;
    _avg?: ContentItemAvgAggregateInputType;
    _sum?: ContentItemSumAggregateInputType;
    _min?: ContentItemMinAggregateInputType;
    _max?: ContentItemMaxAggregateInputType;
  };

  export type ContentItemGroupByOutputType = {
    id: string;
    kind: $Enums.ContentKind;
    topicId: string;
    locale: $Enums.Locale;
    title: string | null;
    text: string;
    richText: string | null;
    sortOrder: number;
    status: $Enums.PublishStatus;
    authorName: string | null;
    createdAt: Date;
    updatedAt: Date;
    publishAt: Date | null;
    expireAt: Date | null;
    regionMode: $Enums.RegionMode;
    regionManualId: string | null;
    regionAuto: JsonValue | null;
    regionEffectiveId: string | null;
    validation: JsonValue | null;
    meta: JsonValue | null;
    _count: ContentItemCountAggregateOutputType | null;
    _avg: ContentItemAvgAggregateOutputType | null;
    _sum: ContentItemSumAggregateOutputType | null;
    _min: ContentItemMinAggregateOutputType | null;
    _max: ContentItemMaxAggregateOutputType | null;
  };

  type GetContentItemGroupByPayload<T extends ContentItemGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<ContentItemGroupByOutputType, T["by"]> & {
          [P in keyof T &
            keyof ContentItemGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContentItemGroupByOutputType[P]>
            : GetScalarType<T[P], ContentItemGroupByOutputType[P]>;
        }
      >
    >;

  export type ContentItemSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      kind?: boolean;
      topicId?: boolean;
      locale?: boolean;
      title?: boolean;
      text?: boolean;
      richText?: boolean;
      sortOrder?: boolean;
      status?: boolean;
      authorName?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      publishAt?: boolean;
      expireAt?: boolean;
      regionMode?: boolean;
      regionManualId?: boolean;
      regionAuto?: boolean;
      regionEffectiveId?: boolean;
      validation?: boolean;
      meta?: boolean;
      topic?: boolean | TopicDefaultArgs<ExtArgs>;
      units?: boolean | ContentItem$unitsArgs<ExtArgs>;
      regionManual?: boolean | ContentItem$regionManualArgs<ExtArgs>;
      regionEffective?: boolean | ContentItem$regionEffectiveArgs<ExtArgs>;
      answerOptions?: boolean | ContentItem$answerOptionsArgs<ExtArgs>;
      tags?: boolean | ContentItem$tagsArgs<ExtArgs>;
      _count?: boolean | ContentItemCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["contentItem"]
  >;

  export type ContentItemSelectScalar = {
    id?: boolean;
    kind?: boolean;
    topicId?: boolean;
    locale?: boolean;
    title?: boolean;
    text?: boolean;
    richText?: boolean;
    sortOrder?: boolean;
    status?: boolean;
    authorName?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    publishAt?: boolean;
    expireAt?: boolean;
    regionMode?: boolean;
    regionManualId?: boolean;
    regionAuto?: boolean;
    regionEffectiveId?: boolean;
    validation?: boolean;
    meta?: boolean;
  };

  export type ContentItemOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | "id"
    | "kind"
    | "topicId"
    | "locale"
    | "title"
    | "text"
    | "richText"
    | "sortOrder"
    | "status"
    | "authorName"
    | "createdAt"
    | "updatedAt"
    | "publishAt"
    | "expireAt"
    | "regionMode"
    | "regionManualId"
    | "regionAuto"
    | "regionEffectiveId"
    | "validation"
    | "meta",
    ExtArgs["result"]["contentItem"]
  >;
  export type ContentItemInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    topic?: boolean | TopicDefaultArgs<ExtArgs>;
    units?: boolean | ContentItem$unitsArgs<ExtArgs>;
    regionManual?: boolean | ContentItem$regionManualArgs<ExtArgs>;
    regionEffective?: boolean | ContentItem$regionEffectiveArgs<ExtArgs>;
    answerOptions?: boolean | ContentItem$answerOptionsArgs<ExtArgs>;
    tags?: boolean | ContentItem$tagsArgs<ExtArgs>;
    _count?: boolean | ContentItemCountOutputTypeDefaultArgs<ExtArgs>;
  };

  export type $ContentItemPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "ContentItem";
    objects: {
      topic: Prisma.$TopicPayload<ExtArgs>;
      units: Prisma.$ExtractedUnitPayload<ExtArgs>[];
      regionManual: Prisma.$RegionPayload<ExtArgs> | null;
      regionEffective: Prisma.$RegionPayload<ExtArgs> | null;
      answerOptions: Prisma.$AnswerOptionPayload<ExtArgs>[];
      tags: Prisma.$ItemTagPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        kind: $Enums.ContentKind;
        topicId: string;
        locale: $Enums.Locale;
        title: string | null;
        text: string;
        richText: string | null;
        sortOrder: number;
        status: $Enums.PublishStatus;
        authorName: string | null;
        createdAt: Date;
        updatedAt: Date;
        publishAt: Date | null;
        expireAt: Date | null;
        regionMode: $Enums.RegionMode;
        regionManualId: string | null;
        regionAuto: Prisma.JsonValue | null;
        regionEffectiveId: string | null;
        validation: Prisma.JsonValue | null;
        meta: Prisma.JsonValue | null;
      },
      ExtArgs["result"]["contentItem"]
    >;
    composites: {};
  };

  type ContentItemGetPayload<
    S extends boolean | null | undefined | ContentItemDefaultArgs,
  > = $Result.GetResult<Prisma.$ContentItemPayload, S>;

  type ContentItemCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    ContentItemFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: ContentItemCountAggregateInputType | true;
  };

  export interface ContentItemDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["ContentItem"];
      meta: { name: "ContentItem" };
    };
    /**
     * Find zero or one ContentItem that matches the filter.
     * @param {ContentItemFindUniqueArgs} args - Arguments to find a ContentItem
     * @example
     * // Get one ContentItem
     * const contentItem = await prisma.contentItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContentItemFindUniqueArgs>(
      args: SelectSubset<T, ContentItemFindUniqueArgs<ExtArgs>>,
    ): Prisma__ContentItemClient<
      $Result.GetResult<
        Prisma.$ContentItemPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one ContentItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContentItemFindUniqueOrThrowArgs} args - Arguments to find a ContentItem
     * @example
     * // Get one ContentItem
     * const contentItem = await prisma.contentItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContentItemFindUniqueOrThrowArgs>(
      args: SelectSubset<T, ContentItemFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__ContentItemClient<
      $Result.GetResult<
        Prisma.$ContentItemPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first ContentItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentItemFindFirstArgs} args - Arguments to find a ContentItem
     * @example
     * // Get one ContentItem
     * const contentItem = await prisma.contentItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContentItemFindFirstArgs>(
      args?: SelectSubset<T, ContentItemFindFirstArgs<ExtArgs>>,
    ): Prisma__ContentItemClient<
      $Result.GetResult<
        Prisma.$ContentItemPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first ContentItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentItemFindFirstOrThrowArgs} args - Arguments to find a ContentItem
     * @example
     * // Get one ContentItem
     * const contentItem = await prisma.contentItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContentItemFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ContentItemFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__ContentItemClient<
      $Result.GetResult<
        Prisma.$ContentItemPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more ContentItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContentItems
     * const contentItems = await prisma.contentItem.findMany()
     *
     * // Get first 10 ContentItems
     * const contentItems = await prisma.contentItem.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const contentItemWithIdOnly = await prisma.contentItem.findMany({ select: { id: true } })
     *
     */
    findMany<T extends ContentItemFindManyArgs>(
      args?: SelectSubset<T, ContentItemFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ContentItemPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a ContentItem.
     * @param {ContentItemCreateArgs} args - Arguments to create a ContentItem.
     * @example
     * // Create one ContentItem
     * const ContentItem = await prisma.contentItem.create({
     *   data: {
     *     // ... data to create a ContentItem
     *   }
     * })
     *
     */
    create<T extends ContentItemCreateArgs>(
      args: SelectSubset<T, ContentItemCreateArgs<ExtArgs>>,
    ): Prisma__ContentItemClient<
      $Result.GetResult<
        Prisma.$ContentItemPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many ContentItems.
     * @param {ContentItemCreateManyArgs} args - Arguments to create many ContentItems.
     * @example
     * // Create many ContentItems
     * const contentItem = await prisma.contentItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends ContentItemCreateManyArgs>(
      args?: SelectSubset<T, ContentItemCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a ContentItem.
     * @param {ContentItemDeleteArgs} args - Arguments to delete one ContentItem.
     * @example
     * // Delete one ContentItem
     * const ContentItem = await prisma.contentItem.delete({
     *   where: {
     *     // ... filter to delete one ContentItem
     *   }
     * })
     *
     */
    delete<T extends ContentItemDeleteArgs>(
      args: SelectSubset<T, ContentItemDeleteArgs<ExtArgs>>,
    ): Prisma__ContentItemClient<
      $Result.GetResult<
        Prisma.$ContentItemPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one ContentItem.
     * @param {ContentItemUpdateArgs} args - Arguments to update one ContentItem.
     * @example
     * // Update one ContentItem
     * const contentItem = await prisma.contentItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends ContentItemUpdateArgs>(
      args: SelectSubset<T, ContentItemUpdateArgs<ExtArgs>>,
    ): Prisma__ContentItemClient<
      $Result.GetResult<
        Prisma.$ContentItemPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more ContentItems.
     * @param {ContentItemDeleteManyArgs} args - Arguments to filter ContentItems to delete.
     * @example
     * // Delete a few ContentItems
     * const { count } = await prisma.contentItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends ContentItemDeleteManyArgs>(
      args?: SelectSubset<T, ContentItemDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more ContentItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContentItems
     * const contentItem = await prisma.contentItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends ContentItemUpdateManyArgs>(
      args: SelectSubset<T, ContentItemUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one ContentItem.
     * @param {ContentItemUpsertArgs} args - Arguments to update or create a ContentItem.
     * @example
     * // Update or create a ContentItem
     * const contentItem = await prisma.contentItem.upsert({
     *   create: {
     *     // ... data to create a ContentItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContentItem we want to update
     *   }
     * })
     */
    upsert<T extends ContentItemUpsertArgs>(
      args: SelectSubset<T, ContentItemUpsertArgs<ExtArgs>>,
    ): Prisma__ContentItemClient<
      $Result.GetResult<
        Prisma.$ContentItemPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more ContentItems that matches the filter.
     * @param {ContentItemFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const contentItem = await prisma.contentItem.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: ContentItemFindRawArgs): Prisma.PrismaPromise<JsonObject>;

    /**
     * Perform aggregation operations on a ContentItem.
     * @param {ContentItemAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const contentItem = await prisma.contentItem.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(
      args?: ContentItemAggregateRawArgs,
    ): Prisma.PrismaPromise<JsonObject>;

    /**
     * Count the number of ContentItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentItemCountArgs} args - Arguments to filter ContentItems to count.
     * @example
     * // Count the number of ContentItems
     * const count = await prisma.contentItem.count({
     *   where: {
     *     // ... the filter for the ContentItems we want to count
     *   }
     * })
     **/
    count<T extends ContentItemCountArgs>(
      args?: Subset<T, ContentItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], ContentItemCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a ContentItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends ContentItemAggregateArgs>(
      args: Subset<T, ContentItemAggregateArgs>,
    ): Prisma.PrismaPromise<GetContentItemAggregateType<T>>;

    /**
     * Group by ContentItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends ContentItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContentItemGroupByArgs["orderBy"] }
        : { orderBy?: ContentItemGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, ContentItemGroupByArgs, OrderByArg> &
        InputErrors,
    ): {} extends InputErrors
      ? GetContentItemGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the ContentItem model
     */
    readonly fields: ContentItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContentItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContentItemClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    topic<T extends TopicDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, TopicDefaultArgs<ExtArgs>>,
    ): Prisma__TopicClient<
      | $Result.GetResult<
          Prisma.$TopicPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    units<T extends ContentItem$unitsArgs<ExtArgs> = {}>(
      args?: Subset<T, ContentItem$unitsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$ExtractedUnitPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    regionManual<T extends ContentItem$regionManualArgs<ExtArgs> = {}>(
      args?: Subset<T, ContentItem$regionManualArgs<ExtArgs>>,
    ): Prisma__RegionClient<
      $Result.GetResult<
        Prisma.$RegionPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    regionEffective<T extends ContentItem$regionEffectiveArgs<ExtArgs> = {}>(
      args?: Subset<T, ContentItem$regionEffectiveArgs<ExtArgs>>,
    ): Prisma__RegionClient<
      $Result.GetResult<
        Prisma.$RegionPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    answerOptions<T extends ContentItem$answerOptionsArgs<ExtArgs> = {}>(
      args?: Subset<T, ContentItem$answerOptionsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$AnswerOptionPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    tags<T extends ContentItem$tagsArgs<ExtArgs> = {}>(
      args?: Subset<T, ContentItem$tagsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$ItemTagPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the ContentItem model
   */
  interface ContentItemFieldRefs {
    readonly id: FieldRef<"ContentItem", "String">;
    readonly kind: FieldRef<"ContentItem", "ContentKind">;
    readonly topicId: FieldRef<"ContentItem", "String">;
    readonly locale: FieldRef<"ContentItem", "Locale">;
    readonly title: FieldRef<"ContentItem", "String">;
    readonly text: FieldRef<"ContentItem", "String">;
    readonly richText: FieldRef<"ContentItem", "String">;
    readonly sortOrder: FieldRef<"ContentItem", "Int">;
    readonly status: FieldRef<"ContentItem", "PublishStatus">;
    readonly authorName: FieldRef<"ContentItem", "String">;
    readonly createdAt: FieldRef<"ContentItem", "DateTime">;
    readonly updatedAt: FieldRef<"ContentItem", "DateTime">;
    readonly publishAt: FieldRef<"ContentItem", "DateTime">;
    readonly expireAt: FieldRef<"ContentItem", "DateTime">;
    readonly regionMode: FieldRef<"ContentItem", "RegionMode">;
    readonly regionManualId: FieldRef<"ContentItem", "String">;
    readonly regionAuto: FieldRef<"ContentItem", "Json">;
    readonly regionEffectiveId: FieldRef<"ContentItem", "String">;
    readonly validation: FieldRef<"ContentItem", "Json">;
    readonly meta: FieldRef<"ContentItem", "Json">;
  }

  // Custom InputTypes
  /**
   * ContentItem findUnique
   */
  export type ContentItemFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ContentItem
     */
    select?: ContentItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ContentItem
     */
    omit?: ContentItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentItemInclude<ExtArgs> | null;
    /**
     * Filter, which ContentItem to fetch.
     */
    where: ContentItemWhereUniqueInput;
  };

  /**
   * ContentItem findUniqueOrThrow
   */
  export type ContentItemFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ContentItem
     */
    select?: ContentItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ContentItem
     */
    omit?: ContentItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentItemInclude<ExtArgs> | null;
    /**
     * Filter, which ContentItem to fetch.
     */
    where: ContentItemWhereUniqueInput;
  };

  /**
   * ContentItem findFirst
   */
  export type ContentItemFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ContentItem
     */
    select?: ContentItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ContentItem
     */
    omit?: ContentItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentItemInclude<ExtArgs> | null;
    /**
     * Filter, which ContentItem to fetch.
     */
    where?: ContentItemWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ContentItems to fetch.
     */
    orderBy?:
      | ContentItemOrderByWithRelationInput
      | ContentItemOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ContentItems.
     */
    cursor?: ContentItemWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ContentItems from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ContentItems.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ContentItems.
     */
    distinct?: ContentItemScalarFieldEnum | ContentItemScalarFieldEnum[];
  };

  /**
   * ContentItem findFirstOrThrow
   */
  export type ContentItemFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ContentItem
     */
    select?: ContentItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ContentItem
     */
    omit?: ContentItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentItemInclude<ExtArgs> | null;
    /**
     * Filter, which ContentItem to fetch.
     */
    where?: ContentItemWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ContentItems to fetch.
     */
    orderBy?:
      | ContentItemOrderByWithRelationInput
      | ContentItemOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ContentItems.
     */
    cursor?: ContentItemWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ContentItems from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ContentItems.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ContentItems.
     */
    distinct?: ContentItemScalarFieldEnum | ContentItemScalarFieldEnum[];
  };

  /**
   * ContentItem findMany
   */
  export type ContentItemFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ContentItem
     */
    select?: ContentItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ContentItem
     */
    omit?: ContentItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentItemInclude<ExtArgs> | null;
    /**
     * Filter, which ContentItems to fetch.
     */
    where?: ContentItemWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ContentItems to fetch.
     */
    orderBy?:
      | ContentItemOrderByWithRelationInput
      | ContentItemOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing ContentItems.
     */
    cursor?: ContentItemWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ContentItems from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ContentItems.
     */
    skip?: number;
    distinct?: ContentItemScalarFieldEnum | ContentItemScalarFieldEnum[];
  };

  /**
   * ContentItem create
   */
  export type ContentItemCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ContentItem
     */
    select?: ContentItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ContentItem
     */
    omit?: ContentItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentItemInclude<ExtArgs> | null;
    /**
     * The data needed to create a ContentItem.
     */
    data: XOR<ContentItemCreateInput, ContentItemUncheckedCreateInput>;
  };

  /**
   * ContentItem createMany
   */
  export type ContentItemCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many ContentItems.
     */
    data: ContentItemCreateManyInput | ContentItemCreateManyInput[];
  };

  /**
   * ContentItem update
   */
  export type ContentItemUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ContentItem
     */
    select?: ContentItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ContentItem
     */
    omit?: ContentItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentItemInclude<ExtArgs> | null;
    /**
     * The data needed to update a ContentItem.
     */
    data: XOR<ContentItemUpdateInput, ContentItemUncheckedUpdateInput>;
    /**
     * Choose, which ContentItem to update.
     */
    where: ContentItemWhereUniqueInput;
  };

  /**
   * ContentItem updateMany
   */
  export type ContentItemUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update ContentItems.
     */
    data: XOR<
      ContentItemUpdateManyMutationInput,
      ContentItemUncheckedUpdateManyInput
    >;
    /**
     * Filter which ContentItems to update
     */
    where?: ContentItemWhereInput;
    /**
     * Limit how many ContentItems to update.
     */
    limit?: number;
  };

  /**
   * ContentItem upsert
   */
  export type ContentItemUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ContentItem
     */
    select?: ContentItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ContentItem
     */
    omit?: ContentItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentItemInclude<ExtArgs> | null;
    /**
     * The filter to search for the ContentItem to update in case it exists.
     */
    where: ContentItemWhereUniqueInput;
    /**
     * In case the ContentItem found by the `where` argument doesn't exist, create a new ContentItem with this data.
     */
    create: XOR<ContentItemCreateInput, ContentItemUncheckedCreateInput>;
    /**
     * In case the ContentItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContentItemUpdateInput, ContentItemUncheckedUpdateInput>;
  };

  /**
   * ContentItem delete
   */
  export type ContentItemDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ContentItem
     */
    select?: ContentItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ContentItem
     */
    omit?: ContentItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentItemInclude<ExtArgs> | null;
    /**
     * Filter which ContentItem to delete.
     */
    where: ContentItemWhereUniqueInput;
  };

  /**
   * ContentItem deleteMany
   */
  export type ContentItemDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which ContentItems to delete
     */
    where?: ContentItemWhereInput;
    /**
     * Limit how many ContentItems to delete.
     */
    limit?: number;
  };

  /**
   * ContentItem findRaw
   */
  export type ContentItemFindRawArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue;
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue;
  };

  /**
   * ContentItem aggregateRaw
   */
  export type ContentItemAggregateRawArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[];
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue;
  };

  /**
   * ContentItem.units
   */
  export type ContentItem$unitsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ExtractedUnit
     */
    select?: ExtractedUnitSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ExtractedUnit
     */
    omit?: ExtractedUnitOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExtractedUnitInclude<ExtArgs> | null;
    where?: ExtractedUnitWhereInput;
    orderBy?:
      | ExtractedUnitOrderByWithRelationInput
      | ExtractedUnitOrderByWithRelationInput[];
    cursor?: ExtractedUnitWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ExtractedUnitScalarFieldEnum | ExtractedUnitScalarFieldEnum[];
  };

  /**
   * ContentItem.regionManual
   */
  export type ContentItem$regionManualArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Region
     */
    omit?: RegionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null;
    where?: RegionWhereInput;
  };

  /**
   * ContentItem.regionEffective
   */
  export type ContentItem$regionEffectiveArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Region
     */
    omit?: RegionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null;
    where?: RegionWhereInput;
  };

  /**
   * ContentItem.answerOptions
   */
  export type ContentItem$answerOptionsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AnswerOption
     */
    select?: AnswerOptionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AnswerOption
     */
    omit?: AnswerOptionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswerOptionInclude<ExtArgs> | null;
    where?: AnswerOptionWhereInput;
    orderBy?:
      | AnswerOptionOrderByWithRelationInput
      | AnswerOptionOrderByWithRelationInput[];
    cursor?: AnswerOptionWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: AnswerOptionScalarFieldEnum | AnswerOptionScalarFieldEnum[];
  };

  /**
   * ContentItem.tags
   */
  export type ContentItem$tagsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ItemTag
     */
    select?: ItemTagSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ItemTag
     */
    omit?: ItemTagOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemTagInclude<ExtArgs> | null;
    where?: ItemTagWhereInput;
    orderBy?:
      | ItemTagOrderByWithRelationInput
      | ItemTagOrderByWithRelationInput[];
    cursor?: ItemTagWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ItemTagScalarFieldEnum | ItemTagScalarFieldEnum[];
  };

  /**
   * ContentItem without action
   */
  export type ContentItemDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ContentItem
     */
    select?: ContentItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ContentItem
     */
    omit?: ContentItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentItemInclude<ExtArgs> | null;
  };

  /**
   * Model AnswerOption
   */

  export type AggregateAnswerOption = {
    _count: AnswerOptionCountAggregateOutputType | null;
    _avg: AnswerOptionAvgAggregateOutputType | null;
    _sum: AnswerOptionSumAggregateOutputType | null;
    _min: AnswerOptionMinAggregateOutputType | null;
    _max: AnswerOptionMaxAggregateOutputType | null;
  };

  export type AnswerOptionAvgAggregateOutputType = {
    sortOrder: number | null;
  };

  export type AnswerOptionSumAggregateOutputType = {
    sortOrder: number | null;
  };

  export type AnswerOptionMinAggregateOutputType = {
    id: string | null;
    itemId: string | null;
    label: string | null;
    value: string | null;
    sortOrder: number | null;
    exclusive: boolean | null;
  };

  export type AnswerOptionMaxAggregateOutputType = {
    id: string | null;
    itemId: string | null;
    label: string | null;
    value: string | null;
    sortOrder: number | null;
    exclusive: boolean | null;
  };

  export type AnswerOptionCountAggregateOutputType = {
    id: number;
    itemId: number;
    label: number;
    value: number;
    sortOrder: number;
    exclusive: number;
    meta: number;
    _all: number;
  };

  export type AnswerOptionAvgAggregateInputType = {
    sortOrder?: true;
  };

  export type AnswerOptionSumAggregateInputType = {
    sortOrder?: true;
  };

  export type AnswerOptionMinAggregateInputType = {
    id?: true;
    itemId?: true;
    label?: true;
    value?: true;
    sortOrder?: true;
    exclusive?: true;
  };

  export type AnswerOptionMaxAggregateInputType = {
    id?: true;
    itemId?: true;
    label?: true;
    value?: true;
    sortOrder?: true;
    exclusive?: true;
  };

  export type AnswerOptionCountAggregateInputType = {
    id?: true;
    itemId?: true;
    label?: true;
    value?: true;
    sortOrder?: true;
    exclusive?: true;
    meta?: true;
    _all?: true;
  };

  export type AnswerOptionAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which AnswerOption to aggregate.
     */
    where?: AnswerOptionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AnswerOptions to fetch.
     */
    orderBy?:
      | AnswerOptionOrderByWithRelationInput
      | AnswerOptionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: AnswerOptionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AnswerOptions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AnswerOptions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned AnswerOptions
     **/
    _count?: true | AnswerOptionCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: AnswerOptionAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: AnswerOptionSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: AnswerOptionMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: AnswerOptionMaxAggregateInputType;
  };

  export type GetAnswerOptionAggregateType<
    T extends AnswerOptionAggregateArgs,
  > = {
    [P in keyof T & keyof AggregateAnswerOption]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnswerOption[P]>
      : GetScalarType<T[P], AggregateAnswerOption[P]>;
  };

  export type AnswerOptionGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: AnswerOptionWhereInput;
    orderBy?:
      | AnswerOptionOrderByWithAggregationInput
      | AnswerOptionOrderByWithAggregationInput[];
    by: AnswerOptionScalarFieldEnum[] | AnswerOptionScalarFieldEnum;
    having?: AnswerOptionScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: AnswerOptionCountAggregateInputType | true;
    _avg?: AnswerOptionAvgAggregateInputType;
    _sum?: AnswerOptionSumAggregateInputType;
    _min?: AnswerOptionMinAggregateInputType;
    _max?: AnswerOptionMaxAggregateInputType;
  };

  export type AnswerOptionGroupByOutputType = {
    id: string;
    itemId: string;
    label: string;
    value: string;
    sortOrder: number;
    exclusive: boolean;
    meta: JsonValue | null;
    _count: AnswerOptionCountAggregateOutputType | null;
    _avg: AnswerOptionAvgAggregateOutputType | null;
    _sum: AnswerOptionSumAggregateOutputType | null;
    _min: AnswerOptionMinAggregateOutputType | null;
    _max: AnswerOptionMaxAggregateOutputType | null;
  };

  type GetAnswerOptionGroupByPayload<T extends AnswerOptionGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<AnswerOptionGroupByOutputType, T["by"]> & {
          [P in keyof T &
            keyof AnswerOptionGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnswerOptionGroupByOutputType[P]>
            : GetScalarType<T[P], AnswerOptionGroupByOutputType[P]>;
        }
      >
    >;

  export type AnswerOptionSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      itemId?: boolean;
      label?: boolean;
      value?: boolean;
      sortOrder?: boolean;
      exclusive?: boolean;
      meta?: boolean;
      item?: boolean | ContentItemDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["answerOption"]
  >;

  export type AnswerOptionSelectScalar = {
    id?: boolean;
    itemId?: boolean;
    label?: boolean;
    value?: boolean;
    sortOrder?: boolean;
    exclusive?: boolean;
    meta?: boolean;
  };

  export type AnswerOptionOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    "id" | "itemId" | "label" | "value" | "sortOrder" | "exclusive" | "meta",
    ExtArgs["result"]["answerOption"]
  >;
  export type AnswerOptionInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    item?: boolean | ContentItemDefaultArgs<ExtArgs>;
  };

  export type $AnswerOptionPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "AnswerOption";
    objects: {
      item: Prisma.$ContentItemPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        itemId: string;
        label: string;
        value: string;
        sortOrder: number;
        exclusive: boolean;
        meta: Prisma.JsonValue | null;
      },
      ExtArgs["result"]["answerOption"]
    >;
    composites: {};
  };

  type AnswerOptionGetPayload<
    S extends boolean | null | undefined | AnswerOptionDefaultArgs,
  > = $Result.GetResult<Prisma.$AnswerOptionPayload, S>;

  type AnswerOptionCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    AnswerOptionFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: AnswerOptionCountAggregateInputType | true;
  };

  export interface AnswerOptionDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["AnswerOption"];
      meta: { name: "AnswerOption" };
    };
    /**
     * Find zero or one AnswerOption that matches the filter.
     * @param {AnswerOptionFindUniqueArgs} args - Arguments to find a AnswerOption
     * @example
     * // Get one AnswerOption
     * const answerOption = await prisma.answerOption.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AnswerOptionFindUniqueArgs>(
      args: SelectSubset<T, AnswerOptionFindUniqueArgs<ExtArgs>>,
    ): Prisma__AnswerOptionClient<
      $Result.GetResult<
        Prisma.$AnswerOptionPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one AnswerOption that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AnswerOptionFindUniqueOrThrowArgs} args - Arguments to find a AnswerOption
     * @example
     * // Get one AnswerOption
     * const answerOption = await prisma.answerOption.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AnswerOptionFindUniqueOrThrowArgs>(
      args: SelectSubset<T, AnswerOptionFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__AnswerOptionClient<
      $Result.GetResult<
        Prisma.$AnswerOptionPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first AnswerOption that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnswerOptionFindFirstArgs} args - Arguments to find a AnswerOption
     * @example
     * // Get one AnswerOption
     * const answerOption = await prisma.answerOption.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AnswerOptionFindFirstArgs>(
      args?: SelectSubset<T, AnswerOptionFindFirstArgs<ExtArgs>>,
    ): Prisma__AnswerOptionClient<
      $Result.GetResult<
        Prisma.$AnswerOptionPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first AnswerOption that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnswerOptionFindFirstOrThrowArgs} args - Arguments to find a AnswerOption
     * @example
     * // Get one AnswerOption
     * const answerOption = await prisma.answerOption.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AnswerOptionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, AnswerOptionFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__AnswerOptionClient<
      $Result.GetResult<
        Prisma.$AnswerOptionPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more AnswerOptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnswerOptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AnswerOptions
     * const answerOptions = await prisma.answerOption.findMany()
     *
     * // Get first 10 AnswerOptions
     * const answerOptions = await prisma.answerOption.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const answerOptionWithIdOnly = await prisma.answerOption.findMany({ select: { id: true } })
     *
     */
    findMany<T extends AnswerOptionFindManyArgs>(
      args?: SelectSubset<T, AnswerOptionFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$AnswerOptionPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a AnswerOption.
     * @param {AnswerOptionCreateArgs} args - Arguments to create a AnswerOption.
     * @example
     * // Create one AnswerOption
     * const AnswerOption = await prisma.answerOption.create({
     *   data: {
     *     // ... data to create a AnswerOption
     *   }
     * })
     *
     */
    create<T extends AnswerOptionCreateArgs>(
      args: SelectSubset<T, AnswerOptionCreateArgs<ExtArgs>>,
    ): Prisma__AnswerOptionClient<
      $Result.GetResult<
        Prisma.$AnswerOptionPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many AnswerOptions.
     * @param {AnswerOptionCreateManyArgs} args - Arguments to create many AnswerOptions.
     * @example
     * // Create many AnswerOptions
     * const answerOption = await prisma.answerOption.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends AnswerOptionCreateManyArgs>(
      args?: SelectSubset<T, AnswerOptionCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a AnswerOption.
     * @param {AnswerOptionDeleteArgs} args - Arguments to delete one AnswerOption.
     * @example
     * // Delete one AnswerOption
     * const AnswerOption = await prisma.answerOption.delete({
     *   where: {
     *     // ... filter to delete one AnswerOption
     *   }
     * })
     *
     */
    delete<T extends AnswerOptionDeleteArgs>(
      args: SelectSubset<T, AnswerOptionDeleteArgs<ExtArgs>>,
    ): Prisma__AnswerOptionClient<
      $Result.GetResult<
        Prisma.$AnswerOptionPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one AnswerOption.
     * @param {AnswerOptionUpdateArgs} args - Arguments to update one AnswerOption.
     * @example
     * // Update one AnswerOption
     * const answerOption = await prisma.answerOption.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends AnswerOptionUpdateArgs>(
      args: SelectSubset<T, AnswerOptionUpdateArgs<ExtArgs>>,
    ): Prisma__AnswerOptionClient<
      $Result.GetResult<
        Prisma.$AnswerOptionPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more AnswerOptions.
     * @param {AnswerOptionDeleteManyArgs} args - Arguments to filter AnswerOptions to delete.
     * @example
     * // Delete a few AnswerOptions
     * const { count } = await prisma.answerOption.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends AnswerOptionDeleteManyArgs>(
      args?: SelectSubset<T, AnswerOptionDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more AnswerOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnswerOptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AnswerOptions
     * const answerOption = await prisma.answerOption.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends AnswerOptionUpdateManyArgs>(
      args: SelectSubset<T, AnswerOptionUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one AnswerOption.
     * @param {AnswerOptionUpsertArgs} args - Arguments to update or create a AnswerOption.
     * @example
     * // Update or create a AnswerOption
     * const answerOption = await prisma.answerOption.upsert({
     *   create: {
     *     // ... data to create a AnswerOption
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AnswerOption we want to update
     *   }
     * })
     */
    upsert<T extends AnswerOptionUpsertArgs>(
      args: SelectSubset<T, AnswerOptionUpsertArgs<ExtArgs>>,
    ): Prisma__AnswerOptionClient<
      $Result.GetResult<
        Prisma.$AnswerOptionPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more AnswerOptions that matches the filter.
     * @param {AnswerOptionFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const answerOption = await prisma.answerOption.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: AnswerOptionFindRawArgs): Prisma.PrismaPromise<JsonObject>;

    /**
     * Perform aggregation operations on a AnswerOption.
     * @param {AnswerOptionAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const answerOption = await prisma.answerOption.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(
      args?: AnswerOptionAggregateRawArgs,
    ): Prisma.PrismaPromise<JsonObject>;

    /**
     * Count the number of AnswerOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnswerOptionCountArgs} args - Arguments to filter AnswerOptions to count.
     * @example
     * // Count the number of AnswerOptions
     * const count = await prisma.answerOption.count({
     *   where: {
     *     // ... the filter for the AnswerOptions we want to count
     *   }
     * })
     **/
    count<T extends AnswerOptionCountArgs>(
      args?: Subset<T, AnswerOptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], AnswerOptionCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a AnswerOption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnswerOptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends AnswerOptionAggregateArgs>(
      args: Subset<T, AnswerOptionAggregateArgs>,
    ): Prisma.PrismaPromise<GetAnswerOptionAggregateType<T>>;

    /**
     * Group by AnswerOption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnswerOptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends AnswerOptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AnswerOptionGroupByArgs["orderBy"] }
        : { orderBy?: AnswerOptionGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, AnswerOptionGroupByArgs, OrderByArg> &
        InputErrors,
    ): {} extends InputErrors
      ? GetAnswerOptionGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the AnswerOption model
     */
    readonly fields: AnswerOptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AnswerOption.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AnswerOptionClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    item<T extends ContentItemDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, ContentItemDefaultArgs<ExtArgs>>,
    ): Prisma__ContentItemClient<
      | $Result.GetResult<
          Prisma.$ContentItemPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the AnswerOption model
   */
  interface AnswerOptionFieldRefs {
    readonly id: FieldRef<"AnswerOption", "String">;
    readonly itemId: FieldRef<"AnswerOption", "String">;
    readonly label: FieldRef<"AnswerOption", "String">;
    readonly value: FieldRef<"AnswerOption", "String">;
    readonly sortOrder: FieldRef<"AnswerOption", "Int">;
    readonly exclusive: FieldRef<"AnswerOption", "Boolean">;
    readonly meta: FieldRef<"AnswerOption", "Json">;
  }

  // Custom InputTypes
  /**
   * AnswerOption findUnique
   */
  export type AnswerOptionFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AnswerOption
     */
    select?: AnswerOptionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AnswerOption
     */
    omit?: AnswerOptionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswerOptionInclude<ExtArgs> | null;
    /**
     * Filter, which AnswerOption to fetch.
     */
    where: AnswerOptionWhereUniqueInput;
  };

  /**
   * AnswerOption findUniqueOrThrow
   */
  export type AnswerOptionFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AnswerOption
     */
    select?: AnswerOptionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AnswerOption
     */
    omit?: AnswerOptionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswerOptionInclude<ExtArgs> | null;
    /**
     * Filter, which AnswerOption to fetch.
     */
    where: AnswerOptionWhereUniqueInput;
  };

  /**
   * AnswerOption findFirst
   */
  export type AnswerOptionFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AnswerOption
     */
    select?: AnswerOptionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AnswerOption
     */
    omit?: AnswerOptionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswerOptionInclude<ExtArgs> | null;
    /**
     * Filter, which AnswerOption to fetch.
     */
    where?: AnswerOptionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AnswerOptions to fetch.
     */
    orderBy?:
      | AnswerOptionOrderByWithRelationInput
      | AnswerOptionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for AnswerOptions.
     */
    cursor?: AnswerOptionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AnswerOptions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AnswerOptions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of AnswerOptions.
     */
    distinct?: AnswerOptionScalarFieldEnum | AnswerOptionScalarFieldEnum[];
  };

  /**
   * AnswerOption findFirstOrThrow
   */
  export type AnswerOptionFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AnswerOption
     */
    select?: AnswerOptionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AnswerOption
     */
    omit?: AnswerOptionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswerOptionInclude<ExtArgs> | null;
    /**
     * Filter, which AnswerOption to fetch.
     */
    where?: AnswerOptionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AnswerOptions to fetch.
     */
    orderBy?:
      | AnswerOptionOrderByWithRelationInput
      | AnswerOptionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for AnswerOptions.
     */
    cursor?: AnswerOptionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AnswerOptions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AnswerOptions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of AnswerOptions.
     */
    distinct?: AnswerOptionScalarFieldEnum | AnswerOptionScalarFieldEnum[];
  };

  /**
   * AnswerOption findMany
   */
  export type AnswerOptionFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AnswerOption
     */
    select?: AnswerOptionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AnswerOption
     */
    omit?: AnswerOptionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswerOptionInclude<ExtArgs> | null;
    /**
     * Filter, which AnswerOptions to fetch.
     */
    where?: AnswerOptionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AnswerOptions to fetch.
     */
    orderBy?:
      | AnswerOptionOrderByWithRelationInput
      | AnswerOptionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing AnswerOptions.
     */
    cursor?: AnswerOptionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AnswerOptions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AnswerOptions.
     */
    skip?: number;
    distinct?: AnswerOptionScalarFieldEnum | AnswerOptionScalarFieldEnum[];
  };

  /**
   * AnswerOption create
   */
  export type AnswerOptionCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AnswerOption
     */
    select?: AnswerOptionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AnswerOption
     */
    omit?: AnswerOptionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswerOptionInclude<ExtArgs> | null;
    /**
     * The data needed to create a AnswerOption.
     */
    data: XOR<AnswerOptionCreateInput, AnswerOptionUncheckedCreateInput>;
  };

  /**
   * AnswerOption createMany
   */
  export type AnswerOptionCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many AnswerOptions.
     */
    data: AnswerOptionCreateManyInput | AnswerOptionCreateManyInput[];
  };

  /**
   * AnswerOption update
   */
  export type AnswerOptionUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AnswerOption
     */
    select?: AnswerOptionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AnswerOption
     */
    omit?: AnswerOptionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswerOptionInclude<ExtArgs> | null;
    /**
     * The data needed to update a AnswerOption.
     */
    data: XOR<AnswerOptionUpdateInput, AnswerOptionUncheckedUpdateInput>;
    /**
     * Choose, which AnswerOption to update.
     */
    where: AnswerOptionWhereUniqueInput;
  };

  /**
   * AnswerOption updateMany
   */
  export type AnswerOptionUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update AnswerOptions.
     */
    data: XOR<
      AnswerOptionUpdateManyMutationInput,
      AnswerOptionUncheckedUpdateManyInput
    >;
    /**
     * Filter which AnswerOptions to update
     */
    where?: AnswerOptionWhereInput;
    /**
     * Limit how many AnswerOptions to update.
     */
    limit?: number;
  };

  /**
   * AnswerOption upsert
   */
  export type AnswerOptionUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AnswerOption
     */
    select?: AnswerOptionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AnswerOption
     */
    omit?: AnswerOptionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswerOptionInclude<ExtArgs> | null;
    /**
     * The filter to search for the AnswerOption to update in case it exists.
     */
    where: AnswerOptionWhereUniqueInput;
    /**
     * In case the AnswerOption found by the `where` argument doesn't exist, create a new AnswerOption with this data.
     */
    create: XOR<AnswerOptionCreateInput, AnswerOptionUncheckedCreateInput>;
    /**
     * In case the AnswerOption was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AnswerOptionUpdateInput, AnswerOptionUncheckedUpdateInput>;
  };

  /**
   * AnswerOption delete
   */
  export type AnswerOptionDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AnswerOption
     */
    select?: AnswerOptionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AnswerOption
     */
    omit?: AnswerOptionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswerOptionInclude<ExtArgs> | null;
    /**
     * Filter which AnswerOption to delete.
     */
    where: AnswerOptionWhereUniqueInput;
  };

  /**
   * AnswerOption deleteMany
   */
  export type AnswerOptionDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which AnswerOptions to delete
     */
    where?: AnswerOptionWhereInput;
    /**
     * Limit how many AnswerOptions to delete.
     */
    limit?: number;
  };

  /**
   * AnswerOption findRaw
   */
  export type AnswerOptionFindRawArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue;
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue;
  };

  /**
   * AnswerOption aggregateRaw
   */
  export type AnswerOptionAggregateRawArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[];
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue;
  };

  /**
   * AnswerOption without action
   */
  export type AnswerOptionDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AnswerOption
     */
    select?: AnswerOptionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AnswerOption
     */
    omit?: AnswerOptionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswerOptionInclude<ExtArgs> | null;
  };

  /**
   * Model FactcheckJob
   */

  export type AggregateFactcheckJob = {
    _count: FactcheckJobCountAggregateOutputType | null;
    _avg: FactcheckJobAvgAggregateOutputType | null;
    _sum: FactcheckJobSumAggregateOutputType | null;
    _min: FactcheckJobMinAggregateOutputType | null;
    _max: FactcheckJobMaxAggregateOutputType | null;
  };

  export type FactcheckJobAvgAggregateOutputType = {
    tokensUsed: number | null;
    durationMs: number | null;
  };

  export type FactcheckJobSumAggregateOutputType = {
    tokensUsed: number | null;
    durationMs: number | null;
  };

  export type FactcheckJobMinAggregateOutputType = {
    id: string | null;
    jobId: string | null;
    contributionId: string | null;
    status: string | null;
    tokensUsed: number | null;
    durationMs: number | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type FactcheckJobMaxAggregateOutputType = {
    id: string | null;
    jobId: string | null;
    contributionId: string | null;
    status: string | null;
    tokensUsed: number | null;
    durationMs: number | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type FactcheckJobCountAggregateOutputType = {
    id: number;
    jobId: number;
    contributionId: number;
    status: number;
    tokensUsed: number;
    durationMs: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type FactcheckJobAvgAggregateInputType = {
    tokensUsed?: true;
    durationMs?: true;
  };

  export type FactcheckJobSumAggregateInputType = {
    tokensUsed?: true;
    durationMs?: true;
  };

  export type FactcheckJobMinAggregateInputType = {
    id?: true;
    jobId?: true;
    contributionId?: true;
    status?: true;
    tokensUsed?: true;
    durationMs?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type FactcheckJobMaxAggregateInputType = {
    id?: true;
    jobId?: true;
    contributionId?: true;
    status?: true;
    tokensUsed?: true;
    durationMs?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type FactcheckJobCountAggregateInputType = {
    id?: true;
    jobId?: true;
    contributionId?: true;
    status?: true;
    tokensUsed?: true;
    durationMs?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type FactcheckJobAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which FactcheckJob to aggregate.
     */
    where?: FactcheckJobWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of FactcheckJobs to fetch.
     */
    orderBy?:
      | FactcheckJobOrderByWithRelationInput
      | FactcheckJobOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: FactcheckJobWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` FactcheckJobs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` FactcheckJobs.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned FactcheckJobs
     **/
    _count?: true | FactcheckJobCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: FactcheckJobAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: FactcheckJobSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: FactcheckJobMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: FactcheckJobMaxAggregateInputType;
  };

  export type GetFactcheckJobAggregateType<
    T extends FactcheckJobAggregateArgs,
  > = {
    [P in keyof T & keyof AggregateFactcheckJob]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFactcheckJob[P]>
      : GetScalarType<T[P], AggregateFactcheckJob[P]>;
  };

  export type FactcheckJobGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: FactcheckJobWhereInput;
    orderBy?:
      | FactcheckJobOrderByWithAggregationInput
      | FactcheckJobOrderByWithAggregationInput[];
    by: FactcheckJobScalarFieldEnum[] | FactcheckJobScalarFieldEnum;
    having?: FactcheckJobScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: FactcheckJobCountAggregateInputType | true;
    _avg?: FactcheckJobAvgAggregateInputType;
    _sum?: FactcheckJobSumAggregateInputType;
    _min?: FactcheckJobMinAggregateInputType;
    _max?: FactcheckJobMaxAggregateInputType;
  };

  export type FactcheckJobGroupByOutputType = {
    id: string;
    jobId: string;
    contributionId: string;
    status: string;
    tokensUsed: number;
    durationMs: number;
    createdAt: Date;
    updatedAt: Date;
    _count: FactcheckJobCountAggregateOutputType | null;
    _avg: FactcheckJobAvgAggregateOutputType | null;
    _sum: FactcheckJobSumAggregateOutputType | null;
    _min: FactcheckJobMinAggregateOutputType | null;
    _max: FactcheckJobMaxAggregateOutputType | null;
  };

  type GetFactcheckJobGroupByPayload<T extends FactcheckJobGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<FactcheckJobGroupByOutputType, T["by"]> & {
          [P in keyof T &
            keyof FactcheckJobGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FactcheckJobGroupByOutputType[P]>
            : GetScalarType<T[P], FactcheckJobGroupByOutputType[P]>;
        }
      >
    >;

  export type FactcheckJobSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      jobId?: boolean;
      contributionId?: boolean;
      status?: boolean;
      tokensUsed?: boolean;
      durationMs?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      claims?: boolean | FactcheckJob$claimsArgs<ExtArgs>;
      results?: boolean | FactcheckJob$resultsArgs<ExtArgs>;
      _count?: boolean | FactcheckJobCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["factcheckJob"]
  >;

  export type FactcheckJobSelectScalar = {
    id?: boolean;
    jobId?: boolean;
    contributionId?: boolean;
    status?: boolean;
    tokensUsed?: boolean;
    durationMs?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type FactcheckJobOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | "id"
    | "jobId"
    | "contributionId"
    | "status"
    | "tokensUsed"
    | "durationMs"
    | "createdAt"
    | "updatedAt",
    ExtArgs["result"]["factcheckJob"]
  >;
  export type FactcheckJobInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    claims?: boolean | FactcheckJob$claimsArgs<ExtArgs>;
    results?: boolean | FactcheckJob$resultsArgs<ExtArgs>;
    _count?: boolean | FactcheckJobCountOutputTypeDefaultArgs<ExtArgs>;
  };

  export type $FactcheckJobPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "FactcheckJob";
    objects: {
      claims: Prisma.$FactcheckClaimPayload<ExtArgs>[];
      results: Prisma.$FactcheckResultPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        jobId: string;
        contributionId: string;
        status: string;
        tokensUsed: number;
        durationMs: number;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs["result"]["factcheckJob"]
    >;
    composites: {};
  };

  type FactcheckJobGetPayload<
    S extends boolean | null | undefined | FactcheckJobDefaultArgs,
  > = $Result.GetResult<Prisma.$FactcheckJobPayload, S>;

  type FactcheckJobCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    FactcheckJobFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: FactcheckJobCountAggregateInputType | true;
  };

  export interface FactcheckJobDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["FactcheckJob"];
      meta: { name: "FactcheckJob" };
    };
    /**
     * Find zero or one FactcheckJob that matches the filter.
     * @param {FactcheckJobFindUniqueArgs} args - Arguments to find a FactcheckJob
     * @example
     * // Get one FactcheckJob
     * const factcheckJob = await prisma.factcheckJob.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FactcheckJobFindUniqueArgs>(
      args: SelectSubset<T, FactcheckJobFindUniqueArgs<ExtArgs>>,
    ): Prisma__FactcheckJobClient<
      $Result.GetResult<
        Prisma.$FactcheckJobPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one FactcheckJob that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FactcheckJobFindUniqueOrThrowArgs} args - Arguments to find a FactcheckJob
     * @example
     * // Get one FactcheckJob
     * const factcheckJob = await prisma.factcheckJob.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FactcheckJobFindUniqueOrThrowArgs>(
      args: SelectSubset<T, FactcheckJobFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__FactcheckJobClient<
      $Result.GetResult<
        Prisma.$FactcheckJobPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first FactcheckJob that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactcheckJobFindFirstArgs} args - Arguments to find a FactcheckJob
     * @example
     * // Get one FactcheckJob
     * const factcheckJob = await prisma.factcheckJob.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FactcheckJobFindFirstArgs>(
      args?: SelectSubset<T, FactcheckJobFindFirstArgs<ExtArgs>>,
    ): Prisma__FactcheckJobClient<
      $Result.GetResult<
        Prisma.$FactcheckJobPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first FactcheckJob that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactcheckJobFindFirstOrThrowArgs} args - Arguments to find a FactcheckJob
     * @example
     * // Get one FactcheckJob
     * const factcheckJob = await prisma.factcheckJob.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FactcheckJobFindFirstOrThrowArgs>(
      args?: SelectSubset<T, FactcheckJobFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__FactcheckJobClient<
      $Result.GetResult<
        Prisma.$FactcheckJobPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more FactcheckJobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactcheckJobFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FactcheckJobs
     * const factcheckJobs = await prisma.factcheckJob.findMany()
     *
     * // Get first 10 FactcheckJobs
     * const factcheckJobs = await prisma.factcheckJob.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const factcheckJobWithIdOnly = await prisma.factcheckJob.findMany({ select: { id: true } })
     *
     */
    findMany<T extends FactcheckJobFindManyArgs>(
      args?: SelectSubset<T, FactcheckJobFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$FactcheckJobPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a FactcheckJob.
     * @param {FactcheckJobCreateArgs} args - Arguments to create a FactcheckJob.
     * @example
     * // Create one FactcheckJob
     * const FactcheckJob = await prisma.factcheckJob.create({
     *   data: {
     *     // ... data to create a FactcheckJob
     *   }
     * })
     *
     */
    create<T extends FactcheckJobCreateArgs>(
      args: SelectSubset<T, FactcheckJobCreateArgs<ExtArgs>>,
    ): Prisma__FactcheckJobClient<
      $Result.GetResult<
        Prisma.$FactcheckJobPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many FactcheckJobs.
     * @param {FactcheckJobCreateManyArgs} args - Arguments to create many FactcheckJobs.
     * @example
     * // Create many FactcheckJobs
     * const factcheckJob = await prisma.factcheckJob.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends FactcheckJobCreateManyArgs>(
      args?: SelectSubset<T, FactcheckJobCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a FactcheckJob.
     * @param {FactcheckJobDeleteArgs} args - Arguments to delete one FactcheckJob.
     * @example
     * // Delete one FactcheckJob
     * const FactcheckJob = await prisma.factcheckJob.delete({
     *   where: {
     *     // ... filter to delete one FactcheckJob
     *   }
     * })
     *
     */
    delete<T extends FactcheckJobDeleteArgs>(
      args: SelectSubset<T, FactcheckJobDeleteArgs<ExtArgs>>,
    ): Prisma__FactcheckJobClient<
      $Result.GetResult<
        Prisma.$FactcheckJobPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one FactcheckJob.
     * @param {FactcheckJobUpdateArgs} args - Arguments to update one FactcheckJob.
     * @example
     * // Update one FactcheckJob
     * const factcheckJob = await prisma.factcheckJob.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends FactcheckJobUpdateArgs>(
      args: SelectSubset<T, FactcheckJobUpdateArgs<ExtArgs>>,
    ): Prisma__FactcheckJobClient<
      $Result.GetResult<
        Prisma.$FactcheckJobPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more FactcheckJobs.
     * @param {FactcheckJobDeleteManyArgs} args - Arguments to filter FactcheckJobs to delete.
     * @example
     * // Delete a few FactcheckJobs
     * const { count } = await prisma.factcheckJob.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends FactcheckJobDeleteManyArgs>(
      args?: SelectSubset<T, FactcheckJobDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more FactcheckJobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactcheckJobUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FactcheckJobs
     * const factcheckJob = await prisma.factcheckJob.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends FactcheckJobUpdateManyArgs>(
      args: SelectSubset<T, FactcheckJobUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one FactcheckJob.
     * @param {FactcheckJobUpsertArgs} args - Arguments to update or create a FactcheckJob.
     * @example
     * // Update or create a FactcheckJob
     * const factcheckJob = await prisma.factcheckJob.upsert({
     *   create: {
     *     // ... data to create a FactcheckJob
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FactcheckJob we want to update
     *   }
     * })
     */
    upsert<T extends FactcheckJobUpsertArgs>(
      args: SelectSubset<T, FactcheckJobUpsertArgs<ExtArgs>>,
    ): Prisma__FactcheckJobClient<
      $Result.GetResult<
        Prisma.$FactcheckJobPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more FactcheckJobs that matches the filter.
     * @param {FactcheckJobFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const factcheckJob = await prisma.factcheckJob.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: FactcheckJobFindRawArgs): Prisma.PrismaPromise<JsonObject>;

    /**
     * Perform aggregation operations on a FactcheckJob.
     * @param {FactcheckJobAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const factcheckJob = await prisma.factcheckJob.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(
      args?: FactcheckJobAggregateRawArgs,
    ): Prisma.PrismaPromise<JsonObject>;

    /**
     * Count the number of FactcheckJobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactcheckJobCountArgs} args - Arguments to filter FactcheckJobs to count.
     * @example
     * // Count the number of FactcheckJobs
     * const count = await prisma.factcheckJob.count({
     *   where: {
     *     // ... the filter for the FactcheckJobs we want to count
     *   }
     * })
     **/
    count<T extends FactcheckJobCountArgs>(
      args?: Subset<T, FactcheckJobCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], FactcheckJobCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a FactcheckJob.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactcheckJobAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends FactcheckJobAggregateArgs>(
      args: Subset<T, FactcheckJobAggregateArgs>,
    ): Prisma.PrismaPromise<GetFactcheckJobAggregateType<T>>;

    /**
     * Group by FactcheckJob.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactcheckJobGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends FactcheckJobGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FactcheckJobGroupByArgs["orderBy"] }
        : { orderBy?: FactcheckJobGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, FactcheckJobGroupByArgs, OrderByArg> &
        InputErrors,
    ): {} extends InputErrors
      ? GetFactcheckJobGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the FactcheckJob model
     */
    readonly fields: FactcheckJobFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FactcheckJob.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FactcheckJobClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    claims<T extends FactcheckJob$claimsArgs<ExtArgs> = {}>(
      args?: Subset<T, FactcheckJob$claimsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$FactcheckClaimPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    results<T extends FactcheckJob$resultsArgs<ExtArgs> = {}>(
      args?: Subset<T, FactcheckJob$resultsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$FactcheckResultPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the FactcheckJob model
   */
  interface FactcheckJobFieldRefs {
    readonly id: FieldRef<"FactcheckJob", "String">;
    readonly jobId: FieldRef<"FactcheckJob", "String">;
    readonly contributionId: FieldRef<"FactcheckJob", "String">;
    readonly status: FieldRef<"FactcheckJob", "String">;
    readonly tokensUsed: FieldRef<"FactcheckJob", "Int">;
    readonly durationMs: FieldRef<"FactcheckJob", "Int">;
    readonly createdAt: FieldRef<"FactcheckJob", "DateTime">;
    readonly updatedAt: FieldRef<"FactcheckJob", "DateTime">;
  }

  // Custom InputTypes
  /**
   * FactcheckJob findUnique
   */
  export type FactcheckJobFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactcheckJob
     */
    select?: FactcheckJobSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FactcheckJob
     */
    omit?: FactcheckJobOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactcheckJobInclude<ExtArgs> | null;
    /**
     * Filter, which FactcheckJob to fetch.
     */
    where: FactcheckJobWhereUniqueInput;
  };

  /**
   * FactcheckJob findUniqueOrThrow
   */
  export type FactcheckJobFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactcheckJob
     */
    select?: FactcheckJobSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FactcheckJob
     */
    omit?: FactcheckJobOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactcheckJobInclude<ExtArgs> | null;
    /**
     * Filter, which FactcheckJob to fetch.
     */
    where: FactcheckJobWhereUniqueInput;
  };

  /**
   * FactcheckJob findFirst
   */
  export type FactcheckJobFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactcheckJob
     */
    select?: FactcheckJobSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FactcheckJob
     */
    omit?: FactcheckJobOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactcheckJobInclude<ExtArgs> | null;
    /**
     * Filter, which FactcheckJob to fetch.
     */
    where?: FactcheckJobWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of FactcheckJobs to fetch.
     */
    orderBy?:
      | FactcheckJobOrderByWithRelationInput
      | FactcheckJobOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for FactcheckJobs.
     */
    cursor?: FactcheckJobWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` FactcheckJobs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` FactcheckJobs.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of FactcheckJobs.
     */
    distinct?: FactcheckJobScalarFieldEnum | FactcheckJobScalarFieldEnum[];
  };

  /**
   * FactcheckJob findFirstOrThrow
   */
  export type FactcheckJobFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactcheckJob
     */
    select?: FactcheckJobSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FactcheckJob
     */
    omit?: FactcheckJobOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactcheckJobInclude<ExtArgs> | null;
    /**
     * Filter, which FactcheckJob to fetch.
     */
    where?: FactcheckJobWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of FactcheckJobs to fetch.
     */
    orderBy?:
      | FactcheckJobOrderByWithRelationInput
      | FactcheckJobOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for FactcheckJobs.
     */
    cursor?: FactcheckJobWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` FactcheckJobs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` FactcheckJobs.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of FactcheckJobs.
     */
    distinct?: FactcheckJobScalarFieldEnum | FactcheckJobScalarFieldEnum[];
  };

  /**
   * FactcheckJob findMany
   */
  export type FactcheckJobFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactcheckJob
     */
    select?: FactcheckJobSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FactcheckJob
     */
    omit?: FactcheckJobOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactcheckJobInclude<ExtArgs> | null;
    /**
     * Filter, which FactcheckJobs to fetch.
     */
    where?: FactcheckJobWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of FactcheckJobs to fetch.
     */
    orderBy?:
      | FactcheckJobOrderByWithRelationInput
      | FactcheckJobOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing FactcheckJobs.
     */
    cursor?: FactcheckJobWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` FactcheckJobs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` FactcheckJobs.
     */
    skip?: number;
    distinct?: FactcheckJobScalarFieldEnum | FactcheckJobScalarFieldEnum[];
  };

  /**
   * FactcheckJob create
   */
  export type FactcheckJobCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactcheckJob
     */
    select?: FactcheckJobSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FactcheckJob
     */
    omit?: FactcheckJobOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactcheckJobInclude<ExtArgs> | null;
    /**
     * The data needed to create a FactcheckJob.
     */
    data: XOR<FactcheckJobCreateInput, FactcheckJobUncheckedCreateInput>;
  };

  /**
   * FactcheckJob createMany
   */
  export type FactcheckJobCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many FactcheckJobs.
     */
    data: FactcheckJobCreateManyInput | FactcheckJobCreateManyInput[];
  };

  /**
   * FactcheckJob update
   */
  export type FactcheckJobUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactcheckJob
     */
    select?: FactcheckJobSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FactcheckJob
     */
    omit?: FactcheckJobOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactcheckJobInclude<ExtArgs> | null;
    /**
     * The data needed to update a FactcheckJob.
     */
    data: XOR<FactcheckJobUpdateInput, FactcheckJobUncheckedUpdateInput>;
    /**
     * Choose, which FactcheckJob to update.
     */
    where: FactcheckJobWhereUniqueInput;
  };

  /**
   * FactcheckJob updateMany
   */
  export type FactcheckJobUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update FactcheckJobs.
     */
    data: XOR<
      FactcheckJobUpdateManyMutationInput,
      FactcheckJobUncheckedUpdateManyInput
    >;
    /**
     * Filter which FactcheckJobs to update
     */
    where?: FactcheckJobWhereInput;
    /**
     * Limit how many FactcheckJobs to update.
     */
    limit?: number;
  };

  /**
   * FactcheckJob upsert
   */
  export type FactcheckJobUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactcheckJob
     */
    select?: FactcheckJobSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FactcheckJob
     */
    omit?: FactcheckJobOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactcheckJobInclude<ExtArgs> | null;
    /**
     * The filter to search for the FactcheckJob to update in case it exists.
     */
    where: FactcheckJobWhereUniqueInput;
    /**
     * In case the FactcheckJob found by the `where` argument doesn't exist, create a new FactcheckJob with this data.
     */
    create: XOR<FactcheckJobCreateInput, FactcheckJobUncheckedCreateInput>;
    /**
     * In case the FactcheckJob was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FactcheckJobUpdateInput, FactcheckJobUncheckedUpdateInput>;
  };

  /**
   * FactcheckJob delete
   */
  export type FactcheckJobDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactcheckJob
     */
    select?: FactcheckJobSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FactcheckJob
     */
    omit?: FactcheckJobOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactcheckJobInclude<ExtArgs> | null;
    /**
     * Filter which FactcheckJob to delete.
     */
    where: FactcheckJobWhereUniqueInput;
  };

  /**
   * FactcheckJob deleteMany
   */
  export type FactcheckJobDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which FactcheckJobs to delete
     */
    where?: FactcheckJobWhereInput;
    /**
     * Limit how many FactcheckJobs to delete.
     */
    limit?: number;
  };

  /**
   * FactcheckJob findRaw
   */
  export type FactcheckJobFindRawArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue;
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue;
  };

  /**
   * FactcheckJob aggregateRaw
   */
  export type FactcheckJobAggregateRawArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[];
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue;
  };

  /**
   * FactcheckJob.claims
   */
  export type FactcheckJob$claimsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactcheckClaim
     */
    select?: FactcheckClaimSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FactcheckClaim
     */
    omit?: FactcheckClaimOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactcheckClaimInclude<ExtArgs> | null;
    where?: FactcheckClaimWhereInput;
    orderBy?:
      | FactcheckClaimOrderByWithRelationInput
      | FactcheckClaimOrderByWithRelationInput[];
    cursor?: FactcheckClaimWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: FactcheckClaimScalarFieldEnum | FactcheckClaimScalarFieldEnum[];
  };

  /**
   * FactcheckJob.results
   */
  export type FactcheckJob$resultsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactcheckResult
     */
    select?: FactcheckResultSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FactcheckResult
     */
    omit?: FactcheckResultOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactcheckResultInclude<ExtArgs> | null;
    where?: FactcheckResultWhereInput;
    orderBy?:
      | FactcheckResultOrderByWithRelationInput
      | FactcheckResultOrderByWithRelationInput[];
    cursor?: FactcheckResultWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?:
      | FactcheckResultScalarFieldEnum
      | FactcheckResultScalarFieldEnum[];
  };

  /**
   * FactcheckJob without action
   */
  export type FactcheckJobDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactcheckJob
     */
    select?: FactcheckJobSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FactcheckJob
     */
    omit?: FactcheckJobOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactcheckJobInclude<ExtArgs> | null;
  };

  /**
   * Model FactcheckClaim
   */

  export type AggregateFactcheckClaim = {
    _count: FactcheckClaimCountAggregateOutputType | null;
    _min: FactcheckClaimMinAggregateOutputType | null;
    _max: FactcheckClaimMaxAggregateOutputType | null;
  };

  export type FactcheckClaimMinAggregateOutputType = {
    id: string | null;
    jobId: string | null;
    text: string | null;
    language: string | null;
    topic: string | null;
    falsifiable: boolean | null;
    canonicalKey: string | null;
    scope: string | null;
    timeframe: string | null;
    status: $Enums.ReviewStatus | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type FactcheckClaimMaxAggregateOutputType = {
    id: string | null;
    jobId: string | null;
    text: string | null;
    language: string | null;
    topic: string | null;
    falsifiable: boolean | null;
    canonicalKey: string | null;
    scope: string | null;
    timeframe: string | null;
    status: $Enums.ReviewStatus | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type FactcheckClaimCountAggregateOutputType = {
    id: number;
    jobId: number;
    text: number;
    language: number;
    topic: number;
    falsifiable: number;
    frames: number;
    rhetoricalFlags: number;
    canonicalKey: number;
    scope: number;
    timeframe: number;
    status: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type FactcheckClaimMinAggregateInputType = {
    id?: true;
    jobId?: true;
    text?: true;
    language?: true;
    topic?: true;
    falsifiable?: true;
    canonicalKey?: true;
    scope?: true;
    timeframe?: true;
    status?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type FactcheckClaimMaxAggregateInputType = {
    id?: true;
    jobId?: true;
    text?: true;
    language?: true;
    topic?: true;
    falsifiable?: true;
    canonicalKey?: true;
    scope?: true;
    timeframe?: true;
    status?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type FactcheckClaimCountAggregateInputType = {
    id?: true;
    jobId?: true;
    text?: true;
    language?: true;
    topic?: true;
    falsifiable?: true;
    frames?: true;
    rhetoricalFlags?: true;
    canonicalKey?: true;
    scope?: true;
    timeframe?: true;
    status?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type FactcheckClaimAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which FactcheckClaim to aggregate.
     */
    where?: FactcheckClaimWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of FactcheckClaims to fetch.
     */
    orderBy?:
      | FactcheckClaimOrderByWithRelationInput
      | FactcheckClaimOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: FactcheckClaimWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` FactcheckClaims from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` FactcheckClaims.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned FactcheckClaims
     **/
    _count?: true | FactcheckClaimCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: FactcheckClaimMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: FactcheckClaimMaxAggregateInputType;
  };

  export type GetFactcheckClaimAggregateType<
    T extends FactcheckClaimAggregateArgs,
  > = {
    [P in keyof T & keyof AggregateFactcheckClaim]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFactcheckClaim[P]>
      : GetScalarType<T[P], AggregateFactcheckClaim[P]>;
  };

  export type FactcheckClaimGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: FactcheckClaimWhereInput;
    orderBy?:
      | FactcheckClaimOrderByWithAggregationInput
      | FactcheckClaimOrderByWithAggregationInput[];
    by: FactcheckClaimScalarFieldEnum[] | FactcheckClaimScalarFieldEnum;
    having?: FactcheckClaimScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: FactcheckClaimCountAggregateInputType | true;
    _min?: FactcheckClaimMinAggregateInputType;
    _max?: FactcheckClaimMaxAggregateInputType;
  };

  export type FactcheckClaimGroupByOutputType = {
    id: string;
    jobId: string;
    text: string;
    language: string | null;
    topic: string | null;
    falsifiable: boolean;
    frames: string[];
    rhetoricalFlags: string[];
    canonicalKey: string;
    scope: string | null;
    timeframe: string | null;
    status: $Enums.ReviewStatus;
    createdAt: Date;
    updatedAt: Date;
    _count: FactcheckClaimCountAggregateOutputType | null;
    _min: FactcheckClaimMinAggregateOutputType | null;
    _max: FactcheckClaimMaxAggregateOutputType | null;
  };

  type GetFactcheckClaimGroupByPayload<T extends FactcheckClaimGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<FactcheckClaimGroupByOutputType, T["by"]> & {
          [P in keyof T &
            keyof FactcheckClaimGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FactcheckClaimGroupByOutputType[P]>
            : GetScalarType<T[P], FactcheckClaimGroupByOutputType[P]>;
        }
      >
    >;

  export type FactcheckClaimSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      jobId?: boolean;
      text?: boolean;
      language?: boolean;
      topic?: boolean;
      falsifiable?: boolean;
      frames?: boolean;
      rhetoricalFlags?: boolean;
      canonicalKey?: boolean;
      scope?: boolean;
      timeframe?: boolean;
      status?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      job?: boolean | FactcheckJobDefaultArgs<ExtArgs>;
      providerRuns?: boolean | FactcheckClaim$providerRunsArgs<ExtArgs>;
      evidences?: boolean | FactcheckClaim$evidencesArgs<ExtArgs>;
      consensus?: boolean | FactcheckClaim$consensusArgs<ExtArgs>;
      verdictVersions?: boolean | FactcheckClaim$verdictVersionsArgs<ExtArgs>;
      units?: boolean | FactcheckClaim$unitsArgs<ExtArgs>;
      finding?: boolean | FactcheckClaim$findingArgs<ExtArgs>;
      _count?: boolean | FactcheckClaimCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["factcheckClaim"]
  >;

  export type FactcheckClaimSelectScalar = {
    id?: boolean;
    jobId?: boolean;
    text?: boolean;
    language?: boolean;
    topic?: boolean;
    falsifiable?: boolean;
    frames?: boolean;
    rhetoricalFlags?: boolean;
    canonicalKey?: boolean;
    scope?: boolean;
    timeframe?: boolean;
    status?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type FactcheckClaimOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | "id"
    | "jobId"
    | "text"
    | "language"
    | "topic"
    | "falsifiable"
    | "frames"
    | "rhetoricalFlags"
    | "canonicalKey"
    | "scope"
    | "timeframe"
    | "status"
    | "createdAt"
    | "updatedAt",
    ExtArgs["result"]["factcheckClaim"]
  >;
  export type FactcheckClaimInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    job?: boolean | FactcheckJobDefaultArgs<ExtArgs>;
    providerRuns?: boolean | FactcheckClaim$providerRunsArgs<ExtArgs>;
    evidences?: boolean | FactcheckClaim$evidencesArgs<ExtArgs>;
    consensus?: boolean | FactcheckClaim$consensusArgs<ExtArgs>;
    verdictVersions?: boolean | FactcheckClaim$verdictVersionsArgs<ExtArgs>;
    units?: boolean | FactcheckClaim$unitsArgs<ExtArgs>;
    finding?: boolean | FactcheckClaim$findingArgs<ExtArgs>;
    _count?: boolean | FactcheckClaimCountOutputTypeDefaultArgs<ExtArgs>;
  };

  export type $FactcheckClaimPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "FactcheckClaim";
    objects: {
      job: Prisma.$FactcheckJobPayload<ExtArgs>;
      providerRuns: Prisma.$ProviderRunPayload<ExtArgs>[];
      evidences: Prisma.$EvidencePayload<ExtArgs>[];
      consensus: Prisma.$ConsensusRunPayload<ExtArgs> | null;
      verdictVersions: Prisma.$VerdictVersionPayload<ExtArgs>[];
      units: Prisma.$ExtractedUnitPayload<ExtArgs>[];
      finding: Prisma.$FindingPayload<ExtArgs> | null;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        jobId: string;
        text: string;
        language: string | null;
        topic: string | null;
        falsifiable: boolean;
        frames: string[];
        rhetoricalFlags: string[];
        canonicalKey: string;
        scope: string | null;
        timeframe: string | null;
        status: $Enums.ReviewStatus;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs["result"]["factcheckClaim"]
    >;
    composites: {};
  };

  type FactcheckClaimGetPayload<
    S extends boolean | null | undefined | FactcheckClaimDefaultArgs,
  > = $Result.GetResult<Prisma.$FactcheckClaimPayload, S>;

  type FactcheckClaimCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    FactcheckClaimFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: FactcheckClaimCountAggregateInputType | true;
  };

  export interface FactcheckClaimDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["FactcheckClaim"];
      meta: { name: "FactcheckClaim" };
    };
    /**
     * Find zero or one FactcheckClaim that matches the filter.
     * @param {FactcheckClaimFindUniqueArgs} args - Arguments to find a FactcheckClaim
     * @example
     * // Get one FactcheckClaim
     * const factcheckClaim = await prisma.factcheckClaim.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FactcheckClaimFindUniqueArgs>(
      args: SelectSubset<T, FactcheckClaimFindUniqueArgs<ExtArgs>>,
    ): Prisma__FactcheckClaimClient<
      $Result.GetResult<
        Prisma.$FactcheckClaimPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one FactcheckClaim that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FactcheckClaimFindUniqueOrThrowArgs} args - Arguments to find a FactcheckClaim
     * @example
     * // Get one FactcheckClaim
     * const factcheckClaim = await prisma.factcheckClaim.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FactcheckClaimFindUniqueOrThrowArgs>(
      args: SelectSubset<T, FactcheckClaimFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__FactcheckClaimClient<
      $Result.GetResult<
        Prisma.$FactcheckClaimPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first FactcheckClaim that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactcheckClaimFindFirstArgs} args - Arguments to find a FactcheckClaim
     * @example
     * // Get one FactcheckClaim
     * const factcheckClaim = await prisma.factcheckClaim.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FactcheckClaimFindFirstArgs>(
      args?: SelectSubset<T, FactcheckClaimFindFirstArgs<ExtArgs>>,
    ): Prisma__FactcheckClaimClient<
      $Result.GetResult<
        Prisma.$FactcheckClaimPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first FactcheckClaim that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactcheckClaimFindFirstOrThrowArgs} args - Arguments to find a FactcheckClaim
     * @example
     * // Get one FactcheckClaim
     * const factcheckClaim = await prisma.factcheckClaim.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FactcheckClaimFindFirstOrThrowArgs>(
      args?: SelectSubset<T, FactcheckClaimFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__FactcheckClaimClient<
      $Result.GetResult<
        Prisma.$FactcheckClaimPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more FactcheckClaims that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactcheckClaimFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FactcheckClaims
     * const factcheckClaims = await prisma.factcheckClaim.findMany()
     *
     * // Get first 10 FactcheckClaims
     * const factcheckClaims = await prisma.factcheckClaim.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const factcheckClaimWithIdOnly = await prisma.factcheckClaim.findMany({ select: { id: true } })
     *
     */
    findMany<T extends FactcheckClaimFindManyArgs>(
      args?: SelectSubset<T, FactcheckClaimFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$FactcheckClaimPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a FactcheckClaim.
     * @param {FactcheckClaimCreateArgs} args - Arguments to create a FactcheckClaim.
     * @example
     * // Create one FactcheckClaim
     * const FactcheckClaim = await prisma.factcheckClaim.create({
     *   data: {
     *     // ... data to create a FactcheckClaim
     *   }
     * })
     *
     */
    create<T extends FactcheckClaimCreateArgs>(
      args: SelectSubset<T, FactcheckClaimCreateArgs<ExtArgs>>,
    ): Prisma__FactcheckClaimClient<
      $Result.GetResult<
        Prisma.$FactcheckClaimPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many FactcheckClaims.
     * @param {FactcheckClaimCreateManyArgs} args - Arguments to create many FactcheckClaims.
     * @example
     * // Create many FactcheckClaims
     * const factcheckClaim = await prisma.factcheckClaim.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends FactcheckClaimCreateManyArgs>(
      args?: SelectSubset<T, FactcheckClaimCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a FactcheckClaim.
     * @param {FactcheckClaimDeleteArgs} args - Arguments to delete one FactcheckClaim.
     * @example
     * // Delete one FactcheckClaim
     * const FactcheckClaim = await prisma.factcheckClaim.delete({
     *   where: {
     *     // ... filter to delete one FactcheckClaim
     *   }
     * })
     *
     */
    delete<T extends FactcheckClaimDeleteArgs>(
      args: SelectSubset<T, FactcheckClaimDeleteArgs<ExtArgs>>,
    ): Prisma__FactcheckClaimClient<
      $Result.GetResult<
        Prisma.$FactcheckClaimPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one FactcheckClaim.
     * @param {FactcheckClaimUpdateArgs} args - Arguments to update one FactcheckClaim.
     * @example
     * // Update one FactcheckClaim
     * const factcheckClaim = await prisma.factcheckClaim.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends FactcheckClaimUpdateArgs>(
      args: SelectSubset<T, FactcheckClaimUpdateArgs<ExtArgs>>,
    ): Prisma__FactcheckClaimClient<
      $Result.GetResult<
        Prisma.$FactcheckClaimPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more FactcheckClaims.
     * @param {FactcheckClaimDeleteManyArgs} args - Arguments to filter FactcheckClaims to delete.
     * @example
     * // Delete a few FactcheckClaims
     * const { count } = await prisma.factcheckClaim.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends FactcheckClaimDeleteManyArgs>(
      args?: SelectSubset<T, FactcheckClaimDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more FactcheckClaims.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactcheckClaimUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FactcheckClaims
     * const factcheckClaim = await prisma.factcheckClaim.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends FactcheckClaimUpdateManyArgs>(
      args: SelectSubset<T, FactcheckClaimUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one FactcheckClaim.
     * @param {FactcheckClaimUpsertArgs} args - Arguments to update or create a FactcheckClaim.
     * @example
     * // Update or create a FactcheckClaim
     * const factcheckClaim = await prisma.factcheckClaim.upsert({
     *   create: {
     *     // ... data to create a FactcheckClaim
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FactcheckClaim we want to update
     *   }
     * })
     */
    upsert<T extends FactcheckClaimUpsertArgs>(
      args: SelectSubset<T, FactcheckClaimUpsertArgs<ExtArgs>>,
    ): Prisma__FactcheckClaimClient<
      $Result.GetResult<
        Prisma.$FactcheckClaimPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more FactcheckClaims that matches the filter.
     * @param {FactcheckClaimFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const factcheckClaim = await prisma.factcheckClaim.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: FactcheckClaimFindRawArgs): Prisma.PrismaPromise<JsonObject>;

    /**
     * Perform aggregation operations on a FactcheckClaim.
     * @param {FactcheckClaimAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const factcheckClaim = await prisma.factcheckClaim.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(
      args?: FactcheckClaimAggregateRawArgs,
    ): Prisma.PrismaPromise<JsonObject>;

    /**
     * Count the number of FactcheckClaims.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactcheckClaimCountArgs} args - Arguments to filter FactcheckClaims to count.
     * @example
     * // Count the number of FactcheckClaims
     * const count = await prisma.factcheckClaim.count({
     *   where: {
     *     // ... the filter for the FactcheckClaims we want to count
     *   }
     * })
     **/
    count<T extends FactcheckClaimCountArgs>(
      args?: Subset<T, FactcheckClaimCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], FactcheckClaimCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a FactcheckClaim.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactcheckClaimAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends FactcheckClaimAggregateArgs>(
      args: Subset<T, FactcheckClaimAggregateArgs>,
    ): Prisma.PrismaPromise<GetFactcheckClaimAggregateType<T>>;

    /**
     * Group by FactcheckClaim.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactcheckClaimGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends FactcheckClaimGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FactcheckClaimGroupByArgs["orderBy"] }
        : { orderBy?: FactcheckClaimGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, FactcheckClaimGroupByArgs, OrderByArg> &
        InputErrors,
    ): {} extends InputErrors
      ? GetFactcheckClaimGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the FactcheckClaim model
     */
    readonly fields: FactcheckClaimFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FactcheckClaim.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FactcheckClaimClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    job<T extends FactcheckJobDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, FactcheckJobDefaultArgs<ExtArgs>>,
    ): Prisma__FactcheckJobClient<
      | $Result.GetResult<
          Prisma.$FactcheckJobPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    providerRuns<T extends FactcheckClaim$providerRunsArgs<ExtArgs> = {}>(
      args?: Subset<T, FactcheckClaim$providerRunsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$ProviderRunPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    evidences<T extends FactcheckClaim$evidencesArgs<ExtArgs> = {}>(
      args?: Subset<T, FactcheckClaim$evidencesArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$EvidencePayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    consensus<T extends FactcheckClaim$consensusArgs<ExtArgs> = {}>(
      args?: Subset<T, FactcheckClaim$consensusArgs<ExtArgs>>,
    ): Prisma__ConsensusRunClient<
      $Result.GetResult<
        Prisma.$ConsensusRunPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    verdictVersions<T extends FactcheckClaim$verdictVersionsArgs<ExtArgs> = {}>(
      args?: Subset<T, FactcheckClaim$verdictVersionsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$VerdictVersionPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    units<T extends FactcheckClaim$unitsArgs<ExtArgs> = {}>(
      args?: Subset<T, FactcheckClaim$unitsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$ExtractedUnitPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    finding<T extends FactcheckClaim$findingArgs<ExtArgs> = {}>(
      args?: Subset<T, FactcheckClaim$findingArgs<ExtArgs>>,
    ): Prisma__FindingClient<
      $Result.GetResult<
        Prisma.$FindingPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the FactcheckClaim model
   */
  interface FactcheckClaimFieldRefs {
    readonly id: FieldRef<"FactcheckClaim", "String">;
    readonly jobId: FieldRef<"FactcheckClaim", "String">;
    readonly text: FieldRef<"FactcheckClaim", "String">;
    readonly language: FieldRef<"FactcheckClaim", "String">;
    readonly topic: FieldRef<"FactcheckClaim", "String">;
    readonly falsifiable: FieldRef<"FactcheckClaim", "Boolean">;
    readonly frames: FieldRef<"FactcheckClaim", "String[]">;
    readonly rhetoricalFlags: FieldRef<"FactcheckClaim", "String[]">;
    readonly canonicalKey: FieldRef<"FactcheckClaim", "String">;
    readonly scope: FieldRef<"FactcheckClaim", "String">;
    readonly timeframe: FieldRef<"FactcheckClaim", "String">;
    readonly status: FieldRef<"FactcheckClaim", "ReviewStatus">;
    readonly createdAt: FieldRef<"FactcheckClaim", "DateTime">;
    readonly updatedAt: FieldRef<"FactcheckClaim", "DateTime">;
  }

  // Custom InputTypes
  /**
   * FactcheckClaim findUnique
   */
  export type FactcheckClaimFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactcheckClaim
     */
    select?: FactcheckClaimSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FactcheckClaim
     */
    omit?: FactcheckClaimOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactcheckClaimInclude<ExtArgs> | null;
    /**
     * Filter, which FactcheckClaim to fetch.
     */
    where: FactcheckClaimWhereUniqueInput;
  };

  /**
   * FactcheckClaim findUniqueOrThrow
   */
  export type FactcheckClaimFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactcheckClaim
     */
    select?: FactcheckClaimSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FactcheckClaim
     */
    omit?: FactcheckClaimOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactcheckClaimInclude<ExtArgs> | null;
    /**
     * Filter, which FactcheckClaim to fetch.
     */
    where: FactcheckClaimWhereUniqueInput;
  };

  /**
   * FactcheckClaim findFirst
   */
  export type FactcheckClaimFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactcheckClaim
     */
    select?: FactcheckClaimSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FactcheckClaim
     */
    omit?: FactcheckClaimOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactcheckClaimInclude<ExtArgs> | null;
    /**
     * Filter, which FactcheckClaim to fetch.
     */
    where?: FactcheckClaimWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of FactcheckClaims to fetch.
     */
    orderBy?:
      | FactcheckClaimOrderByWithRelationInput
      | FactcheckClaimOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for FactcheckClaims.
     */
    cursor?: FactcheckClaimWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` FactcheckClaims from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` FactcheckClaims.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of FactcheckClaims.
     */
    distinct?: FactcheckClaimScalarFieldEnum | FactcheckClaimScalarFieldEnum[];
  };

  /**
   * FactcheckClaim findFirstOrThrow
   */
  export type FactcheckClaimFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactcheckClaim
     */
    select?: FactcheckClaimSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FactcheckClaim
     */
    omit?: FactcheckClaimOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactcheckClaimInclude<ExtArgs> | null;
    /**
     * Filter, which FactcheckClaim to fetch.
     */
    where?: FactcheckClaimWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of FactcheckClaims to fetch.
     */
    orderBy?:
      | FactcheckClaimOrderByWithRelationInput
      | FactcheckClaimOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for FactcheckClaims.
     */
    cursor?: FactcheckClaimWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` FactcheckClaims from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` FactcheckClaims.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of FactcheckClaims.
     */
    distinct?: FactcheckClaimScalarFieldEnum | FactcheckClaimScalarFieldEnum[];
  };

  /**
   * FactcheckClaim findMany
   */
  export type FactcheckClaimFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactcheckClaim
     */
    select?: FactcheckClaimSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FactcheckClaim
     */
    omit?: FactcheckClaimOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactcheckClaimInclude<ExtArgs> | null;
    /**
     * Filter, which FactcheckClaims to fetch.
     */
    where?: FactcheckClaimWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of FactcheckClaims to fetch.
     */
    orderBy?:
      | FactcheckClaimOrderByWithRelationInput
      | FactcheckClaimOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing FactcheckClaims.
     */
    cursor?: FactcheckClaimWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` FactcheckClaims from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` FactcheckClaims.
     */
    skip?: number;
    distinct?: FactcheckClaimScalarFieldEnum | FactcheckClaimScalarFieldEnum[];
  };

  /**
   * FactcheckClaim create
   */
  export type FactcheckClaimCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactcheckClaim
     */
    select?: FactcheckClaimSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FactcheckClaim
     */
    omit?: FactcheckClaimOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactcheckClaimInclude<ExtArgs> | null;
    /**
     * The data needed to create a FactcheckClaim.
     */
    data: XOR<FactcheckClaimCreateInput, FactcheckClaimUncheckedCreateInput>;
  };

  /**
   * FactcheckClaim createMany
   */
  export type FactcheckClaimCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many FactcheckClaims.
     */
    data: FactcheckClaimCreateManyInput | FactcheckClaimCreateManyInput[];
  };

  /**
   * FactcheckClaim update
   */
  export type FactcheckClaimUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactcheckClaim
     */
    select?: FactcheckClaimSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FactcheckClaim
     */
    omit?: FactcheckClaimOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactcheckClaimInclude<ExtArgs> | null;
    /**
     * The data needed to update a FactcheckClaim.
     */
    data: XOR<FactcheckClaimUpdateInput, FactcheckClaimUncheckedUpdateInput>;
    /**
     * Choose, which FactcheckClaim to update.
     */
    where: FactcheckClaimWhereUniqueInput;
  };

  /**
   * FactcheckClaim updateMany
   */
  export type FactcheckClaimUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update FactcheckClaims.
     */
    data: XOR<
      FactcheckClaimUpdateManyMutationInput,
      FactcheckClaimUncheckedUpdateManyInput
    >;
    /**
     * Filter which FactcheckClaims to update
     */
    where?: FactcheckClaimWhereInput;
    /**
     * Limit how many FactcheckClaims to update.
     */
    limit?: number;
  };

  /**
   * FactcheckClaim upsert
   */
  export type FactcheckClaimUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactcheckClaim
     */
    select?: FactcheckClaimSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FactcheckClaim
     */
    omit?: FactcheckClaimOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactcheckClaimInclude<ExtArgs> | null;
    /**
     * The filter to search for the FactcheckClaim to update in case it exists.
     */
    where: FactcheckClaimWhereUniqueInput;
    /**
     * In case the FactcheckClaim found by the `where` argument doesn't exist, create a new FactcheckClaim with this data.
     */
    create: XOR<FactcheckClaimCreateInput, FactcheckClaimUncheckedCreateInput>;
    /**
     * In case the FactcheckClaim was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FactcheckClaimUpdateInput, FactcheckClaimUncheckedUpdateInput>;
  };

  /**
   * FactcheckClaim delete
   */
  export type FactcheckClaimDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactcheckClaim
     */
    select?: FactcheckClaimSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FactcheckClaim
     */
    omit?: FactcheckClaimOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactcheckClaimInclude<ExtArgs> | null;
    /**
     * Filter which FactcheckClaim to delete.
     */
    where: FactcheckClaimWhereUniqueInput;
  };

  /**
   * FactcheckClaim deleteMany
   */
  export type FactcheckClaimDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which FactcheckClaims to delete
     */
    where?: FactcheckClaimWhereInput;
    /**
     * Limit how many FactcheckClaims to delete.
     */
    limit?: number;
  };

  /**
   * FactcheckClaim findRaw
   */
  export type FactcheckClaimFindRawArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue;
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue;
  };

  /**
   * FactcheckClaim aggregateRaw
   */
  export type FactcheckClaimAggregateRawArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[];
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue;
  };

  /**
   * FactcheckClaim.providerRuns
   */
  export type FactcheckClaim$providerRunsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ProviderRun
     */
    select?: ProviderRunSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ProviderRun
     */
    omit?: ProviderRunOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderRunInclude<ExtArgs> | null;
    where?: ProviderRunWhereInput;
    orderBy?:
      | ProviderRunOrderByWithRelationInput
      | ProviderRunOrderByWithRelationInput[];
    cursor?: ProviderRunWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ProviderRunScalarFieldEnum | ProviderRunScalarFieldEnum[];
  };

  /**
   * FactcheckClaim.evidences
   */
  export type FactcheckClaim$evidencesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Evidence
     */
    select?: EvidenceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Evidence
     */
    omit?: EvidenceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenceInclude<ExtArgs> | null;
    where?: EvidenceWhereInput;
    orderBy?:
      | EvidenceOrderByWithRelationInput
      | EvidenceOrderByWithRelationInput[];
    cursor?: EvidenceWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: EvidenceScalarFieldEnum | EvidenceScalarFieldEnum[];
  };

  /**
   * FactcheckClaim.consensus
   */
  export type FactcheckClaim$consensusArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ConsensusRun
     */
    select?: ConsensusRunSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ConsensusRun
     */
    omit?: ConsensusRunOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsensusRunInclude<ExtArgs> | null;
    where?: ConsensusRunWhereInput;
  };

  /**
   * FactcheckClaim.verdictVersions
   */
  export type FactcheckClaim$verdictVersionsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the VerdictVersion
     */
    select?: VerdictVersionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the VerdictVersion
     */
    omit?: VerdictVersionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictVersionInclude<ExtArgs> | null;
    where?: VerdictVersionWhereInput;
    orderBy?:
      | VerdictVersionOrderByWithRelationInput
      | VerdictVersionOrderByWithRelationInput[];
    cursor?: VerdictVersionWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: VerdictVersionScalarFieldEnum | VerdictVersionScalarFieldEnum[];
  };

  /**
   * FactcheckClaim.units
   */
  export type FactcheckClaim$unitsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ExtractedUnit
     */
    select?: ExtractedUnitSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ExtractedUnit
     */
    omit?: ExtractedUnitOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExtractedUnitInclude<ExtArgs> | null;
    where?: ExtractedUnitWhereInput;
    orderBy?:
      | ExtractedUnitOrderByWithRelationInput
      | ExtractedUnitOrderByWithRelationInput[];
    cursor?: ExtractedUnitWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ExtractedUnitScalarFieldEnum | ExtractedUnitScalarFieldEnum[];
  };

  /**
   * FactcheckClaim.finding
   */
  export type FactcheckClaim$findingArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Finding
     */
    select?: FindingSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Finding
     */
    omit?: FindingOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FindingInclude<ExtArgs> | null;
    where?: FindingWhereInput;
  };

  /**
   * FactcheckClaim without action
   */
  export type FactcheckClaimDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactcheckClaim
     */
    select?: FactcheckClaimSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FactcheckClaim
     */
    omit?: FactcheckClaimOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactcheckClaimInclude<ExtArgs> | null;
  };

  /**
   * Model ProviderRun
   */

  export type AggregateProviderRun = {
    _count: ProviderRunCountAggregateOutputType | null;
    _avg: ProviderRunAvgAggregateOutputType | null;
    _sum: ProviderRunSumAggregateOutputType | null;
    _min: ProviderRunMinAggregateOutputType | null;
    _max: ProviderRunMaxAggregateOutputType | null;
  };

  export type ProviderRunAvgAggregateOutputType = {
    confidence: number | null;
    costTokens: number | null;
    latencyMs: number | null;
  };

  export type ProviderRunSumAggregateOutputType = {
    confidence: number | null;
    costTokens: number | null;
    latencyMs: number | null;
  };

  export type ProviderRunMinAggregateOutputType = {
    id: string | null;
    claimId: string | null;
    provider: string | null;
    verdict: string | null;
    confidence: number | null;
    costTokens: number | null;
    latencyMs: number | null;
    createdAt: Date | null;
  };

  export type ProviderRunMaxAggregateOutputType = {
    id: string | null;
    claimId: string | null;
    provider: string | null;
    verdict: string | null;
    confidence: number | null;
    costTokens: number | null;
    latencyMs: number | null;
    createdAt: Date | null;
  };

  export type ProviderRunCountAggregateOutputType = {
    id: number;
    claimId: number;
    provider: number;
    verdict: number;
    confidence: number;
    costTokens: number;
    latencyMs: number;
    raw: number;
    createdAt: number;
    _all: number;
  };

  export type ProviderRunAvgAggregateInputType = {
    confidence?: true;
    costTokens?: true;
    latencyMs?: true;
  };

  export type ProviderRunSumAggregateInputType = {
    confidence?: true;
    costTokens?: true;
    latencyMs?: true;
  };

  export type ProviderRunMinAggregateInputType = {
    id?: true;
    claimId?: true;
    provider?: true;
    verdict?: true;
    confidence?: true;
    costTokens?: true;
    latencyMs?: true;
    createdAt?: true;
  };

  export type ProviderRunMaxAggregateInputType = {
    id?: true;
    claimId?: true;
    provider?: true;
    verdict?: true;
    confidence?: true;
    costTokens?: true;
    latencyMs?: true;
    createdAt?: true;
  };

  export type ProviderRunCountAggregateInputType = {
    id?: true;
    claimId?: true;
    provider?: true;
    verdict?: true;
    confidence?: true;
    costTokens?: true;
    latencyMs?: true;
    raw?: true;
    createdAt?: true;
    _all?: true;
  };

  export type ProviderRunAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which ProviderRun to aggregate.
     */
    where?: ProviderRunWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ProviderRuns to fetch.
     */
    orderBy?:
      | ProviderRunOrderByWithRelationInput
      | ProviderRunOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: ProviderRunWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ProviderRuns from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ProviderRuns.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned ProviderRuns
     **/
    _count?: true | ProviderRunCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: ProviderRunAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: ProviderRunSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: ProviderRunMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: ProviderRunMaxAggregateInputType;
  };

  export type GetProviderRunAggregateType<T extends ProviderRunAggregateArgs> =
    {
      [P in keyof T & keyof AggregateProviderRun]: P extends "_count" | "count"
        ? T[P] extends true
          ? number
          : GetScalarType<T[P], AggregateProviderRun[P]>
        : GetScalarType<T[P], AggregateProviderRun[P]>;
    };

  export type ProviderRunGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ProviderRunWhereInput;
    orderBy?:
      | ProviderRunOrderByWithAggregationInput
      | ProviderRunOrderByWithAggregationInput[];
    by: ProviderRunScalarFieldEnum[] | ProviderRunScalarFieldEnum;
    having?: ProviderRunScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: ProviderRunCountAggregateInputType | true;
    _avg?: ProviderRunAvgAggregateInputType;
    _sum?: ProviderRunSumAggregateInputType;
    _min?: ProviderRunMinAggregateInputType;
    _max?: ProviderRunMaxAggregateInputType;
  };

  export type ProviderRunGroupByOutputType = {
    id: string;
    claimId: string;
    provider: string;
    verdict: string;
    confidence: number;
    costTokens: number;
    latencyMs: number;
    raw: JsonValue;
    createdAt: Date;
    _count: ProviderRunCountAggregateOutputType | null;
    _avg: ProviderRunAvgAggregateOutputType | null;
    _sum: ProviderRunSumAggregateOutputType | null;
    _min: ProviderRunMinAggregateOutputType | null;
    _max: ProviderRunMaxAggregateOutputType | null;
  };

  type GetProviderRunGroupByPayload<T extends ProviderRunGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<ProviderRunGroupByOutputType, T["by"]> & {
          [P in keyof T &
            keyof ProviderRunGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProviderRunGroupByOutputType[P]>
            : GetScalarType<T[P], ProviderRunGroupByOutputType[P]>;
        }
      >
    >;

  export type ProviderRunSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      claimId?: boolean;
      provider?: boolean;
      verdict?: boolean;
      confidence?: boolean;
      costTokens?: boolean;
      latencyMs?: boolean;
      raw?: boolean;
      createdAt?: boolean;
      claim?: boolean | FactcheckClaimDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["providerRun"]
  >;

  export type ProviderRunSelectScalar = {
    id?: boolean;
    claimId?: boolean;
    provider?: boolean;
    verdict?: boolean;
    confidence?: boolean;
    costTokens?: boolean;
    latencyMs?: boolean;
    raw?: boolean;
    createdAt?: boolean;
  };

  export type ProviderRunOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | "id"
    | "claimId"
    | "provider"
    | "verdict"
    | "confidence"
    | "costTokens"
    | "latencyMs"
    | "raw"
    | "createdAt",
    ExtArgs["result"]["providerRun"]
  >;
  export type ProviderRunInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    claim?: boolean | FactcheckClaimDefaultArgs<ExtArgs>;
  };

  export type $ProviderRunPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "ProviderRun";
    objects: {
      claim: Prisma.$FactcheckClaimPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        claimId: string;
        provider: string;
        verdict: string;
        confidence: number;
        costTokens: number;
        latencyMs: number;
        raw: Prisma.JsonValue;
        createdAt: Date;
      },
      ExtArgs["result"]["providerRun"]
    >;
    composites: {};
  };

  type ProviderRunGetPayload<
    S extends boolean | null | undefined | ProviderRunDefaultArgs,
  > = $Result.GetResult<Prisma.$ProviderRunPayload, S>;

  type ProviderRunCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    ProviderRunFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: ProviderRunCountAggregateInputType | true;
  };

  export interface ProviderRunDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["ProviderRun"];
      meta: { name: "ProviderRun" };
    };
    /**
     * Find zero or one ProviderRun that matches the filter.
     * @param {ProviderRunFindUniqueArgs} args - Arguments to find a ProviderRun
     * @example
     * // Get one ProviderRun
     * const providerRun = await prisma.providerRun.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProviderRunFindUniqueArgs>(
      args: SelectSubset<T, ProviderRunFindUniqueArgs<ExtArgs>>,
    ): Prisma__ProviderRunClient<
      $Result.GetResult<
        Prisma.$ProviderRunPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one ProviderRun that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProviderRunFindUniqueOrThrowArgs} args - Arguments to find a ProviderRun
     * @example
     * // Get one ProviderRun
     * const providerRun = await prisma.providerRun.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProviderRunFindUniqueOrThrowArgs>(
      args: SelectSubset<T, ProviderRunFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__ProviderRunClient<
      $Result.GetResult<
        Prisma.$ProviderRunPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first ProviderRun that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderRunFindFirstArgs} args - Arguments to find a ProviderRun
     * @example
     * // Get one ProviderRun
     * const providerRun = await prisma.providerRun.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProviderRunFindFirstArgs>(
      args?: SelectSubset<T, ProviderRunFindFirstArgs<ExtArgs>>,
    ): Prisma__ProviderRunClient<
      $Result.GetResult<
        Prisma.$ProviderRunPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first ProviderRun that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderRunFindFirstOrThrowArgs} args - Arguments to find a ProviderRun
     * @example
     * // Get one ProviderRun
     * const providerRun = await prisma.providerRun.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProviderRunFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ProviderRunFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__ProviderRunClient<
      $Result.GetResult<
        Prisma.$ProviderRunPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more ProviderRuns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderRunFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProviderRuns
     * const providerRuns = await prisma.providerRun.findMany()
     *
     * // Get first 10 ProviderRuns
     * const providerRuns = await prisma.providerRun.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const providerRunWithIdOnly = await prisma.providerRun.findMany({ select: { id: true } })
     *
     */
    findMany<T extends ProviderRunFindManyArgs>(
      args?: SelectSubset<T, ProviderRunFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ProviderRunPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a ProviderRun.
     * @param {ProviderRunCreateArgs} args - Arguments to create a ProviderRun.
     * @example
     * // Create one ProviderRun
     * const ProviderRun = await prisma.providerRun.create({
     *   data: {
     *     // ... data to create a ProviderRun
     *   }
     * })
     *
     */
    create<T extends ProviderRunCreateArgs>(
      args: SelectSubset<T, ProviderRunCreateArgs<ExtArgs>>,
    ): Prisma__ProviderRunClient<
      $Result.GetResult<
        Prisma.$ProviderRunPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many ProviderRuns.
     * @param {ProviderRunCreateManyArgs} args - Arguments to create many ProviderRuns.
     * @example
     * // Create many ProviderRuns
     * const providerRun = await prisma.providerRun.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends ProviderRunCreateManyArgs>(
      args?: SelectSubset<T, ProviderRunCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a ProviderRun.
     * @param {ProviderRunDeleteArgs} args - Arguments to delete one ProviderRun.
     * @example
     * // Delete one ProviderRun
     * const ProviderRun = await prisma.providerRun.delete({
     *   where: {
     *     // ... filter to delete one ProviderRun
     *   }
     * })
     *
     */
    delete<T extends ProviderRunDeleteArgs>(
      args: SelectSubset<T, ProviderRunDeleteArgs<ExtArgs>>,
    ): Prisma__ProviderRunClient<
      $Result.GetResult<
        Prisma.$ProviderRunPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one ProviderRun.
     * @param {ProviderRunUpdateArgs} args - Arguments to update one ProviderRun.
     * @example
     * // Update one ProviderRun
     * const providerRun = await prisma.providerRun.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends ProviderRunUpdateArgs>(
      args: SelectSubset<T, ProviderRunUpdateArgs<ExtArgs>>,
    ): Prisma__ProviderRunClient<
      $Result.GetResult<
        Prisma.$ProviderRunPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more ProviderRuns.
     * @param {ProviderRunDeleteManyArgs} args - Arguments to filter ProviderRuns to delete.
     * @example
     * // Delete a few ProviderRuns
     * const { count } = await prisma.providerRun.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends ProviderRunDeleteManyArgs>(
      args?: SelectSubset<T, ProviderRunDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more ProviderRuns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderRunUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProviderRuns
     * const providerRun = await prisma.providerRun.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends ProviderRunUpdateManyArgs>(
      args: SelectSubset<T, ProviderRunUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one ProviderRun.
     * @param {ProviderRunUpsertArgs} args - Arguments to update or create a ProviderRun.
     * @example
     * // Update or create a ProviderRun
     * const providerRun = await prisma.providerRun.upsert({
     *   create: {
     *     // ... data to create a ProviderRun
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProviderRun we want to update
     *   }
     * })
     */
    upsert<T extends ProviderRunUpsertArgs>(
      args: SelectSubset<T, ProviderRunUpsertArgs<ExtArgs>>,
    ): Prisma__ProviderRunClient<
      $Result.GetResult<
        Prisma.$ProviderRunPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more ProviderRuns that matches the filter.
     * @param {ProviderRunFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const providerRun = await prisma.providerRun.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: ProviderRunFindRawArgs): Prisma.PrismaPromise<JsonObject>;

    /**
     * Perform aggregation operations on a ProviderRun.
     * @param {ProviderRunAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const providerRun = await prisma.providerRun.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(
      args?: ProviderRunAggregateRawArgs,
    ): Prisma.PrismaPromise<JsonObject>;

    /**
     * Count the number of ProviderRuns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderRunCountArgs} args - Arguments to filter ProviderRuns to count.
     * @example
     * // Count the number of ProviderRuns
     * const count = await prisma.providerRun.count({
     *   where: {
     *     // ... the filter for the ProviderRuns we want to count
     *   }
     * })
     **/
    count<T extends ProviderRunCountArgs>(
      args?: Subset<T, ProviderRunCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], ProviderRunCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a ProviderRun.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderRunAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends ProviderRunAggregateArgs>(
      args: Subset<T, ProviderRunAggregateArgs>,
    ): Prisma.PrismaPromise<GetProviderRunAggregateType<T>>;

    /**
     * Group by ProviderRun.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderRunGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends ProviderRunGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProviderRunGroupByArgs["orderBy"] }
        : { orderBy?: ProviderRunGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, ProviderRunGroupByArgs, OrderByArg> &
        InputErrors,
    ): {} extends InputErrors
      ? GetProviderRunGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the ProviderRun model
     */
    readonly fields: ProviderRunFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProviderRun.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProviderRunClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    claim<T extends FactcheckClaimDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, FactcheckClaimDefaultArgs<ExtArgs>>,
    ): Prisma__FactcheckClaimClient<
      | $Result.GetResult<
          Prisma.$FactcheckClaimPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the ProviderRun model
   */
  interface ProviderRunFieldRefs {
    readonly id: FieldRef<"ProviderRun", "String">;
    readonly claimId: FieldRef<"ProviderRun", "String">;
    readonly provider: FieldRef<"ProviderRun", "String">;
    readonly verdict: FieldRef<"ProviderRun", "String">;
    readonly confidence: FieldRef<"ProviderRun", "Float">;
    readonly costTokens: FieldRef<"ProviderRun", "Int">;
    readonly latencyMs: FieldRef<"ProviderRun", "Int">;
    readonly raw: FieldRef<"ProviderRun", "Json">;
    readonly createdAt: FieldRef<"ProviderRun", "DateTime">;
  }

  // Custom InputTypes
  /**
   * ProviderRun findUnique
   */
  export type ProviderRunFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ProviderRun
     */
    select?: ProviderRunSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ProviderRun
     */
    omit?: ProviderRunOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderRunInclude<ExtArgs> | null;
    /**
     * Filter, which ProviderRun to fetch.
     */
    where: ProviderRunWhereUniqueInput;
  };

  /**
   * ProviderRun findUniqueOrThrow
   */
  export type ProviderRunFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ProviderRun
     */
    select?: ProviderRunSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ProviderRun
     */
    omit?: ProviderRunOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderRunInclude<ExtArgs> | null;
    /**
     * Filter, which ProviderRun to fetch.
     */
    where: ProviderRunWhereUniqueInput;
  };

  /**
   * ProviderRun findFirst
   */
  export type ProviderRunFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ProviderRun
     */
    select?: ProviderRunSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ProviderRun
     */
    omit?: ProviderRunOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderRunInclude<ExtArgs> | null;
    /**
     * Filter, which ProviderRun to fetch.
     */
    where?: ProviderRunWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ProviderRuns to fetch.
     */
    orderBy?:
      | ProviderRunOrderByWithRelationInput
      | ProviderRunOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ProviderRuns.
     */
    cursor?: ProviderRunWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ProviderRuns from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ProviderRuns.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ProviderRuns.
     */
    distinct?: ProviderRunScalarFieldEnum | ProviderRunScalarFieldEnum[];
  };

  /**
   * ProviderRun findFirstOrThrow
   */
  export type ProviderRunFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ProviderRun
     */
    select?: ProviderRunSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ProviderRun
     */
    omit?: ProviderRunOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderRunInclude<ExtArgs> | null;
    /**
     * Filter, which ProviderRun to fetch.
     */
    where?: ProviderRunWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ProviderRuns to fetch.
     */
    orderBy?:
      | ProviderRunOrderByWithRelationInput
      | ProviderRunOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ProviderRuns.
     */
    cursor?: ProviderRunWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ProviderRuns from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ProviderRuns.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ProviderRuns.
     */
    distinct?: ProviderRunScalarFieldEnum | ProviderRunScalarFieldEnum[];
  };

  /**
   * ProviderRun findMany
   */
  export type ProviderRunFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ProviderRun
     */
    select?: ProviderRunSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ProviderRun
     */
    omit?: ProviderRunOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderRunInclude<ExtArgs> | null;
    /**
     * Filter, which ProviderRuns to fetch.
     */
    where?: ProviderRunWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ProviderRuns to fetch.
     */
    orderBy?:
      | ProviderRunOrderByWithRelationInput
      | ProviderRunOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing ProviderRuns.
     */
    cursor?: ProviderRunWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ProviderRuns from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ProviderRuns.
     */
    skip?: number;
    distinct?: ProviderRunScalarFieldEnum | ProviderRunScalarFieldEnum[];
  };

  /**
   * ProviderRun create
   */
  export type ProviderRunCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ProviderRun
     */
    select?: ProviderRunSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ProviderRun
     */
    omit?: ProviderRunOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderRunInclude<ExtArgs> | null;
    /**
     * The data needed to create a ProviderRun.
     */
    data: XOR<ProviderRunCreateInput, ProviderRunUncheckedCreateInput>;
  };

  /**
   * ProviderRun createMany
   */
  export type ProviderRunCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many ProviderRuns.
     */
    data: ProviderRunCreateManyInput | ProviderRunCreateManyInput[];
  };

  /**
   * ProviderRun update
   */
  export type ProviderRunUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ProviderRun
     */
    select?: ProviderRunSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ProviderRun
     */
    omit?: ProviderRunOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderRunInclude<ExtArgs> | null;
    /**
     * The data needed to update a ProviderRun.
     */
    data: XOR<ProviderRunUpdateInput, ProviderRunUncheckedUpdateInput>;
    /**
     * Choose, which ProviderRun to update.
     */
    where: ProviderRunWhereUniqueInput;
  };

  /**
   * ProviderRun updateMany
   */
  export type ProviderRunUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update ProviderRuns.
     */
    data: XOR<
      ProviderRunUpdateManyMutationInput,
      ProviderRunUncheckedUpdateManyInput
    >;
    /**
     * Filter which ProviderRuns to update
     */
    where?: ProviderRunWhereInput;
    /**
     * Limit how many ProviderRuns to update.
     */
    limit?: number;
  };

  /**
   * ProviderRun upsert
   */
  export type ProviderRunUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ProviderRun
     */
    select?: ProviderRunSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ProviderRun
     */
    omit?: ProviderRunOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderRunInclude<ExtArgs> | null;
    /**
     * The filter to search for the ProviderRun to update in case it exists.
     */
    where: ProviderRunWhereUniqueInput;
    /**
     * In case the ProviderRun found by the `where` argument doesn't exist, create a new ProviderRun with this data.
     */
    create: XOR<ProviderRunCreateInput, ProviderRunUncheckedCreateInput>;
    /**
     * In case the ProviderRun was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProviderRunUpdateInput, ProviderRunUncheckedUpdateInput>;
  };

  /**
   * ProviderRun delete
   */
  export type ProviderRunDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ProviderRun
     */
    select?: ProviderRunSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ProviderRun
     */
    omit?: ProviderRunOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderRunInclude<ExtArgs> | null;
    /**
     * Filter which ProviderRun to delete.
     */
    where: ProviderRunWhereUniqueInput;
  };

  /**
   * ProviderRun deleteMany
   */
  export type ProviderRunDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which ProviderRuns to delete
     */
    where?: ProviderRunWhereInput;
    /**
     * Limit how many ProviderRuns to delete.
     */
    limit?: number;
  };

  /**
   * ProviderRun findRaw
   */
  export type ProviderRunFindRawArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue;
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue;
  };

  /**
   * ProviderRun aggregateRaw
   */
  export type ProviderRunAggregateRawArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[];
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue;
  };

  /**
   * ProviderRun without action
   */
  export type ProviderRunDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ProviderRun
     */
    select?: ProviderRunSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ProviderRun
     */
    omit?: ProviderRunOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderRunInclude<ExtArgs> | null;
  };

  /**
   * Model ConsensusRun
   */

  export type AggregateConsensusRun = {
    _count: ConsensusRunCountAggregateOutputType | null;
    _avg: ConsensusRunAvgAggregateOutputType | null;
    _sum: ConsensusRunSumAggregateOutputType | null;
    _min: ConsensusRunMinAggregateOutputType | null;
    _max: ConsensusRunMaxAggregateOutputType | null;
  };

  export type ConsensusRunAvgAggregateOutputType = {
    confidence: number | null;
    balanceScore: number | null;
    diversityIndex: number | null;
  };

  export type ConsensusRunSumAggregateOutputType = {
    confidence: number | null;
    balanceScore: number | null;
    diversityIndex: number | null;
  };

  export type ConsensusRunMinAggregateOutputType = {
    id: string | null;
    claimId: string | null;
    method: string | null;
    verdict: string | null;
    confidence: number | null;
    balanceScore: number | null;
    diversityIndex: number | null;
    createdAt: Date | null;
  };

  export type ConsensusRunMaxAggregateOutputType = {
    id: string | null;
    claimId: string | null;
    method: string | null;
    verdict: string | null;
    confidence: number | null;
    balanceScore: number | null;
    diversityIndex: number | null;
    createdAt: Date | null;
  };

  export type ConsensusRunCountAggregateOutputType = {
    id: number;
    claimId: number;
    method: number;
    verdict: number;
    confidence: number;
    balanceScore: number;
    diversityIndex: number;
    providers: number;
    createdAt: number;
    _all: number;
  };

  export type ConsensusRunAvgAggregateInputType = {
    confidence?: true;
    balanceScore?: true;
    diversityIndex?: true;
  };

  export type ConsensusRunSumAggregateInputType = {
    confidence?: true;
    balanceScore?: true;
    diversityIndex?: true;
  };

  export type ConsensusRunMinAggregateInputType = {
    id?: true;
    claimId?: true;
    method?: true;
    verdict?: true;
    confidence?: true;
    balanceScore?: true;
    diversityIndex?: true;
    createdAt?: true;
  };

  export type ConsensusRunMaxAggregateInputType = {
    id?: true;
    claimId?: true;
    method?: true;
    verdict?: true;
    confidence?: true;
    balanceScore?: true;
    diversityIndex?: true;
    createdAt?: true;
  };

  export type ConsensusRunCountAggregateInputType = {
    id?: true;
    claimId?: true;
    method?: true;
    verdict?: true;
    confidence?: true;
    balanceScore?: true;
    diversityIndex?: true;
    providers?: true;
    createdAt?: true;
    _all?: true;
  };

  export type ConsensusRunAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which ConsensusRun to aggregate.
     */
    where?: ConsensusRunWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ConsensusRuns to fetch.
     */
    orderBy?:
      | ConsensusRunOrderByWithRelationInput
      | ConsensusRunOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: ConsensusRunWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ConsensusRuns from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ConsensusRuns.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned ConsensusRuns
     **/
    _count?: true | ConsensusRunCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: ConsensusRunAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: ConsensusRunSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: ConsensusRunMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: ConsensusRunMaxAggregateInputType;
  };

  export type GetConsensusRunAggregateType<
    T extends ConsensusRunAggregateArgs,
  > = {
    [P in keyof T & keyof AggregateConsensusRun]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConsensusRun[P]>
      : GetScalarType<T[P], AggregateConsensusRun[P]>;
  };

  export type ConsensusRunGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ConsensusRunWhereInput;
    orderBy?:
      | ConsensusRunOrderByWithAggregationInput
      | ConsensusRunOrderByWithAggregationInput[];
    by: ConsensusRunScalarFieldEnum[] | ConsensusRunScalarFieldEnum;
    having?: ConsensusRunScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: ConsensusRunCountAggregateInputType | true;
    _avg?: ConsensusRunAvgAggregateInputType;
    _sum?: ConsensusRunSumAggregateInputType;
    _min?: ConsensusRunMinAggregateInputType;
    _max?: ConsensusRunMaxAggregateInputType;
  };

  export type ConsensusRunGroupByOutputType = {
    id: string;
    claimId: string;
    method: string;
    verdict: string;
    confidence: number;
    balanceScore: number;
    diversityIndex: number;
    providers: JsonValue;
    createdAt: Date;
    _count: ConsensusRunCountAggregateOutputType | null;
    _avg: ConsensusRunAvgAggregateOutputType | null;
    _sum: ConsensusRunSumAggregateOutputType | null;
    _min: ConsensusRunMinAggregateOutputType | null;
    _max: ConsensusRunMaxAggregateOutputType | null;
  };

  type GetConsensusRunGroupByPayload<T extends ConsensusRunGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<ConsensusRunGroupByOutputType, T["by"]> & {
          [P in keyof T &
            keyof ConsensusRunGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConsensusRunGroupByOutputType[P]>
            : GetScalarType<T[P], ConsensusRunGroupByOutputType[P]>;
        }
      >
    >;

  export type ConsensusRunSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      claimId?: boolean;
      method?: boolean;
      verdict?: boolean;
      confidence?: boolean;
      balanceScore?: boolean;
      diversityIndex?: boolean;
      providers?: boolean;
      createdAt?: boolean;
      claim?: boolean | FactcheckClaimDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["consensusRun"]
  >;

  export type ConsensusRunSelectScalar = {
    id?: boolean;
    claimId?: boolean;
    method?: boolean;
    verdict?: boolean;
    confidence?: boolean;
    balanceScore?: boolean;
    diversityIndex?: boolean;
    providers?: boolean;
    createdAt?: boolean;
  };

  export type ConsensusRunOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | "id"
    | "claimId"
    | "method"
    | "verdict"
    | "confidence"
    | "balanceScore"
    | "diversityIndex"
    | "providers"
    | "createdAt",
    ExtArgs["result"]["consensusRun"]
  >;
  export type ConsensusRunInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    claim?: boolean | FactcheckClaimDefaultArgs<ExtArgs>;
  };

  export type $ConsensusRunPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "ConsensusRun";
    objects: {
      claim: Prisma.$FactcheckClaimPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        claimId: string;
        method: string;
        verdict: string;
        confidence: number;
        balanceScore: number;
        diversityIndex: number;
        providers: Prisma.JsonValue;
        createdAt: Date;
      },
      ExtArgs["result"]["consensusRun"]
    >;
    composites: {};
  };

  type ConsensusRunGetPayload<
    S extends boolean | null | undefined | ConsensusRunDefaultArgs,
  > = $Result.GetResult<Prisma.$ConsensusRunPayload, S>;

  type ConsensusRunCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    ConsensusRunFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: ConsensusRunCountAggregateInputType | true;
  };

  export interface ConsensusRunDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["ConsensusRun"];
      meta: { name: "ConsensusRun" };
    };
    /**
     * Find zero or one ConsensusRun that matches the filter.
     * @param {ConsensusRunFindUniqueArgs} args - Arguments to find a ConsensusRun
     * @example
     * // Get one ConsensusRun
     * const consensusRun = await prisma.consensusRun.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConsensusRunFindUniqueArgs>(
      args: SelectSubset<T, ConsensusRunFindUniqueArgs<ExtArgs>>,
    ): Prisma__ConsensusRunClient<
      $Result.GetResult<
        Prisma.$ConsensusRunPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one ConsensusRun that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ConsensusRunFindUniqueOrThrowArgs} args - Arguments to find a ConsensusRun
     * @example
     * // Get one ConsensusRun
     * const consensusRun = await prisma.consensusRun.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConsensusRunFindUniqueOrThrowArgs>(
      args: SelectSubset<T, ConsensusRunFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__ConsensusRunClient<
      $Result.GetResult<
        Prisma.$ConsensusRunPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first ConsensusRun that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsensusRunFindFirstArgs} args - Arguments to find a ConsensusRun
     * @example
     * // Get one ConsensusRun
     * const consensusRun = await prisma.consensusRun.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConsensusRunFindFirstArgs>(
      args?: SelectSubset<T, ConsensusRunFindFirstArgs<ExtArgs>>,
    ): Prisma__ConsensusRunClient<
      $Result.GetResult<
        Prisma.$ConsensusRunPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first ConsensusRun that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsensusRunFindFirstOrThrowArgs} args - Arguments to find a ConsensusRun
     * @example
     * // Get one ConsensusRun
     * const consensusRun = await prisma.consensusRun.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConsensusRunFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ConsensusRunFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__ConsensusRunClient<
      $Result.GetResult<
        Prisma.$ConsensusRunPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more ConsensusRuns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsensusRunFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ConsensusRuns
     * const consensusRuns = await prisma.consensusRun.findMany()
     *
     * // Get first 10 ConsensusRuns
     * const consensusRuns = await prisma.consensusRun.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const consensusRunWithIdOnly = await prisma.consensusRun.findMany({ select: { id: true } })
     *
     */
    findMany<T extends ConsensusRunFindManyArgs>(
      args?: SelectSubset<T, ConsensusRunFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ConsensusRunPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a ConsensusRun.
     * @param {ConsensusRunCreateArgs} args - Arguments to create a ConsensusRun.
     * @example
     * // Create one ConsensusRun
     * const ConsensusRun = await prisma.consensusRun.create({
     *   data: {
     *     // ... data to create a ConsensusRun
     *   }
     * })
     *
     */
    create<T extends ConsensusRunCreateArgs>(
      args: SelectSubset<T, ConsensusRunCreateArgs<ExtArgs>>,
    ): Prisma__ConsensusRunClient<
      $Result.GetResult<
        Prisma.$ConsensusRunPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many ConsensusRuns.
     * @param {ConsensusRunCreateManyArgs} args - Arguments to create many ConsensusRuns.
     * @example
     * // Create many ConsensusRuns
     * const consensusRun = await prisma.consensusRun.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends ConsensusRunCreateManyArgs>(
      args?: SelectSubset<T, ConsensusRunCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a ConsensusRun.
     * @param {ConsensusRunDeleteArgs} args - Arguments to delete one ConsensusRun.
     * @example
     * // Delete one ConsensusRun
     * const ConsensusRun = await prisma.consensusRun.delete({
     *   where: {
     *     // ... filter to delete one ConsensusRun
     *   }
     * })
     *
     */
    delete<T extends ConsensusRunDeleteArgs>(
      args: SelectSubset<T, ConsensusRunDeleteArgs<ExtArgs>>,
    ): Prisma__ConsensusRunClient<
      $Result.GetResult<
        Prisma.$ConsensusRunPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one ConsensusRun.
     * @param {ConsensusRunUpdateArgs} args - Arguments to update one ConsensusRun.
     * @example
     * // Update one ConsensusRun
     * const consensusRun = await prisma.consensusRun.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends ConsensusRunUpdateArgs>(
      args: SelectSubset<T, ConsensusRunUpdateArgs<ExtArgs>>,
    ): Prisma__ConsensusRunClient<
      $Result.GetResult<
        Prisma.$ConsensusRunPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more ConsensusRuns.
     * @param {ConsensusRunDeleteManyArgs} args - Arguments to filter ConsensusRuns to delete.
     * @example
     * // Delete a few ConsensusRuns
     * const { count } = await prisma.consensusRun.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends ConsensusRunDeleteManyArgs>(
      args?: SelectSubset<T, ConsensusRunDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more ConsensusRuns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsensusRunUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ConsensusRuns
     * const consensusRun = await prisma.consensusRun.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends ConsensusRunUpdateManyArgs>(
      args: SelectSubset<T, ConsensusRunUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one ConsensusRun.
     * @param {ConsensusRunUpsertArgs} args - Arguments to update or create a ConsensusRun.
     * @example
     * // Update or create a ConsensusRun
     * const consensusRun = await prisma.consensusRun.upsert({
     *   create: {
     *     // ... data to create a ConsensusRun
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ConsensusRun we want to update
     *   }
     * })
     */
    upsert<T extends ConsensusRunUpsertArgs>(
      args: SelectSubset<T, ConsensusRunUpsertArgs<ExtArgs>>,
    ): Prisma__ConsensusRunClient<
      $Result.GetResult<
        Prisma.$ConsensusRunPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more ConsensusRuns that matches the filter.
     * @param {ConsensusRunFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const consensusRun = await prisma.consensusRun.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: ConsensusRunFindRawArgs): Prisma.PrismaPromise<JsonObject>;

    /**
     * Perform aggregation operations on a ConsensusRun.
     * @param {ConsensusRunAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const consensusRun = await prisma.consensusRun.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(
      args?: ConsensusRunAggregateRawArgs,
    ): Prisma.PrismaPromise<JsonObject>;

    /**
     * Count the number of ConsensusRuns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsensusRunCountArgs} args - Arguments to filter ConsensusRuns to count.
     * @example
     * // Count the number of ConsensusRuns
     * const count = await prisma.consensusRun.count({
     *   where: {
     *     // ... the filter for the ConsensusRuns we want to count
     *   }
     * })
     **/
    count<T extends ConsensusRunCountArgs>(
      args?: Subset<T, ConsensusRunCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], ConsensusRunCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a ConsensusRun.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsensusRunAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends ConsensusRunAggregateArgs>(
      args: Subset<T, ConsensusRunAggregateArgs>,
    ): Prisma.PrismaPromise<GetConsensusRunAggregateType<T>>;

    /**
     * Group by ConsensusRun.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsensusRunGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends ConsensusRunGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConsensusRunGroupByArgs["orderBy"] }
        : { orderBy?: ConsensusRunGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, ConsensusRunGroupByArgs, OrderByArg> &
        InputErrors,
    ): {} extends InputErrors
      ? GetConsensusRunGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the ConsensusRun model
     */
    readonly fields: ConsensusRunFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ConsensusRun.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConsensusRunClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    claim<T extends FactcheckClaimDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, FactcheckClaimDefaultArgs<ExtArgs>>,
    ): Prisma__FactcheckClaimClient<
      | $Result.GetResult<
          Prisma.$FactcheckClaimPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the ConsensusRun model
   */
  interface ConsensusRunFieldRefs {
    readonly id: FieldRef<"ConsensusRun", "String">;
    readonly claimId: FieldRef<"ConsensusRun", "String">;
    readonly method: FieldRef<"ConsensusRun", "String">;
    readonly verdict: FieldRef<"ConsensusRun", "String">;
    readonly confidence: FieldRef<"ConsensusRun", "Float">;
    readonly balanceScore: FieldRef<"ConsensusRun", "Float">;
    readonly diversityIndex: FieldRef<"ConsensusRun", "Float">;
    readonly providers: FieldRef<"ConsensusRun", "Json">;
    readonly createdAt: FieldRef<"ConsensusRun", "DateTime">;
  }

  // Custom InputTypes
  /**
   * ConsensusRun findUnique
   */
  export type ConsensusRunFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ConsensusRun
     */
    select?: ConsensusRunSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ConsensusRun
     */
    omit?: ConsensusRunOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsensusRunInclude<ExtArgs> | null;
    /**
     * Filter, which ConsensusRun to fetch.
     */
    where: ConsensusRunWhereUniqueInput;
  };

  /**
   * ConsensusRun findUniqueOrThrow
   */
  export type ConsensusRunFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ConsensusRun
     */
    select?: ConsensusRunSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ConsensusRun
     */
    omit?: ConsensusRunOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsensusRunInclude<ExtArgs> | null;
    /**
     * Filter, which ConsensusRun to fetch.
     */
    where: ConsensusRunWhereUniqueInput;
  };

  /**
   * ConsensusRun findFirst
   */
  export type ConsensusRunFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ConsensusRun
     */
    select?: ConsensusRunSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ConsensusRun
     */
    omit?: ConsensusRunOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsensusRunInclude<ExtArgs> | null;
    /**
     * Filter, which ConsensusRun to fetch.
     */
    where?: ConsensusRunWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ConsensusRuns to fetch.
     */
    orderBy?:
      | ConsensusRunOrderByWithRelationInput
      | ConsensusRunOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ConsensusRuns.
     */
    cursor?: ConsensusRunWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ConsensusRuns from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ConsensusRuns.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ConsensusRuns.
     */
    distinct?: ConsensusRunScalarFieldEnum | ConsensusRunScalarFieldEnum[];
  };

  /**
   * ConsensusRun findFirstOrThrow
   */
  export type ConsensusRunFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ConsensusRun
     */
    select?: ConsensusRunSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ConsensusRun
     */
    omit?: ConsensusRunOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsensusRunInclude<ExtArgs> | null;
    /**
     * Filter, which ConsensusRun to fetch.
     */
    where?: ConsensusRunWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ConsensusRuns to fetch.
     */
    orderBy?:
      | ConsensusRunOrderByWithRelationInput
      | ConsensusRunOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ConsensusRuns.
     */
    cursor?: ConsensusRunWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ConsensusRuns from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ConsensusRuns.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ConsensusRuns.
     */
    distinct?: ConsensusRunScalarFieldEnum | ConsensusRunScalarFieldEnum[];
  };

  /**
   * ConsensusRun findMany
   */
  export type ConsensusRunFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ConsensusRun
     */
    select?: ConsensusRunSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ConsensusRun
     */
    omit?: ConsensusRunOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsensusRunInclude<ExtArgs> | null;
    /**
     * Filter, which ConsensusRuns to fetch.
     */
    where?: ConsensusRunWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ConsensusRuns to fetch.
     */
    orderBy?:
      | ConsensusRunOrderByWithRelationInput
      | ConsensusRunOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing ConsensusRuns.
     */
    cursor?: ConsensusRunWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ConsensusRuns from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ConsensusRuns.
     */
    skip?: number;
    distinct?: ConsensusRunScalarFieldEnum | ConsensusRunScalarFieldEnum[];
  };

  /**
   * ConsensusRun create
   */
  export type ConsensusRunCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ConsensusRun
     */
    select?: ConsensusRunSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ConsensusRun
     */
    omit?: ConsensusRunOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsensusRunInclude<ExtArgs> | null;
    /**
     * The data needed to create a ConsensusRun.
     */
    data: XOR<ConsensusRunCreateInput, ConsensusRunUncheckedCreateInput>;
  };

  /**
   * ConsensusRun createMany
   */
  export type ConsensusRunCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many ConsensusRuns.
     */
    data: ConsensusRunCreateManyInput | ConsensusRunCreateManyInput[];
  };

  /**
   * ConsensusRun update
   */
  export type ConsensusRunUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ConsensusRun
     */
    select?: ConsensusRunSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ConsensusRun
     */
    omit?: ConsensusRunOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsensusRunInclude<ExtArgs> | null;
    /**
     * The data needed to update a ConsensusRun.
     */
    data: XOR<ConsensusRunUpdateInput, ConsensusRunUncheckedUpdateInput>;
    /**
     * Choose, which ConsensusRun to update.
     */
    where: ConsensusRunWhereUniqueInput;
  };

  /**
   * ConsensusRun updateMany
   */
  export type ConsensusRunUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update ConsensusRuns.
     */
    data: XOR<
      ConsensusRunUpdateManyMutationInput,
      ConsensusRunUncheckedUpdateManyInput
    >;
    /**
     * Filter which ConsensusRuns to update
     */
    where?: ConsensusRunWhereInput;
    /**
     * Limit how many ConsensusRuns to update.
     */
    limit?: number;
  };

  /**
   * ConsensusRun upsert
   */
  export type ConsensusRunUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ConsensusRun
     */
    select?: ConsensusRunSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ConsensusRun
     */
    omit?: ConsensusRunOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsensusRunInclude<ExtArgs> | null;
    /**
     * The filter to search for the ConsensusRun to update in case it exists.
     */
    where: ConsensusRunWhereUniqueInput;
    /**
     * In case the ConsensusRun found by the `where` argument doesn't exist, create a new ConsensusRun with this data.
     */
    create: XOR<ConsensusRunCreateInput, ConsensusRunUncheckedCreateInput>;
    /**
     * In case the ConsensusRun was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConsensusRunUpdateInput, ConsensusRunUncheckedUpdateInput>;
  };

  /**
   * ConsensusRun delete
   */
  export type ConsensusRunDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ConsensusRun
     */
    select?: ConsensusRunSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ConsensusRun
     */
    omit?: ConsensusRunOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsensusRunInclude<ExtArgs> | null;
    /**
     * Filter which ConsensusRun to delete.
     */
    where: ConsensusRunWhereUniqueInput;
  };

  /**
   * ConsensusRun deleteMany
   */
  export type ConsensusRunDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which ConsensusRuns to delete
     */
    where?: ConsensusRunWhereInput;
    /**
     * Limit how many ConsensusRuns to delete.
     */
    limit?: number;
  };

  /**
   * ConsensusRun findRaw
   */
  export type ConsensusRunFindRawArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue;
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue;
  };

  /**
   * ConsensusRun aggregateRaw
   */
  export type ConsensusRunAggregateRawArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[];
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue;
  };

  /**
   * ConsensusRun without action
   */
  export type ConsensusRunDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ConsensusRun
     */
    select?: ConsensusRunSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ConsensusRun
     */
    omit?: ConsensusRunOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsensusRunInclude<ExtArgs> | null;
  };

  /**
   * Model Evidence
   */

  export type AggregateEvidence = {
    _count: EvidenceCountAggregateOutputType | null;
    _avg: EvidenceAvgAggregateOutputType | null;
    _sum: EvidenceSumAggregateOutputType | null;
    _min: EvidenceMinAggregateOutputType | null;
    _max: EvidenceMaxAggregateOutputType | null;
  };

  export type EvidenceAvgAggregateOutputType = {
    trustScore: number | null;
  };

  export type EvidenceSumAggregateOutputType = {
    trustScore: number | null;
  };

  export type EvidenceMinAggregateOutputType = {
    id: string | null;
    claimId: string | null;
    url: string | null;
    domain: string | null;
    stance: $Enums.Stance | null;
    snapshotHash: string | null;
    firstSeenAt: Date | null;
    trustScore: number | null;
  };

  export type EvidenceMaxAggregateOutputType = {
    id: string | null;
    claimId: string | null;
    url: string | null;
    domain: string | null;
    stance: $Enums.Stance | null;
    snapshotHash: string | null;
    firstSeenAt: Date | null;
    trustScore: number | null;
  };

  export type EvidenceCountAggregateOutputType = {
    id: number;
    claimId: number;
    url: number;
    domain: number;
    stance: number;
    snapshotHash: number;
    firstSeenAt: number;
    trustScore: number;
    _all: number;
  };

  export type EvidenceAvgAggregateInputType = {
    trustScore?: true;
  };

  export type EvidenceSumAggregateInputType = {
    trustScore?: true;
  };

  export type EvidenceMinAggregateInputType = {
    id?: true;
    claimId?: true;
    url?: true;
    domain?: true;
    stance?: true;
    snapshotHash?: true;
    firstSeenAt?: true;
    trustScore?: true;
  };

  export type EvidenceMaxAggregateInputType = {
    id?: true;
    claimId?: true;
    url?: true;
    domain?: true;
    stance?: true;
    snapshotHash?: true;
    firstSeenAt?: true;
    trustScore?: true;
  };

  export type EvidenceCountAggregateInputType = {
    id?: true;
    claimId?: true;
    url?: true;
    domain?: true;
    stance?: true;
    snapshotHash?: true;
    firstSeenAt?: true;
    trustScore?: true;
    _all?: true;
  };

  export type EvidenceAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Evidence to aggregate.
     */
    where?: EvidenceWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Evidences to fetch.
     */
    orderBy?:
      | EvidenceOrderByWithRelationInput
      | EvidenceOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: EvidenceWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Evidences from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Evidences.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Evidences
     **/
    _count?: true | EvidenceCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: EvidenceAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: EvidenceSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: EvidenceMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: EvidenceMaxAggregateInputType;
  };

  export type GetEvidenceAggregateType<T extends EvidenceAggregateArgs> = {
    [P in keyof T & keyof AggregateEvidence]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvidence[P]>
      : GetScalarType<T[P], AggregateEvidence[P]>;
  };

  export type EvidenceGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: EvidenceWhereInput;
    orderBy?:
      | EvidenceOrderByWithAggregationInput
      | EvidenceOrderByWithAggregationInput[];
    by: EvidenceScalarFieldEnum[] | EvidenceScalarFieldEnum;
    having?: EvidenceScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: EvidenceCountAggregateInputType | true;
    _avg?: EvidenceAvgAggregateInputType;
    _sum?: EvidenceSumAggregateInputType;
    _min?: EvidenceMinAggregateInputType;
    _max?: EvidenceMaxAggregateInputType;
  };

  export type EvidenceGroupByOutputType = {
    id: string;
    claimId: string;
    url: string;
    domain: string;
    stance: $Enums.Stance;
    snapshotHash: string | null;
    firstSeenAt: Date | null;
    trustScore: number | null;
    _count: EvidenceCountAggregateOutputType | null;
    _avg: EvidenceAvgAggregateOutputType | null;
    _sum: EvidenceSumAggregateOutputType | null;
    _min: EvidenceMinAggregateOutputType | null;
    _max: EvidenceMaxAggregateOutputType | null;
  };

  type GetEvidenceGroupByPayload<T extends EvidenceGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<EvidenceGroupByOutputType, T["by"]> & {
          [P in keyof T & keyof EvidenceGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EvidenceGroupByOutputType[P]>
            : GetScalarType<T[P], EvidenceGroupByOutputType[P]>;
        }
      >
    >;

  export type EvidenceSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      claimId?: boolean;
      url?: boolean;
      domain?: boolean;
      stance?: boolean;
      snapshotHash?: boolean;
      firstSeenAt?: boolean;
      trustScore?: boolean;
      claim?: boolean | FactcheckClaimDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["evidence"]
  >;

  export type EvidenceSelectScalar = {
    id?: boolean;
    claimId?: boolean;
    url?: boolean;
    domain?: boolean;
    stance?: boolean;
    snapshotHash?: boolean;
    firstSeenAt?: boolean;
    trustScore?: boolean;
  };

  export type EvidenceOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | "id"
    | "claimId"
    | "url"
    | "domain"
    | "stance"
    | "snapshotHash"
    | "firstSeenAt"
    | "trustScore",
    ExtArgs["result"]["evidence"]
  >;
  export type EvidenceInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    claim?: boolean | FactcheckClaimDefaultArgs<ExtArgs>;
  };

  export type $EvidencePayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "Evidence";
    objects: {
      claim: Prisma.$FactcheckClaimPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        claimId: string;
        url: string;
        domain: string;
        stance: $Enums.Stance;
        snapshotHash: string | null;
        firstSeenAt: Date | null;
        trustScore: number | null;
      },
      ExtArgs["result"]["evidence"]
    >;
    composites: {};
  };

  type EvidenceGetPayload<
    S extends boolean | null | undefined | EvidenceDefaultArgs,
  > = $Result.GetResult<Prisma.$EvidencePayload, S>;

  type EvidenceCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<EvidenceFindManyArgs, "select" | "include" | "distinct" | "omit"> & {
    select?: EvidenceCountAggregateInputType | true;
  };

  export interface EvidenceDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["Evidence"];
      meta: { name: "Evidence" };
    };
    /**
     * Find zero or one Evidence that matches the filter.
     * @param {EvidenceFindUniqueArgs} args - Arguments to find a Evidence
     * @example
     * // Get one Evidence
     * const evidence = await prisma.evidence.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EvidenceFindUniqueArgs>(
      args: SelectSubset<T, EvidenceFindUniqueArgs<ExtArgs>>,
    ): Prisma__EvidenceClient<
      $Result.GetResult<
        Prisma.$EvidencePayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Evidence that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EvidenceFindUniqueOrThrowArgs} args - Arguments to find a Evidence
     * @example
     * // Get one Evidence
     * const evidence = await prisma.evidence.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EvidenceFindUniqueOrThrowArgs>(
      args: SelectSubset<T, EvidenceFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__EvidenceClient<
      $Result.GetResult<
        Prisma.$EvidencePayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Evidence that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvidenceFindFirstArgs} args - Arguments to find a Evidence
     * @example
     * // Get one Evidence
     * const evidence = await prisma.evidence.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EvidenceFindFirstArgs>(
      args?: SelectSubset<T, EvidenceFindFirstArgs<ExtArgs>>,
    ): Prisma__EvidenceClient<
      $Result.GetResult<
        Prisma.$EvidencePayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Evidence that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvidenceFindFirstOrThrowArgs} args - Arguments to find a Evidence
     * @example
     * // Get one Evidence
     * const evidence = await prisma.evidence.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EvidenceFindFirstOrThrowArgs>(
      args?: SelectSubset<T, EvidenceFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__EvidenceClient<
      $Result.GetResult<
        Prisma.$EvidencePayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Evidences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvidenceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Evidences
     * const evidences = await prisma.evidence.findMany()
     *
     * // Get first 10 Evidences
     * const evidences = await prisma.evidence.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const evidenceWithIdOnly = await prisma.evidence.findMany({ select: { id: true } })
     *
     */
    findMany<T extends EvidenceFindManyArgs>(
      args?: SelectSubset<T, EvidenceFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$EvidencePayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Evidence.
     * @param {EvidenceCreateArgs} args - Arguments to create a Evidence.
     * @example
     * // Create one Evidence
     * const Evidence = await prisma.evidence.create({
     *   data: {
     *     // ... data to create a Evidence
     *   }
     * })
     *
     */
    create<T extends EvidenceCreateArgs>(
      args: SelectSubset<T, EvidenceCreateArgs<ExtArgs>>,
    ): Prisma__EvidenceClient<
      $Result.GetResult<
        Prisma.$EvidencePayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Evidences.
     * @param {EvidenceCreateManyArgs} args - Arguments to create many Evidences.
     * @example
     * // Create many Evidences
     * const evidence = await prisma.evidence.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends EvidenceCreateManyArgs>(
      args?: SelectSubset<T, EvidenceCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a Evidence.
     * @param {EvidenceDeleteArgs} args - Arguments to delete one Evidence.
     * @example
     * // Delete one Evidence
     * const Evidence = await prisma.evidence.delete({
     *   where: {
     *     // ... filter to delete one Evidence
     *   }
     * })
     *
     */
    delete<T extends EvidenceDeleteArgs>(
      args: SelectSubset<T, EvidenceDeleteArgs<ExtArgs>>,
    ): Prisma__EvidenceClient<
      $Result.GetResult<
        Prisma.$EvidencePayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Evidence.
     * @param {EvidenceUpdateArgs} args - Arguments to update one Evidence.
     * @example
     * // Update one Evidence
     * const evidence = await prisma.evidence.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends EvidenceUpdateArgs>(
      args: SelectSubset<T, EvidenceUpdateArgs<ExtArgs>>,
    ): Prisma__EvidenceClient<
      $Result.GetResult<
        Prisma.$EvidencePayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Evidences.
     * @param {EvidenceDeleteManyArgs} args - Arguments to filter Evidences to delete.
     * @example
     * // Delete a few Evidences
     * const { count } = await prisma.evidence.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends EvidenceDeleteManyArgs>(
      args?: SelectSubset<T, EvidenceDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Evidences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvidenceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Evidences
     * const evidence = await prisma.evidence.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends EvidenceUpdateManyArgs>(
      args: SelectSubset<T, EvidenceUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one Evidence.
     * @param {EvidenceUpsertArgs} args - Arguments to update or create a Evidence.
     * @example
     * // Update or create a Evidence
     * const evidence = await prisma.evidence.upsert({
     *   create: {
     *     // ... data to create a Evidence
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Evidence we want to update
     *   }
     * })
     */
    upsert<T extends EvidenceUpsertArgs>(
      args: SelectSubset<T, EvidenceUpsertArgs<ExtArgs>>,
    ): Prisma__EvidenceClient<
      $Result.GetResult<
        Prisma.$EvidencePayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Evidences that matches the filter.
     * @param {EvidenceFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const evidence = await prisma.evidence.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: EvidenceFindRawArgs): Prisma.PrismaPromise<JsonObject>;

    /**
     * Perform aggregation operations on a Evidence.
     * @param {EvidenceAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const evidence = await prisma.evidence.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(
      args?: EvidenceAggregateRawArgs,
    ): Prisma.PrismaPromise<JsonObject>;

    /**
     * Count the number of Evidences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvidenceCountArgs} args - Arguments to filter Evidences to count.
     * @example
     * // Count the number of Evidences
     * const count = await prisma.evidence.count({
     *   where: {
     *     // ... the filter for the Evidences we want to count
     *   }
     * })
     **/
    count<T extends EvidenceCountArgs>(
      args?: Subset<T, EvidenceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], EvidenceCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Evidence.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvidenceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends EvidenceAggregateArgs>(
      args: Subset<T, EvidenceAggregateArgs>,
    ): Prisma.PrismaPromise<GetEvidenceAggregateType<T>>;

    /**
     * Group by Evidence.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvidenceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends EvidenceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EvidenceGroupByArgs["orderBy"] }
        : { orderBy?: EvidenceGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, EvidenceGroupByArgs, OrderByArg> &
        InputErrors,
    ): {} extends InputErrors
      ? GetEvidenceGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Evidence model
     */
    readonly fields: EvidenceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Evidence.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EvidenceClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    claim<T extends FactcheckClaimDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, FactcheckClaimDefaultArgs<ExtArgs>>,
    ): Prisma__FactcheckClaimClient<
      | $Result.GetResult<
          Prisma.$FactcheckClaimPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Evidence model
   */
  interface EvidenceFieldRefs {
    readonly id: FieldRef<"Evidence", "String">;
    readonly claimId: FieldRef<"Evidence", "String">;
    readonly url: FieldRef<"Evidence", "String">;
    readonly domain: FieldRef<"Evidence", "String">;
    readonly stance: FieldRef<"Evidence", "Stance">;
    readonly snapshotHash: FieldRef<"Evidence", "String">;
    readonly firstSeenAt: FieldRef<"Evidence", "DateTime">;
    readonly trustScore: FieldRef<"Evidence", "Int">;
  }

  // Custom InputTypes
  /**
   * Evidence findUnique
   */
  export type EvidenceFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Evidence
     */
    select?: EvidenceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Evidence
     */
    omit?: EvidenceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenceInclude<ExtArgs> | null;
    /**
     * Filter, which Evidence to fetch.
     */
    where: EvidenceWhereUniqueInput;
  };

  /**
   * Evidence findUniqueOrThrow
   */
  export type EvidenceFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Evidence
     */
    select?: EvidenceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Evidence
     */
    omit?: EvidenceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenceInclude<ExtArgs> | null;
    /**
     * Filter, which Evidence to fetch.
     */
    where: EvidenceWhereUniqueInput;
  };

  /**
   * Evidence findFirst
   */
  export type EvidenceFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Evidence
     */
    select?: EvidenceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Evidence
     */
    omit?: EvidenceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenceInclude<ExtArgs> | null;
    /**
     * Filter, which Evidence to fetch.
     */
    where?: EvidenceWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Evidences to fetch.
     */
    orderBy?:
      | EvidenceOrderByWithRelationInput
      | EvidenceOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Evidences.
     */
    cursor?: EvidenceWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Evidences from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Evidences.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Evidences.
     */
    distinct?: EvidenceScalarFieldEnum | EvidenceScalarFieldEnum[];
  };

  /**
   * Evidence findFirstOrThrow
   */
  export type EvidenceFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Evidence
     */
    select?: EvidenceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Evidence
     */
    omit?: EvidenceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenceInclude<ExtArgs> | null;
    /**
     * Filter, which Evidence to fetch.
     */
    where?: EvidenceWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Evidences to fetch.
     */
    orderBy?:
      | EvidenceOrderByWithRelationInput
      | EvidenceOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Evidences.
     */
    cursor?: EvidenceWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Evidences from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Evidences.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Evidences.
     */
    distinct?: EvidenceScalarFieldEnum | EvidenceScalarFieldEnum[];
  };

  /**
   * Evidence findMany
   */
  export type EvidenceFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Evidence
     */
    select?: EvidenceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Evidence
     */
    omit?: EvidenceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenceInclude<ExtArgs> | null;
    /**
     * Filter, which Evidences to fetch.
     */
    where?: EvidenceWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Evidences to fetch.
     */
    orderBy?:
      | EvidenceOrderByWithRelationInput
      | EvidenceOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Evidences.
     */
    cursor?: EvidenceWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Evidences from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Evidences.
     */
    skip?: number;
    distinct?: EvidenceScalarFieldEnum | EvidenceScalarFieldEnum[];
  };

  /**
   * Evidence create
   */
  export type EvidenceCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Evidence
     */
    select?: EvidenceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Evidence
     */
    omit?: EvidenceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenceInclude<ExtArgs> | null;
    /**
     * The data needed to create a Evidence.
     */
    data: XOR<EvidenceCreateInput, EvidenceUncheckedCreateInput>;
  };

  /**
   * Evidence createMany
   */
  export type EvidenceCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Evidences.
     */
    data: EvidenceCreateManyInput | EvidenceCreateManyInput[];
  };

  /**
   * Evidence update
   */
  export type EvidenceUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Evidence
     */
    select?: EvidenceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Evidence
     */
    omit?: EvidenceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenceInclude<ExtArgs> | null;
    /**
     * The data needed to update a Evidence.
     */
    data: XOR<EvidenceUpdateInput, EvidenceUncheckedUpdateInput>;
    /**
     * Choose, which Evidence to update.
     */
    where: EvidenceWhereUniqueInput;
  };

  /**
   * Evidence updateMany
   */
  export type EvidenceUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Evidences.
     */
    data: XOR<
      EvidenceUpdateManyMutationInput,
      EvidenceUncheckedUpdateManyInput
    >;
    /**
     * Filter which Evidences to update
     */
    where?: EvidenceWhereInput;
    /**
     * Limit how many Evidences to update.
     */
    limit?: number;
  };

  /**
   * Evidence upsert
   */
  export type EvidenceUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Evidence
     */
    select?: EvidenceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Evidence
     */
    omit?: EvidenceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenceInclude<ExtArgs> | null;
    /**
     * The filter to search for the Evidence to update in case it exists.
     */
    where: EvidenceWhereUniqueInput;
    /**
     * In case the Evidence found by the `where` argument doesn't exist, create a new Evidence with this data.
     */
    create: XOR<EvidenceCreateInput, EvidenceUncheckedCreateInput>;
    /**
     * In case the Evidence was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EvidenceUpdateInput, EvidenceUncheckedUpdateInput>;
  };

  /**
   * Evidence delete
   */
  export type EvidenceDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Evidence
     */
    select?: EvidenceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Evidence
     */
    omit?: EvidenceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenceInclude<ExtArgs> | null;
    /**
     * Filter which Evidence to delete.
     */
    where: EvidenceWhereUniqueInput;
  };

  /**
   * Evidence deleteMany
   */
  export type EvidenceDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Evidences to delete
     */
    where?: EvidenceWhereInput;
    /**
     * Limit how many Evidences to delete.
     */
    limit?: number;
  };

  /**
   * Evidence findRaw
   */
  export type EvidenceFindRawArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue;
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue;
  };

  /**
   * Evidence aggregateRaw
   */
  export type EvidenceAggregateRawArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[];
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue;
  };

  /**
   * Evidence without action
   */
  export type EvidenceDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Evidence
     */
    select?: EvidenceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Evidence
     */
    omit?: EvidenceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenceInclude<ExtArgs> | null;
  };

  /**
   * Model VerdictVersion
   */

  export type AggregateVerdictVersion = {
    _count: VerdictVersionCountAggregateOutputType | null;
    _avg: VerdictVersionAvgAggregateOutputType | null;
    _sum: VerdictVersionSumAggregateOutputType | null;
    _min: VerdictVersionMinAggregateOutputType | null;
    _max: VerdictVersionMaxAggregateOutputType | null;
  };

  export type VerdictVersionAvgAggregateOutputType = {
    confidence: number | null;
  };

  export type VerdictVersionSumAggregateOutputType = {
    confidence: number | null;
  };

  export type VerdictVersionMinAggregateOutputType = {
    id: string | null;
    claimId: string | null;
    verdict: string | null;
    confidence: number | null;
    asOf: Date | null;
    supersedes: string | null;
  };

  export type VerdictVersionMaxAggregateOutputType = {
    id: string | null;
    claimId: string | null;
    verdict: string | null;
    confidence: number | null;
    asOf: Date | null;
    supersedes: string | null;
  };

  export type VerdictVersionCountAggregateOutputType = {
    id: number;
    claimId: number;
    verdict: number;
    confidence: number;
    asOf: number;
    supersedes: number;
    _all: number;
  };

  export type VerdictVersionAvgAggregateInputType = {
    confidence?: true;
  };

  export type VerdictVersionSumAggregateInputType = {
    confidence?: true;
  };

  export type VerdictVersionMinAggregateInputType = {
    id?: true;
    claimId?: true;
    verdict?: true;
    confidence?: true;
    asOf?: true;
    supersedes?: true;
  };

  export type VerdictVersionMaxAggregateInputType = {
    id?: true;
    claimId?: true;
    verdict?: true;
    confidence?: true;
    asOf?: true;
    supersedes?: true;
  };

  export type VerdictVersionCountAggregateInputType = {
    id?: true;
    claimId?: true;
    verdict?: true;
    confidence?: true;
    asOf?: true;
    supersedes?: true;
    _all?: true;
  };

  export type VerdictVersionAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which VerdictVersion to aggregate.
     */
    where?: VerdictVersionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of VerdictVersions to fetch.
     */
    orderBy?:
      | VerdictVersionOrderByWithRelationInput
      | VerdictVersionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: VerdictVersionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` VerdictVersions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` VerdictVersions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned VerdictVersions
     **/
    _count?: true | VerdictVersionCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: VerdictVersionAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: VerdictVersionSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: VerdictVersionMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: VerdictVersionMaxAggregateInputType;
  };

  export type GetVerdictVersionAggregateType<
    T extends VerdictVersionAggregateArgs,
  > = {
    [P in keyof T & keyof AggregateVerdictVersion]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerdictVersion[P]>
      : GetScalarType<T[P], AggregateVerdictVersion[P]>;
  };

  export type VerdictVersionGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: VerdictVersionWhereInput;
    orderBy?:
      | VerdictVersionOrderByWithAggregationInput
      | VerdictVersionOrderByWithAggregationInput[];
    by: VerdictVersionScalarFieldEnum[] | VerdictVersionScalarFieldEnum;
    having?: VerdictVersionScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: VerdictVersionCountAggregateInputType | true;
    _avg?: VerdictVersionAvgAggregateInputType;
    _sum?: VerdictVersionSumAggregateInputType;
    _min?: VerdictVersionMinAggregateInputType;
    _max?: VerdictVersionMaxAggregateInputType;
  };

  export type VerdictVersionGroupByOutputType = {
    id: string;
    claimId: string;
    verdict: string;
    confidence: number;
    asOf: Date;
    supersedes: string | null;
    _count: VerdictVersionCountAggregateOutputType | null;
    _avg: VerdictVersionAvgAggregateOutputType | null;
    _sum: VerdictVersionSumAggregateOutputType | null;
    _min: VerdictVersionMinAggregateOutputType | null;
    _max: VerdictVersionMaxAggregateOutputType | null;
  };

  type GetVerdictVersionGroupByPayload<T extends VerdictVersionGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<VerdictVersionGroupByOutputType, T["by"]> & {
          [P in keyof T &
            keyof VerdictVersionGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerdictVersionGroupByOutputType[P]>
            : GetScalarType<T[P], VerdictVersionGroupByOutputType[P]>;
        }
      >
    >;

  export type VerdictVersionSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      claimId?: boolean;
      verdict?: boolean;
      confidence?: boolean;
      asOf?: boolean;
      supersedes?: boolean;
      claim?: boolean | FactcheckClaimDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["verdictVersion"]
  >;

  export type VerdictVersionSelectScalar = {
    id?: boolean;
    claimId?: boolean;
    verdict?: boolean;
    confidence?: boolean;
    asOf?: boolean;
    supersedes?: boolean;
  };

  export type VerdictVersionOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    "id" | "claimId" | "verdict" | "confidence" | "asOf" | "supersedes",
    ExtArgs["result"]["verdictVersion"]
  >;
  export type VerdictVersionInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    claim?: boolean | FactcheckClaimDefaultArgs<ExtArgs>;
  };

  export type $VerdictVersionPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "VerdictVersion";
    objects: {
      claim: Prisma.$FactcheckClaimPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        claimId: string;
        verdict: string;
        confidence: number;
        asOf: Date;
        supersedes: string | null;
      },
      ExtArgs["result"]["verdictVersion"]
    >;
    composites: {};
  };

  type VerdictVersionGetPayload<
    S extends boolean | null | undefined | VerdictVersionDefaultArgs,
  > = $Result.GetResult<Prisma.$VerdictVersionPayload, S>;

  type VerdictVersionCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    VerdictVersionFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: VerdictVersionCountAggregateInputType | true;
  };

  export interface VerdictVersionDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["VerdictVersion"];
      meta: { name: "VerdictVersion" };
    };
    /**
     * Find zero or one VerdictVersion that matches the filter.
     * @param {VerdictVersionFindUniqueArgs} args - Arguments to find a VerdictVersion
     * @example
     * // Get one VerdictVersion
     * const verdictVersion = await prisma.verdictVersion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerdictVersionFindUniqueArgs>(
      args: SelectSubset<T, VerdictVersionFindUniqueArgs<ExtArgs>>,
    ): Prisma__VerdictVersionClient<
      $Result.GetResult<
        Prisma.$VerdictVersionPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one VerdictVersion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VerdictVersionFindUniqueOrThrowArgs} args - Arguments to find a VerdictVersion
     * @example
     * // Get one VerdictVersion
     * const verdictVersion = await prisma.verdictVersion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerdictVersionFindUniqueOrThrowArgs>(
      args: SelectSubset<T, VerdictVersionFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__VerdictVersionClient<
      $Result.GetResult<
        Prisma.$VerdictVersionPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first VerdictVersion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictVersionFindFirstArgs} args - Arguments to find a VerdictVersion
     * @example
     * // Get one VerdictVersion
     * const verdictVersion = await prisma.verdictVersion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerdictVersionFindFirstArgs>(
      args?: SelectSubset<T, VerdictVersionFindFirstArgs<ExtArgs>>,
    ): Prisma__VerdictVersionClient<
      $Result.GetResult<
        Prisma.$VerdictVersionPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first VerdictVersion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictVersionFindFirstOrThrowArgs} args - Arguments to find a VerdictVersion
     * @example
     * // Get one VerdictVersion
     * const verdictVersion = await prisma.verdictVersion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerdictVersionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, VerdictVersionFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__VerdictVersionClient<
      $Result.GetResult<
        Prisma.$VerdictVersionPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more VerdictVersions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictVersionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VerdictVersions
     * const verdictVersions = await prisma.verdictVersion.findMany()
     *
     * // Get first 10 VerdictVersions
     * const verdictVersions = await prisma.verdictVersion.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const verdictVersionWithIdOnly = await prisma.verdictVersion.findMany({ select: { id: true } })
     *
     */
    findMany<T extends VerdictVersionFindManyArgs>(
      args?: SelectSubset<T, VerdictVersionFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$VerdictVersionPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a VerdictVersion.
     * @param {VerdictVersionCreateArgs} args - Arguments to create a VerdictVersion.
     * @example
     * // Create one VerdictVersion
     * const VerdictVersion = await prisma.verdictVersion.create({
     *   data: {
     *     // ... data to create a VerdictVersion
     *   }
     * })
     *
     */
    create<T extends VerdictVersionCreateArgs>(
      args: SelectSubset<T, VerdictVersionCreateArgs<ExtArgs>>,
    ): Prisma__VerdictVersionClient<
      $Result.GetResult<
        Prisma.$VerdictVersionPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many VerdictVersions.
     * @param {VerdictVersionCreateManyArgs} args - Arguments to create many VerdictVersions.
     * @example
     * // Create many VerdictVersions
     * const verdictVersion = await prisma.verdictVersion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends VerdictVersionCreateManyArgs>(
      args?: SelectSubset<T, VerdictVersionCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a VerdictVersion.
     * @param {VerdictVersionDeleteArgs} args - Arguments to delete one VerdictVersion.
     * @example
     * // Delete one VerdictVersion
     * const VerdictVersion = await prisma.verdictVersion.delete({
     *   where: {
     *     // ... filter to delete one VerdictVersion
     *   }
     * })
     *
     */
    delete<T extends VerdictVersionDeleteArgs>(
      args: SelectSubset<T, VerdictVersionDeleteArgs<ExtArgs>>,
    ): Prisma__VerdictVersionClient<
      $Result.GetResult<
        Prisma.$VerdictVersionPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one VerdictVersion.
     * @param {VerdictVersionUpdateArgs} args - Arguments to update one VerdictVersion.
     * @example
     * // Update one VerdictVersion
     * const verdictVersion = await prisma.verdictVersion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends VerdictVersionUpdateArgs>(
      args: SelectSubset<T, VerdictVersionUpdateArgs<ExtArgs>>,
    ): Prisma__VerdictVersionClient<
      $Result.GetResult<
        Prisma.$VerdictVersionPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more VerdictVersions.
     * @param {VerdictVersionDeleteManyArgs} args - Arguments to filter VerdictVersions to delete.
     * @example
     * // Delete a few VerdictVersions
     * const { count } = await prisma.verdictVersion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends VerdictVersionDeleteManyArgs>(
      args?: SelectSubset<T, VerdictVersionDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more VerdictVersions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictVersionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VerdictVersions
     * const verdictVersion = await prisma.verdictVersion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends VerdictVersionUpdateManyArgs>(
      args: SelectSubset<T, VerdictVersionUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one VerdictVersion.
     * @param {VerdictVersionUpsertArgs} args - Arguments to update or create a VerdictVersion.
     * @example
     * // Update or create a VerdictVersion
     * const verdictVersion = await prisma.verdictVersion.upsert({
     *   create: {
     *     // ... data to create a VerdictVersion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VerdictVersion we want to update
     *   }
     * })
     */
    upsert<T extends VerdictVersionUpsertArgs>(
      args: SelectSubset<T, VerdictVersionUpsertArgs<ExtArgs>>,
    ): Prisma__VerdictVersionClient<
      $Result.GetResult<
        Prisma.$VerdictVersionPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more VerdictVersions that matches the filter.
     * @param {VerdictVersionFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const verdictVersion = await prisma.verdictVersion.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: VerdictVersionFindRawArgs): Prisma.PrismaPromise<JsonObject>;

    /**
     * Perform aggregation operations on a VerdictVersion.
     * @param {VerdictVersionAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const verdictVersion = await prisma.verdictVersion.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(
      args?: VerdictVersionAggregateRawArgs,
    ): Prisma.PrismaPromise<JsonObject>;

    /**
     * Count the number of VerdictVersions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictVersionCountArgs} args - Arguments to filter VerdictVersions to count.
     * @example
     * // Count the number of VerdictVersions
     * const count = await prisma.verdictVersion.count({
     *   where: {
     *     // ... the filter for the VerdictVersions we want to count
     *   }
     * })
     **/
    count<T extends VerdictVersionCountArgs>(
      args?: Subset<T, VerdictVersionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], VerdictVersionCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a VerdictVersion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictVersionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends VerdictVersionAggregateArgs>(
      args: Subset<T, VerdictVersionAggregateArgs>,
    ): Prisma.PrismaPromise<GetVerdictVersionAggregateType<T>>;

    /**
     * Group by VerdictVersion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictVersionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends VerdictVersionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerdictVersionGroupByArgs["orderBy"] }
        : { orderBy?: VerdictVersionGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, VerdictVersionGroupByArgs, OrderByArg> &
        InputErrors,
    ): {} extends InputErrors
      ? GetVerdictVersionGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the VerdictVersion model
     */
    readonly fields: VerdictVersionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VerdictVersion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerdictVersionClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    claim<T extends FactcheckClaimDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, FactcheckClaimDefaultArgs<ExtArgs>>,
    ): Prisma__FactcheckClaimClient<
      | $Result.GetResult<
          Prisma.$FactcheckClaimPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the VerdictVersion model
   */
  interface VerdictVersionFieldRefs {
    readonly id: FieldRef<"VerdictVersion", "String">;
    readonly claimId: FieldRef<"VerdictVersion", "String">;
    readonly verdict: FieldRef<"VerdictVersion", "String">;
    readonly confidence: FieldRef<"VerdictVersion", "Float">;
    readonly asOf: FieldRef<"VerdictVersion", "DateTime">;
    readonly supersedes: FieldRef<"VerdictVersion", "String">;
  }

  // Custom InputTypes
  /**
   * VerdictVersion findUnique
   */
  export type VerdictVersionFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the VerdictVersion
     */
    select?: VerdictVersionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the VerdictVersion
     */
    omit?: VerdictVersionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictVersionInclude<ExtArgs> | null;
    /**
     * Filter, which VerdictVersion to fetch.
     */
    where: VerdictVersionWhereUniqueInput;
  };

  /**
   * VerdictVersion findUniqueOrThrow
   */
  export type VerdictVersionFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the VerdictVersion
     */
    select?: VerdictVersionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the VerdictVersion
     */
    omit?: VerdictVersionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictVersionInclude<ExtArgs> | null;
    /**
     * Filter, which VerdictVersion to fetch.
     */
    where: VerdictVersionWhereUniqueInput;
  };

  /**
   * VerdictVersion findFirst
   */
  export type VerdictVersionFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the VerdictVersion
     */
    select?: VerdictVersionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the VerdictVersion
     */
    omit?: VerdictVersionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictVersionInclude<ExtArgs> | null;
    /**
     * Filter, which VerdictVersion to fetch.
     */
    where?: VerdictVersionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of VerdictVersions to fetch.
     */
    orderBy?:
      | VerdictVersionOrderByWithRelationInput
      | VerdictVersionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for VerdictVersions.
     */
    cursor?: VerdictVersionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` VerdictVersions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` VerdictVersions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of VerdictVersions.
     */
    distinct?: VerdictVersionScalarFieldEnum | VerdictVersionScalarFieldEnum[];
  };

  /**
   * VerdictVersion findFirstOrThrow
   */
  export type VerdictVersionFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the VerdictVersion
     */
    select?: VerdictVersionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the VerdictVersion
     */
    omit?: VerdictVersionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictVersionInclude<ExtArgs> | null;
    /**
     * Filter, which VerdictVersion to fetch.
     */
    where?: VerdictVersionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of VerdictVersions to fetch.
     */
    orderBy?:
      | VerdictVersionOrderByWithRelationInput
      | VerdictVersionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for VerdictVersions.
     */
    cursor?: VerdictVersionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` VerdictVersions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` VerdictVersions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of VerdictVersions.
     */
    distinct?: VerdictVersionScalarFieldEnum | VerdictVersionScalarFieldEnum[];
  };

  /**
   * VerdictVersion findMany
   */
  export type VerdictVersionFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the VerdictVersion
     */
    select?: VerdictVersionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the VerdictVersion
     */
    omit?: VerdictVersionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictVersionInclude<ExtArgs> | null;
    /**
     * Filter, which VerdictVersions to fetch.
     */
    where?: VerdictVersionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of VerdictVersions to fetch.
     */
    orderBy?:
      | VerdictVersionOrderByWithRelationInput
      | VerdictVersionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing VerdictVersions.
     */
    cursor?: VerdictVersionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` VerdictVersions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` VerdictVersions.
     */
    skip?: number;
    distinct?: VerdictVersionScalarFieldEnum | VerdictVersionScalarFieldEnum[];
  };

  /**
   * VerdictVersion create
   */
  export type VerdictVersionCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the VerdictVersion
     */
    select?: VerdictVersionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the VerdictVersion
     */
    omit?: VerdictVersionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictVersionInclude<ExtArgs> | null;
    /**
     * The data needed to create a VerdictVersion.
     */
    data: XOR<VerdictVersionCreateInput, VerdictVersionUncheckedCreateInput>;
  };

  /**
   * VerdictVersion createMany
   */
  export type VerdictVersionCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many VerdictVersions.
     */
    data: VerdictVersionCreateManyInput | VerdictVersionCreateManyInput[];
  };

  /**
   * VerdictVersion update
   */
  export type VerdictVersionUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the VerdictVersion
     */
    select?: VerdictVersionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the VerdictVersion
     */
    omit?: VerdictVersionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictVersionInclude<ExtArgs> | null;
    /**
     * The data needed to update a VerdictVersion.
     */
    data: XOR<VerdictVersionUpdateInput, VerdictVersionUncheckedUpdateInput>;
    /**
     * Choose, which VerdictVersion to update.
     */
    where: VerdictVersionWhereUniqueInput;
  };

  /**
   * VerdictVersion updateMany
   */
  export type VerdictVersionUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update VerdictVersions.
     */
    data: XOR<
      VerdictVersionUpdateManyMutationInput,
      VerdictVersionUncheckedUpdateManyInput
    >;
    /**
     * Filter which VerdictVersions to update
     */
    where?: VerdictVersionWhereInput;
    /**
     * Limit how many VerdictVersions to update.
     */
    limit?: number;
  };

  /**
   * VerdictVersion upsert
   */
  export type VerdictVersionUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the VerdictVersion
     */
    select?: VerdictVersionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the VerdictVersion
     */
    omit?: VerdictVersionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictVersionInclude<ExtArgs> | null;
    /**
     * The filter to search for the VerdictVersion to update in case it exists.
     */
    where: VerdictVersionWhereUniqueInput;
    /**
     * In case the VerdictVersion found by the `where` argument doesn't exist, create a new VerdictVersion with this data.
     */
    create: XOR<VerdictVersionCreateInput, VerdictVersionUncheckedCreateInput>;
    /**
     * In case the VerdictVersion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerdictVersionUpdateInput, VerdictVersionUncheckedUpdateInput>;
  };

  /**
   * VerdictVersion delete
   */
  export type VerdictVersionDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the VerdictVersion
     */
    select?: VerdictVersionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the VerdictVersion
     */
    omit?: VerdictVersionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictVersionInclude<ExtArgs> | null;
    /**
     * Filter which VerdictVersion to delete.
     */
    where: VerdictVersionWhereUniqueInput;
  };

  /**
   * VerdictVersion deleteMany
   */
  export type VerdictVersionDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which VerdictVersions to delete
     */
    where?: VerdictVersionWhereInput;
    /**
     * Limit how many VerdictVersions to delete.
     */
    limit?: number;
  };

  /**
   * VerdictVersion findRaw
   */
  export type VerdictVersionFindRawArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue;
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue;
  };

  /**
   * VerdictVersion aggregateRaw
   */
  export type VerdictVersionAggregateRawArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[];
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue;
  };

  /**
   * VerdictVersion without action
   */
  export type VerdictVersionDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the VerdictVersion
     */
    select?: VerdictVersionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the VerdictVersion
     */
    omit?: VerdictVersionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictVersionInclude<ExtArgs> | null;
  };

  /**
   * Model FactcheckResult
   */

  export type AggregateFactcheckResult = {
    _count: FactcheckResultCountAggregateOutputType | null;
    _min: FactcheckResultMinAggregateOutputType | null;
    _max: FactcheckResultMaxAggregateOutputType | null;
  };

  export type FactcheckResultMinAggregateOutputType = {
    id: string | null;
    jobId: string | null;
    verdict: string | null;
    createdAt: Date | null;
  };

  export type FactcheckResultMaxAggregateOutputType = {
    id: string | null;
    jobId: string | null;
    verdict: string | null;
    createdAt: Date | null;
  };

  export type FactcheckResultCountAggregateOutputType = {
    id: number;
    jobId: number;
    verdict: number;
    rawOutput: number;
    createdAt: number;
    _all: number;
  };

  export type FactcheckResultMinAggregateInputType = {
    id?: true;
    jobId?: true;
    verdict?: true;
    createdAt?: true;
  };

  export type FactcheckResultMaxAggregateInputType = {
    id?: true;
    jobId?: true;
    verdict?: true;
    createdAt?: true;
  };

  export type FactcheckResultCountAggregateInputType = {
    id?: true;
    jobId?: true;
    verdict?: true;
    rawOutput?: true;
    createdAt?: true;
    _all?: true;
  };

  export type FactcheckResultAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which FactcheckResult to aggregate.
     */
    where?: FactcheckResultWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of FactcheckResults to fetch.
     */
    orderBy?:
      | FactcheckResultOrderByWithRelationInput
      | FactcheckResultOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: FactcheckResultWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` FactcheckResults from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` FactcheckResults.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned FactcheckResults
     **/
    _count?: true | FactcheckResultCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: FactcheckResultMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: FactcheckResultMaxAggregateInputType;
  };

  export type GetFactcheckResultAggregateType<
    T extends FactcheckResultAggregateArgs,
  > = {
    [P in keyof T & keyof AggregateFactcheckResult]: P extends
      | "_count"
      | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFactcheckResult[P]>
      : GetScalarType<T[P], AggregateFactcheckResult[P]>;
  };

  export type FactcheckResultGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: FactcheckResultWhereInput;
    orderBy?:
      | FactcheckResultOrderByWithAggregationInput
      | FactcheckResultOrderByWithAggregationInput[];
    by: FactcheckResultScalarFieldEnum[] | FactcheckResultScalarFieldEnum;
    having?: FactcheckResultScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: FactcheckResultCountAggregateInputType | true;
    _min?: FactcheckResultMinAggregateInputType;
    _max?: FactcheckResultMaxAggregateInputType;
  };

  export type FactcheckResultGroupByOutputType = {
    id: string;
    jobId: string;
    verdict: string;
    rawOutput: JsonValue;
    createdAt: Date;
    _count: FactcheckResultCountAggregateOutputType | null;
    _min: FactcheckResultMinAggregateOutputType | null;
    _max: FactcheckResultMaxAggregateOutputType | null;
  };

  type GetFactcheckResultGroupByPayload<T extends FactcheckResultGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<FactcheckResultGroupByOutputType, T["by"]> & {
          [P in keyof T &
            keyof FactcheckResultGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FactcheckResultGroupByOutputType[P]>
            : GetScalarType<T[P], FactcheckResultGroupByOutputType[P]>;
        }
      >
    >;

  export type FactcheckResultSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      jobId?: boolean;
      verdict?: boolean;
      rawOutput?: boolean;
      createdAt?: boolean;
      job?: boolean | FactcheckJobDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["factcheckResult"]
  >;

  export type FactcheckResultSelectScalar = {
    id?: boolean;
    jobId?: boolean;
    verdict?: boolean;
    rawOutput?: boolean;
    createdAt?: boolean;
  };

  export type FactcheckResultOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    "id" | "jobId" | "verdict" | "rawOutput" | "createdAt",
    ExtArgs["result"]["factcheckResult"]
  >;
  export type FactcheckResultInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    job?: boolean | FactcheckJobDefaultArgs<ExtArgs>;
  };

  export type $FactcheckResultPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "FactcheckResult";
    objects: {
      job: Prisma.$FactcheckJobPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        jobId: string;
        verdict: string;
        rawOutput: Prisma.JsonValue;
        createdAt: Date;
      },
      ExtArgs["result"]["factcheckResult"]
    >;
    composites: {};
  };

  type FactcheckResultGetPayload<
    S extends boolean | null | undefined | FactcheckResultDefaultArgs,
  > = $Result.GetResult<Prisma.$FactcheckResultPayload, S>;

  type FactcheckResultCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    FactcheckResultFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: FactcheckResultCountAggregateInputType | true;
  };

  export interface FactcheckResultDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["FactcheckResult"];
      meta: { name: "FactcheckResult" };
    };
    /**
     * Find zero or one FactcheckResult that matches the filter.
     * @param {FactcheckResultFindUniqueArgs} args - Arguments to find a FactcheckResult
     * @example
     * // Get one FactcheckResult
     * const factcheckResult = await prisma.factcheckResult.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FactcheckResultFindUniqueArgs>(
      args: SelectSubset<T, FactcheckResultFindUniqueArgs<ExtArgs>>,
    ): Prisma__FactcheckResultClient<
      $Result.GetResult<
        Prisma.$FactcheckResultPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one FactcheckResult that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FactcheckResultFindUniqueOrThrowArgs} args - Arguments to find a FactcheckResult
     * @example
     * // Get one FactcheckResult
     * const factcheckResult = await prisma.factcheckResult.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FactcheckResultFindUniqueOrThrowArgs>(
      args: SelectSubset<T, FactcheckResultFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__FactcheckResultClient<
      $Result.GetResult<
        Prisma.$FactcheckResultPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first FactcheckResult that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactcheckResultFindFirstArgs} args - Arguments to find a FactcheckResult
     * @example
     * // Get one FactcheckResult
     * const factcheckResult = await prisma.factcheckResult.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FactcheckResultFindFirstArgs>(
      args?: SelectSubset<T, FactcheckResultFindFirstArgs<ExtArgs>>,
    ): Prisma__FactcheckResultClient<
      $Result.GetResult<
        Prisma.$FactcheckResultPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first FactcheckResult that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactcheckResultFindFirstOrThrowArgs} args - Arguments to find a FactcheckResult
     * @example
     * // Get one FactcheckResult
     * const factcheckResult = await prisma.factcheckResult.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FactcheckResultFindFirstOrThrowArgs>(
      args?: SelectSubset<T, FactcheckResultFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__FactcheckResultClient<
      $Result.GetResult<
        Prisma.$FactcheckResultPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more FactcheckResults that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactcheckResultFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FactcheckResults
     * const factcheckResults = await prisma.factcheckResult.findMany()
     *
     * // Get first 10 FactcheckResults
     * const factcheckResults = await prisma.factcheckResult.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const factcheckResultWithIdOnly = await prisma.factcheckResult.findMany({ select: { id: true } })
     *
     */
    findMany<T extends FactcheckResultFindManyArgs>(
      args?: SelectSubset<T, FactcheckResultFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$FactcheckResultPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a FactcheckResult.
     * @param {FactcheckResultCreateArgs} args - Arguments to create a FactcheckResult.
     * @example
     * // Create one FactcheckResult
     * const FactcheckResult = await prisma.factcheckResult.create({
     *   data: {
     *     // ... data to create a FactcheckResult
     *   }
     * })
     *
     */
    create<T extends FactcheckResultCreateArgs>(
      args: SelectSubset<T, FactcheckResultCreateArgs<ExtArgs>>,
    ): Prisma__FactcheckResultClient<
      $Result.GetResult<
        Prisma.$FactcheckResultPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many FactcheckResults.
     * @param {FactcheckResultCreateManyArgs} args - Arguments to create many FactcheckResults.
     * @example
     * // Create many FactcheckResults
     * const factcheckResult = await prisma.factcheckResult.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends FactcheckResultCreateManyArgs>(
      args?: SelectSubset<T, FactcheckResultCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a FactcheckResult.
     * @param {FactcheckResultDeleteArgs} args - Arguments to delete one FactcheckResult.
     * @example
     * // Delete one FactcheckResult
     * const FactcheckResult = await prisma.factcheckResult.delete({
     *   where: {
     *     // ... filter to delete one FactcheckResult
     *   }
     * })
     *
     */
    delete<T extends FactcheckResultDeleteArgs>(
      args: SelectSubset<T, FactcheckResultDeleteArgs<ExtArgs>>,
    ): Prisma__FactcheckResultClient<
      $Result.GetResult<
        Prisma.$FactcheckResultPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one FactcheckResult.
     * @param {FactcheckResultUpdateArgs} args - Arguments to update one FactcheckResult.
     * @example
     * // Update one FactcheckResult
     * const factcheckResult = await prisma.factcheckResult.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends FactcheckResultUpdateArgs>(
      args: SelectSubset<T, FactcheckResultUpdateArgs<ExtArgs>>,
    ): Prisma__FactcheckResultClient<
      $Result.GetResult<
        Prisma.$FactcheckResultPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more FactcheckResults.
     * @param {FactcheckResultDeleteManyArgs} args - Arguments to filter FactcheckResults to delete.
     * @example
     * // Delete a few FactcheckResults
     * const { count } = await prisma.factcheckResult.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends FactcheckResultDeleteManyArgs>(
      args?: SelectSubset<T, FactcheckResultDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more FactcheckResults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactcheckResultUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FactcheckResults
     * const factcheckResult = await prisma.factcheckResult.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends FactcheckResultUpdateManyArgs>(
      args: SelectSubset<T, FactcheckResultUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one FactcheckResult.
     * @param {FactcheckResultUpsertArgs} args - Arguments to update or create a FactcheckResult.
     * @example
     * // Update or create a FactcheckResult
     * const factcheckResult = await prisma.factcheckResult.upsert({
     *   create: {
     *     // ... data to create a FactcheckResult
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FactcheckResult we want to update
     *   }
     * })
     */
    upsert<T extends FactcheckResultUpsertArgs>(
      args: SelectSubset<T, FactcheckResultUpsertArgs<ExtArgs>>,
    ): Prisma__FactcheckResultClient<
      $Result.GetResult<
        Prisma.$FactcheckResultPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more FactcheckResults that matches the filter.
     * @param {FactcheckResultFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const factcheckResult = await prisma.factcheckResult.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(
      args?: FactcheckResultFindRawArgs,
    ): Prisma.PrismaPromise<JsonObject>;

    /**
     * Perform aggregation operations on a FactcheckResult.
     * @param {FactcheckResultAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const factcheckResult = await prisma.factcheckResult.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(
      args?: FactcheckResultAggregateRawArgs,
    ): Prisma.PrismaPromise<JsonObject>;

    /**
     * Count the number of FactcheckResults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactcheckResultCountArgs} args - Arguments to filter FactcheckResults to count.
     * @example
     * // Count the number of FactcheckResults
     * const count = await prisma.factcheckResult.count({
     *   where: {
     *     // ... the filter for the FactcheckResults we want to count
     *   }
     * })
     **/
    count<T extends FactcheckResultCountArgs>(
      args?: Subset<T, FactcheckResultCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], FactcheckResultCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a FactcheckResult.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactcheckResultAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends FactcheckResultAggregateArgs>(
      args: Subset<T, FactcheckResultAggregateArgs>,
    ): Prisma.PrismaPromise<GetFactcheckResultAggregateType<T>>;

    /**
     * Group by FactcheckResult.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactcheckResultGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends FactcheckResultGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FactcheckResultGroupByArgs["orderBy"] }
        : { orderBy?: FactcheckResultGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, FactcheckResultGroupByArgs, OrderByArg> &
        InputErrors,
    ): {} extends InputErrors
      ? GetFactcheckResultGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the FactcheckResult model
     */
    readonly fields: FactcheckResultFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FactcheckResult.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FactcheckResultClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    job<T extends FactcheckJobDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, FactcheckJobDefaultArgs<ExtArgs>>,
    ): Prisma__FactcheckJobClient<
      | $Result.GetResult<
          Prisma.$FactcheckJobPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the FactcheckResult model
   */
  interface FactcheckResultFieldRefs {
    readonly id: FieldRef<"FactcheckResult", "String">;
    readonly jobId: FieldRef<"FactcheckResult", "String">;
    readonly verdict: FieldRef<"FactcheckResult", "String">;
    readonly rawOutput: FieldRef<"FactcheckResult", "Json">;
    readonly createdAt: FieldRef<"FactcheckResult", "DateTime">;
  }

  // Custom InputTypes
  /**
   * FactcheckResult findUnique
   */
  export type FactcheckResultFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactcheckResult
     */
    select?: FactcheckResultSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FactcheckResult
     */
    omit?: FactcheckResultOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactcheckResultInclude<ExtArgs> | null;
    /**
     * Filter, which FactcheckResult to fetch.
     */
    where: FactcheckResultWhereUniqueInput;
  };

  /**
   * FactcheckResult findUniqueOrThrow
   */
  export type FactcheckResultFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactcheckResult
     */
    select?: FactcheckResultSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FactcheckResult
     */
    omit?: FactcheckResultOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactcheckResultInclude<ExtArgs> | null;
    /**
     * Filter, which FactcheckResult to fetch.
     */
    where: FactcheckResultWhereUniqueInput;
  };

  /**
   * FactcheckResult findFirst
   */
  export type FactcheckResultFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactcheckResult
     */
    select?: FactcheckResultSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FactcheckResult
     */
    omit?: FactcheckResultOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactcheckResultInclude<ExtArgs> | null;
    /**
     * Filter, which FactcheckResult to fetch.
     */
    where?: FactcheckResultWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of FactcheckResults to fetch.
     */
    orderBy?:
      | FactcheckResultOrderByWithRelationInput
      | FactcheckResultOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for FactcheckResults.
     */
    cursor?: FactcheckResultWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` FactcheckResults from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` FactcheckResults.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of FactcheckResults.
     */
    distinct?:
      | FactcheckResultScalarFieldEnum
      | FactcheckResultScalarFieldEnum[];
  };

  /**
   * FactcheckResult findFirstOrThrow
   */
  export type FactcheckResultFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactcheckResult
     */
    select?: FactcheckResultSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FactcheckResult
     */
    omit?: FactcheckResultOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactcheckResultInclude<ExtArgs> | null;
    /**
     * Filter, which FactcheckResult to fetch.
     */
    where?: FactcheckResultWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of FactcheckResults to fetch.
     */
    orderBy?:
      | FactcheckResultOrderByWithRelationInput
      | FactcheckResultOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for FactcheckResults.
     */
    cursor?: FactcheckResultWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` FactcheckResults from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` FactcheckResults.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of FactcheckResults.
     */
    distinct?:
      | FactcheckResultScalarFieldEnum
      | FactcheckResultScalarFieldEnum[];
  };

  /**
   * FactcheckResult findMany
   */
  export type FactcheckResultFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactcheckResult
     */
    select?: FactcheckResultSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FactcheckResult
     */
    omit?: FactcheckResultOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactcheckResultInclude<ExtArgs> | null;
    /**
     * Filter, which FactcheckResults to fetch.
     */
    where?: FactcheckResultWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of FactcheckResults to fetch.
     */
    orderBy?:
      | FactcheckResultOrderByWithRelationInput
      | FactcheckResultOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing FactcheckResults.
     */
    cursor?: FactcheckResultWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` FactcheckResults from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` FactcheckResults.
     */
    skip?: number;
    distinct?:
      | FactcheckResultScalarFieldEnum
      | FactcheckResultScalarFieldEnum[];
  };

  /**
   * FactcheckResult create
   */
  export type FactcheckResultCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactcheckResult
     */
    select?: FactcheckResultSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FactcheckResult
     */
    omit?: FactcheckResultOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactcheckResultInclude<ExtArgs> | null;
    /**
     * The data needed to create a FactcheckResult.
     */
    data: XOR<FactcheckResultCreateInput, FactcheckResultUncheckedCreateInput>;
  };

  /**
   * FactcheckResult createMany
   */
  export type FactcheckResultCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many FactcheckResults.
     */
    data: FactcheckResultCreateManyInput | FactcheckResultCreateManyInput[];
  };

  /**
   * FactcheckResult update
   */
  export type FactcheckResultUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactcheckResult
     */
    select?: FactcheckResultSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FactcheckResult
     */
    omit?: FactcheckResultOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactcheckResultInclude<ExtArgs> | null;
    /**
     * The data needed to update a FactcheckResult.
     */
    data: XOR<FactcheckResultUpdateInput, FactcheckResultUncheckedUpdateInput>;
    /**
     * Choose, which FactcheckResult to update.
     */
    where: FactcheckResultWhereUniqueInput;
  };

  /**
   * FactcheckResult updateMany
   */
  export type FactcheckResultUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update FactcheckResults.
     */
    data: XOR<
      FactcheckResultUpdateManyMutationInput,
      FactcheckResultUncheckedUpdateManyInput
    >;
    /**
     * Filter which FactcheckResults to update
     */
    where?: FactcheckResultWhereInput;
    /**
     * Limit how many FactcheckResults to update.
     */
    limit?: number;
  };

  /**
   * FactcheckResult upsert
   */
  export type FactcheckResultUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactcheckResult
     */
    select?: FactcheckResultSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FactcheckResult
     */
    omit?: FactcheckResultOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactcheckResultInclude<ExtArgs> | null;
    /**
     * The filter to search for the FactcheckResult to update in case it exists.
     */
    where: FactcheckResultWhereUniqueInput;
    /**
     * In case the FactcheckResult found by the `where` argument doesn't exist, create a new FactcheckResult with this data.
     */
    create: XOR<
      FactcheckResultCreateInput,
      FactcheckResultUncheckedCreateInput
    >;
    /**
     * In case the FactcheckResult was found with the provided `where` argument, update it with this data.
     */
    update: XOR<
      FactcheckResultUpdateInput,
      FactcheckResultUncheckedUpdateInput
    >;
  };

  /**
   * FactcheckResult delete
   */
  export type FactcheckResultDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactcheckResult
     */
    select?: FactcheckResultSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FactcheckResult
     */
    omit?: FactcheckResultOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactcheckResultInclude<ExtArgs> | null;
    /**
     * Filter which FactcheckResult to delete.
     */
    where: FactcheckResultWhereUniqueInput;
  };

  /**
   * FactcheckResult deleteMany
   */
  export type FactcheckResultDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which FactcheckResults to delete
     */
    where?: FactcheckResultWhereInput;
    /**
     * Limit how many FactcheckResults to delete.
     */
    limit?: number;
  };

  /**
   * FactcheckResult findRaw
   */
  export type FactcheckResultFindRawArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue;
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue;
  };

  /**
   * FactcheckResult aggregateRaw
   */
  export type FactcheckResultAggregateRawArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[];
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue;
  };

  /**
   * FactcheckResult without action
   */
  export type FactcheckResultDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactcheckResult
     */
    select?: FactcheckResultSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FactcheckResult
     */
    omit?: FactcheckResultOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactcheckResultInclude<ExtArgs> | null;
  };

  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null;
    _min: AuditLogMinAggregateOutputType | null;
    _max: AuditLogMaxAggregateOutputType | null;
  };

  export type AuditLogMinAggregateOutputType = {
    id: string | null;
    entityType: string | null;
    entityId: string | null;
    action: string | null;
    actor: string | null;
    at: Date | null;
  };

  export type AuditLogMaxAggregateOutputType = {
    id: string | null;
    entityType: string | null;
    entityId: string | null;
    action: string | null;
    actor: string | null;
    at: Date | null;
  };

  export type AuditLogCountAggregateOutputType = {
    id: number;
    entityType: number;
    entityId: number;
    action: number;
    actor: number;
    at: number;
    meta: number;
    _all: number;
  };

  export type AuditLogMinAggregateInputType = {
    id?: true;
    entityType?: true;
    entityId?: true;
    action?: true;
    actor?: true;
    at?: true;
  };

  export type AuditLogMaxAggregateInputType = {
    id?: true;
    entityType?: true;
    entityId?: true;
    action?: true;
    actor?: true;
    at?: true;
  };

  export type AuditLogCountAggregateInputType = {
    id?: true;
    entityType?: true;
    entityId?: true;
    action?: true;
    actor?: true;
    at?: true;
    meta?: true;
    _all?: true;
  };

  export type AuditLogAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?:
      | AuditLogOrderByWithRelationInput
      | AuditLogOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AuditLogs.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned AuditLogs
     **/
    _count?: true | AuditLogCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: AuditLogMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: AuditLogMaxAggregateInputType;
  };

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
    [P in keyof T & keyof AggregateAuditLog]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>;
  };

  export type AuditLogGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: AuditLogWhereInput;
    orderBy?:
      | AuditLogOrderByWithAggregationInput
      | AuditLogOrderByWithAggregationInput[];
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum;
    having?: AuditLogScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: AuditLogCountAggregateInputType | true;
    _min?: AuditLogMinAggregateInputType;
    _max?: AuditLogMaxAggregateInputType;
  };

  export type AuditLogGroupByOutputType = {
    id: string;
    entityType: string;
    entityId: string;
    action: string;
    actor: string;
    at: Date;
    meta: JsonValue;
    _count: AuditLogCountAggregateOutputType | null;
    _min: AuditLogMinAggregateOutputType | null;
    _max: AuditLogMaxAggregateOutputType | null;
  };

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<AuditLogGroupByOutputType, T["by"]> & {
          [P in keyof T & keyof AuditLogGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>;
        }
      >
    >;

  export type AuditLogSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      entityType?: boolean;
      entityId?: boolean;
      action?: boolean;
      actor?: boolean;
      at?: boolean;
      meta?: boolean;
    },
    ExtArgs["result"]["auditLog"]
  >;

  export type AuditLogSelectScalar = {
    id?: boolean;
    entityType?: boolean;
    entityId?: boolean;
    action?: boolean;
    actor?: boolean;
    at?: boolean;
    meta?: boolean;
  };

  export type AuditLogOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    "id" | "entityType" | "entityId" | "action" | "actor" | "at" | "meta",
    ExtArgs["result"]["auditLog"]
  >;

  export type $AuditLogPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "AuditLog";
    objects: {};
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        entityType: string;
        entityId: string;
        action: string;
        actor: string;
        at: Date;
        meta: Prisma.JsonValue;
      },
      ExtArgs["result"]["auditLog"]
    >;
    composites: {};
  };

  type AuditLogGetPayload<
    S extends boolean | null | undefined | AuditLogDefaultArgs,
  > = $Result.GetResult<Prisma.$AuditLogPayload, S>;

  type AuditLogCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<AuditLogFindManyArgs, "select" | "include" | "distinct" | "omit"> & {
    select?: AuditLogCountAggregateInputType | true;
  };

  export interface AuditLogDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["AuditLog"];
      meta: { name: "AuditLog" };
    };
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(
      args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>,
    ): Prisma__AuditLogClient<
      $Result.GetResult<
        Prisma.$AuditLogPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(
      args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__AuditLogClient<
      $Result.GetResult<
        Prisma.$AuditLogPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(
      args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>,
    ): Prisma__AuditLogClient<
      $Result.GetResult<
        Prisma.$AuditLogPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(
      args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__AuditLogClient<
      $Result.GetResult<
        Prisma.$AuditLogPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     *
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     *
     */
    findMany<T extends AuditLogFindManyArgs>(
      args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$AuditLogPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     *
     */
    create<T extends AuditLogCreateArgs>(
      args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>,
    ): Prisma__AuditLogClient<
      $Result.GetResult<
        Prisma.$AuditLogPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends AuditLogCreateManyArgs>(
      args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     *
     */
    delete<T extends AuditLogDeleteArgs>(
      args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>,
    ): Prisma__AuditLogClient<
      $Result.GetResult<
        Prisma.$AuditLogPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends AuditLogUpdateArgs>(
      args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>,
    ): Prisma__AuditLogClient<
      $Result.GetResult<
        Prisma.$AuditLogPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(
      args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends AuditLogUpdateManyArgs>(
      args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(
      args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>,
    ): Prisma__AuditLogClient<
      $Result.GetResult<
        Prisma.$AuditLogPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more AuditLogs that matches the filter.
     * @param {AuditLogFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const auditLog = await prisma.auditLog.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: AuditLogFindRawArgs): Prisma.PrismaPromise<JsonObject>;

    /**
     * Perform aggregation operations on a AuditLog.
     * @param {AuditLogAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const auditLog = await prisma.auditLog.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(
      args?: AuditLogAggregateRawArgs,
    ): Prisma.PrismaPromise<JsonObject>;

    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
     **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], AuditLogCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends AuditLogAggregateArgs>(
      args: Subset<T, AuditLogAggregateArgs>,
    ): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>;

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs["orderBy"] }
        : { orderBy?: AuditLogGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> &
        InputErrors,
    ): {} extends InputErrors
      ? GetAuditLogGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the AuditLog model
     */
    readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the AuditLog model
   */
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", "String">;
    readonly entityType: FieldRef<"AuditLog", "String">;
    readonly entityId: FieldRef<"AuditLog", "String">;
    readonly action: FieldRef<"AuditLog", "String">;
    readonly actor: FieldRef<"AuditLog", "String">;
    readonly at: FieldRef<"AuditLog", "DateTime">;
    readonly meta: FieldRef<"AuditLog", "Json">;
  }

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null;
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput;
  };

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null;
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput;
  };

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null;
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?:
      | AuditLogOrderByWithRelationInput
      | AuditLogOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AuditLogs.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[];
  };

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null;
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?:
      | AuditLogOrderByWithRelationInput
      | AuditLogOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AuditLogs.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[];
  };

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null;
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?:
      | AuditLogOrderByWithRelationInput
      | AuditLogOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AuditLogs.
     */
    skip?: number;
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[];
  };

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null;
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>;
  };

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[];
  };

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null;
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>;
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput;
  };

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<
      AuditLogUpdateManyMutationInput,
      AuditLogUncheckedUpdateManyInput
    >;
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput;
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number;
  };

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null;
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput;
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>;
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>;
  };

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null;
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput;
  };

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput;
    /**
     * Limit how many AuditLogs to delete.
     */
    limit?: number;
  };

  /**
   * AuditLog findRaw
   */
  export type AuditLogFindRawArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue;
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue;
  };

  /**
   * AuditLog aggregateRaw
   */
  export type AuditLogAggregateRawArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[];
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue;
  };

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null;
  };

  /**
   * Model ExtractedUnit
   */

  export type AggregateExtractedUnit = {
    _count: ExtractedUnitCountAggregateOutputType | null;
    _avg: ExtractedUnitAvgAggregateOutputType | null;
    _sum: ExtractedUnitSumAggregateOutputType | null;
    _min: ExtractedUnitMinAggregateOutputType | null;
    _max: ExtractedUnitMaxAggregateOutputType | null;
  };

  export type ExtractedUnitAvgAggregateOutputType = {
    spanStart: number | null;
    spanEnd: number | null;
    confidence: number | null;
  };

  export type ExtractedUnitSumAggregateOutputType = {
    spanStart: number | null;
    spanEnd: number | null;
    confidence: number | null;
  };

  export type ExtractedUnitMinAggregateOutputType = {
    id: string | null;
    itemId: string | null;
    statementId: string | null;
    kind: $Enums.UnitKind | null;
    text: string | null;
    spanStart: number | null;
    spanEnd: number | null;
    confidence: number | null;
    canonicalKey: string | null;
    scope: string | null;
    timeframe: string | null;
    claimId: string | null;
    interest: $Enums.Interest | null;
    triage: $Enums.Triage | null;
    editorNote: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type ExtractedUnitMaxAggregateOutputType = {
    id: string | null;
    itemId: string | null;
    statementId: string | null;
    kind: $Enums.UnitKind | null;
    text: string | null;
    spanStart: number | null;
    spanEnd: number | null;
    confidence: number | null;
    canonicalKey: string | null;
    scope: string | null;
    timeframe: string | null;
    claimId: string | null;
    interest: $Enums.Interest | null;
    triage: $Enums.Triage | null;
    editorNote: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type ExtractedUnitCountAggregateOutputType = {
    id: number;
    itemId: number;
    statementId: number;
    kind: number;
    text: number;
    spanStart: number;
    spanEnd: number;
    confidence: number;
    canonicalKey: number;
    scope: number;
    timeframe: number;
    claimId: number;
    interest: number;
    triage: number;
    editorNote: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type ExtractedUnitAvgAggregateInputType = {
    spanStart?: true;
    spanEnd?: true;
    confidence?: true;
  };

  export type ExtractedUnitSumAggregateInputType = {
    spanStart?: true;
    spanEnd?: true;
    confidence?: true;
  };

  export type ExtractedUnitMinAggregateInputType = {
    id?: true;
    itemId?: true;
    statementId?: true;
    kind?: true;
    text?: true;
    spanStart?: true;
    spanEnd?: true;
    confidence?: true;
    canonicalKey?: true;
    scope?: true;
    timeframe?: true;
    claimId?: true;
    interest?: true;
    triage?: true;
    editorNote?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type ExtractedUnitMaxAggregateInputType = {
    id?: true;
    itemId?: true;
    statementId?: true;
    kind?: true;
    text?: true;
    spanStart?: true;
    spanEnd?: true;
    confidence?: true;
    canonicalKey?: true;
    scope?: true;
    timeframe?: true;
    claimId?: true;
    interest?: true;
    triage?: true;
    editorNote?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type ExtractedUnitCountAggregateInputType = {
    id?: true;
    itemId?: true;
    statementId?: true;
    kind?: true;
    text?: true;
    spanStart?: true;
    spanEnd?: true;
    confidence?: true;
    canonicalKey?: true;
    scope?: true;
    timeframe?: true;
    claimId?: true;
    interest?: true;
    triage?: true;
    editorNote?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type ExtractedUnitAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which ExtractedUnit to aggregate.
     */
    where?: ExtractedUnitWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ExtractedUnits to fetch.
     */
    orderBy?:
      | ExtractedUnitOrderByWithRelationInput
      | ExtractedUnitOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: ExtractedUnitWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ExtractedUnits from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ExtractedUnits.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned ExtractedUnits
     **/
    _count?: true | ExtractedUnitCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: ExtractedUnitAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: ExtractedUnitSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: ExtractedUnitMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: ExtractedUnitMaxAggregateInputType;
  };

  export type GetExtractedUnitAggregateType<
    T extends ExtractedUnitAggregateArgs,
  > = {
    [P in keyof T & keyof AggregateExtractedUnit]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExtractedUnit[P]>
      : GetScalarType<T[P], AggregateExtractedUnit[P]>;
  };

  export type ExtractedUnitGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ExtractedUnitWhereInput;
    orderBy?:
      | ExtractedUnitOrderByWithAggregationInput
      | ExtractedUnitOrderByWithAggregationInput[];
    by: ExtractedUnitScalarFieldEnum[] | ExtractedUnitScalarFieldEnum;
    having?: ExtractedUnitScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: ExtractedUnitCountAggregateInputType | true;
    _avg?: ExtractedUnitAvgAggregateInputType;
    _sum?: ExtractedUnitSumAggregateInputType;
    _min?: ExtractedUnitMinAggregateInputType;
    _max?: ExtractedUnitMaxAggregateInputType;
  };

  export type ExtractedUnitGroupByOutputType = {
    id: string;
    itemId: string | null;
    statementId: string | null;
    kind: $Enums.UnitKind;
    text: string;
    spanStart: number;
    spanEnd: number;
    confidence: number;
    canonicalKey: string;
    scope: string | null;
    timeframe: string | null;
    claimId: string | null;
    interest: $Enums.Interest;
    triage: $Enums.Triage;
    editorNote: string | null;
    createdAt: Date;
    updatedAt: Date;
    _count: ExtractedUnitCountAggregateOutputType | null;
    _avg: ExtractedUnitAvgAggregateOutputType | null;
    _sum: ExtractedUnitSumAggregateOutputType | null;
    _min: ExtractedUnitMinAggregateOutputType | null;
    _max: ExtractedUnitMaxAggregateOutputType | null;
  };

  type GetExtractedUnitGroupByPayload<T extends ExtractedUnitGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<ExtractedUnitGroupByOutputType, T["by"]> & {
          [P in keyof T &
            keyof ExtractedUnitGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExtractedUnitGroupByOutputType[P]>
            : GetScalarType<T[P], ExtractedUnitGroupByOutputType[P]>;
        }
      >
    >;

  export type ExtractedUnitSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      itemId?: boolean;
      statementId?: boolean;
      kind?: boolean;
      text?: boolean;
      spanStart?: boolean;
      spanEnd?: boolean;
      confidence?: boolean;
      canonicalKey?: boolean;
      scope?: boolean;
      timeframe?: boolean;
      claimId?: boolean;
      interest?: boolean;
      triage?: boolean;
      editorNote?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      item?: boolean | ExtractedUnit$itemArgs<ExtArgs>;
      claim?: boolean | ExtractedUnit$claimArgs<ExtArgs>;
    },
    ExtArgs["result"]["extractedUnit"]
  >;

  export type ExtractedUnitSelectScalar = {
    id?: boolean;
    itemId?: boolean;
    statementId?: boolean;
    kind?: boolean;
    text?: boolean;
    spanStart?: boolean;
    spanEnd?: boolean;
    confidence?: boolean;
    canonicalKey?: boolean;
    scope?: boolean;
    timeframe?: boolean;
    claimId?: boolean;
    interest?: boolean;
    triage?: boolean;
    editorNote?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type ExtractedUnitOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | "id"
    | "itemId"
    | "statementId"
    | "kind"
    | "text"
    | "spanStart"
    | "spanEnd"
    | "confidence"
    | "canonicalKey"
    | "scope"
    | "timeframe"
    | "claimId"
    | "interest"
    | "triage"
    | "editorNote"
    | "createdAt"
    | "updatedAt",
    ExtArgs["result"]["extractedUnit"]
  >;
  export type ExtractedUnitInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    item?: boolean | ExtractedUnit$itemArgs<ExtArgs>;
    claim?: boolean | ExtractedUnit$claimArgs<ExtArgs>;
  };

  export type $ExtractedUnitPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "ExtractedUnit";
    objects: {
      item: Prisma.$ContentItemPayload<ExtArgs> | null;
      claim: Prisma.$FactcheckClaimPayload<ExtArgs> | null;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        itemId: string | null;
        statementId: string | null;
        kind: $Enums.UnitKind;
        text: string;
        spanStart: number;
        spanEnd: number;
        confidence: number;
        canonicalKey: string;
        scope: string | null;
        timeframe: string | null;
        claimId: string | null;
        interest: $Enums.Interest;
        triage: $Enums.Triage;
        editorNote: string | null;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs["result"]["extractedUnit"]
    >;
    composites: {};
  };

  type ExtractedUnitGetPayload<
    S extends boolean | null | undefined | ExtractedUnitDefaultArgs,
  > = $Result.GetResult<Prisma.$ExtractedUnitPayload, S>;

  type ExtractedUnitCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    ExtractedUnitFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: ExtractedUnitCountAggregateInputType | true;
  };

  export interface ExtractedUnitDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["ExtractedUnit"];
      meta: { name: "ExtractedUnit" };
    };
    /**
     * Find zero or one ExtractedUnit that matches the filter.
     * @param {ExtractedUnitFindUniqueArgs} args - Arguments to find a ExtractedUnit
     * @example
     * // Get one ExtractedUnit
     * const extractedUnit = await prisma.extractedUnit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExtractedUnitFindUniqueArgs>(
      args: SelectSubset<T, ExtractedUnitFindUniqueArgs<ExtArgs>>,
    ): Prisma__ExtractedUnitClient<
      $Result.GetResult<
        Prisma.$ExtractedUnitPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one ExtractedUnit that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExtractedUnitFindUniqueOrThrowArgs} args - Arguments to find a ExtractedUnit
     * @example
     * // Get one ExtractedUnit
     * const extractedUnit = await prisma.extractedUnit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExtractedUnitFindUniqueOrThrowArgs>(
      args: SelectSubset<T, ExtractedUnitFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__ExtractedUnitClient<
      $Result.GetResult<
        Prisma.$ExtractedUnitPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first ExtractedUnit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExtractedUnitFindFirstArgs} args - Arguments to find a ExtractedUnit
     * @example
     * // Get one ExtractedUnit
     * const extractedUnit = await prisma.extractedUnit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExtractedUnitFindFirstArgs>(
      args?: SelectSubset<T, ExtractedUnitFindFirstArgs<ExtArgs>>,
    ): Prisma__ExtractedUnitClient<
      $Result.GetResult<
        Prisma.$ExtractedUnitPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first ExtractedUnit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExtractedUnitFindFirstOrThrowArgs} args - Arguments to find a ExtractedUnit
     * @example
     * // Get one ExtractedUnit
     * const extractedUnit = await prisma.extractedUnit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExtractedUnitFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ExtractedUnitFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__ExtractedUnitClient<
      $Result.GetResult<
        Prisma.$ExtractedUnitPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more ExtractedUnits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExtractedUnitFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExtractedUnits
     * const extractedUnits = await prisma.extractedUnit.findMany()
     *
     * // Get first 10 ExtractedUnits
     * const extractedUnits = await prisma.extractedUnit.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const extractedUnitWithIdOnly = await prisma.extractedUnit.findMany({ select: { id: true } })
     *
     */
    findMany<T extends ExtractedUnitFindManyArgs>(
      args?: SelectSubset<T, ExtractedUnitFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ExtractedUnitPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a ExtractedUnit.
     * @param {ExtractedUnitCreateArgs} args - Arguments to create a ExtractedUnit.
     * @example
     * // Create one ExtractedUnit
     * const ExtractedUnit = await prisma.extractedUnit.create({
     *   data: {
     *     // ... data to create a ExtractedUnit
     *   }
     * })
     *
     */
    create<T extends ExtractedUnitCreateArgs>(
      args: SelectSubset<T, ExtractedUnitCreateArgs<ExtArgs>>,
    ): Prisma__ExtractedUnitClient<
      $Result.GetResult<
        Prisma.$ExtractedUnitPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many ExtractedUnits.
     * @param {ExtractedUnitCreateManyArgs} args - Arguments to create many ExtractedUnits.
     * @example
     * // Create many ExtractedUnits
     * const extractedUnit = await prisma.extractedUnit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends ExtractedUnitCreateManyArgs>(
      args?: SelectSubset<T, ExtractedUnitCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a ExtractedUnit.
     * @param {ExtractedUnitDeleteArgs} args - Arguments to delete one ExtractedUnit.
     * @example
     * // Delete one ExtractedUnit
     * const ExtractedUnit = await prisma.extractedUnit.delete({
     *   where: {
     *     // ... filter to delete one ExtractedUnit
     *   }
     * })
     *
     */
    delete<T extends ExtractedUnitDeleteArgs>(
      args: SelectSubset<T, ExtractedUnitDeleteArgs<ExtArgs>>,
    ): Prisma__ExtractedUnitClient<
      $Result.GetResult<
        Prisma.$ExtractedUnitPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one ExtractedUnit.
     * @param {ExtractedUnitUpdateArgs} args - Arguments to update one ExtractedUnit.
     * @example
     * // Update one ExtractedUnit
     * const extractedUnit = await prisma.extractedUnit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends ExtractedUnitUpdateArgs>(
      args: SelectSubset<T, ExtractedUnitUpdateArgs<ExtArgs>>,
    ): Prisma__ExtractedUnitClient<
      $Result.GetResult<
        Prisma.$ExtractedUnitPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more ExtractedUnits.
     * @param {ExtractedUnitDeleteManyArgs} args - Arguments to filter ExtractedUnits to delete.
     * @example
     * // Delete a few ExtractedUnits
     * const { count } = await prisma.extractedUnit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends ExtractedUnitDeleteManyArgs>(
      args?: SelectSubset<T, ExtractedUnitDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more ExtractedUnits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExtractedUnitUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExtractedUnits
     * const extractedUnit = await prisma.extractedUnit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends ExtractedUnitUpdateManyArgs>(
      args: SelectSubset<T, ExtractedUnitUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one ExtractedUnit.
     * @param {ExtractedUnitUpsertArgs} args - Arguments to update or create a ExtractedUnit.
     * @example
     * // Update or create a ExtractedUnit
     * const extractedUnit = await prisma.extractedUnit.upsert({
     *   create: {
     *     // ... data to create a ExtractedUnit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExtractedUnit we want to update
     *   }
     * })
     */
    upsert<T extends ExtractedUnitUpsertArgs>(
      args: SelectSubset<T, ExtractedUnitUpsertArgs<ExtArgs>>,
    ): Prisma__ExtractedUnitClient<
      $Result.GetResult<
        Prisma.$ExtractedUnitPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more ExtractedUnits that matches the filter.
     * @param {ExtractedUnitFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const extractedUnit = await prisma.extractedUnit.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: ExtractedUnitFindRawArgs): Prisma.PrismaPromise<JsonObject>;

    /**
     * Perform aggregation operations on a ExtractedUnit.
     * @param {ExtractedUnitAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const extractedUnit = await prisma.extractedUnit.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(
      args?: ExtractedUnitAggregateRawArgs,
    ): Prisma.PrismaPromise<JsonObject>;

    /**
     * Count the number of ExtractedUnits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExtractedUnitCountArgs} args - Arguments to filter ExtractedUnits to count.
     * @example
     * // Count the number of ExtractedUnits
     * const count = await prisma.extractedUnit.count({
     *   where: {
     *     // ... the filter for the ExtractedUnits we want to count
     *   }
     * })
     **/
    count<T extends ExtractedUnitCountArgs>(
      args?: Subset<T, ExtractedUnitCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], ExtractedUnitCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a ExtractedUnit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExtractedUnitAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends ExtractedUnitAggregateArgs>(
      args: Subset<T, ExtractedUnitAggregateArgs>,
    ): Prisma.PrismaPromise<GetExtractedUnitAggregateType<T>>;

    /**
     * Group by ExtractedUnit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExtractedUnitGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends ExtractedUnitGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExtractedUnitGroupByArgs["orderBy"] }
        : { orderBy?: ExtractedUnitGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, ExtractedUnitGroupByArgs, OrderByArg> &
        InputErrors,
    ): {} extends InputErrors
      ? GetExtractedUnitGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the ExtractedUnit model
     */
    readonly fields: ExtractedUnitFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExtractedUnit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExtractedUnitClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    item<T extends ExtractedUnit$itemArgs<ExtArgs> = {}>(
      args?: Subset<T, ExtractedUnit$itemArgs<ExtArgs>>,
    ): Prisma__ContentItemClient<
      $Result.GetResult<
        Prisma.$ContentItemPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    claim<T extends ExtractedUnit$claimArgs<ExtArgs> = {}>(
      args?: Subset<T, ExtractedUnit$claimArgs<ExtArgs>>,
    ): Prisma__FactcheckClaimClient<
      $Result.GetResult<
        Prisma.$FactcheckClaimPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the ExtractedUnit model
   */
  interface ExtractedUnitFieldRefs {
    readonly id: FieldRef<"ExtractedUnit", "String">;
    readonly itemId: FieldRef<"ExtractedUnit", "String">;
    readonly statementId: FieldRef<"ExtractedUnit", "String">;
    readonly kind: FieldRef<"ExtractedUnit", "UnitKind">;
    readonly text: FieldRef<"ExtractedUnit", "String">;
    readonly spanStart: FieldRef<"ExtractedUnit", "Int">;
    readonly spanEnd: FieldRef<"ExtractedUnit", "Int">;
    readonly confidence: FieldRef<"ExtractedUnit", "Float">;
    readonly canonicalKey: FieldRef<"ExtractedUnit", "String">;
    readonly scope: FieldRef<"ExtractedUnit", "String">;
    readonly timeframe: FieldRef<"ExtractedUnit", "String">;
    readonly claimId: FieldRef<"ExtractedUnit", "String">;
    readonly interest: FieldRef<"ExtractedUnit", "Interest">;
    readonly triage: FieldRef<"ExtractedUnit", "Triage">;
    readonly editorNote: FieldRef<"ExtractedUnit", "String">;
    readonly createdAt: FieldRef<"ExtractedUnit", "DateTime">;
    readonly updatedAt: FieldRef<"ExtractedUnit", "DateTime">;
  }

  // Custom InputTypes
  /**
   * ExtractedUnit findUnique
   */
  export type ExtractedUnitFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ExtractedUnit
     */
    select?: ExtractedUnitSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ExtractedUnit
     */
    omit?: ExtractedUnitOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExtractedUnitInclude<ExtArgs> | null;
    /**
     * Filter, which ExtractedUnit to fetch.
     */
    where: ExtractedUnitWhereUniqueInput;
  };

  /**
   * ExtractedUnit findUniqueOrThrow
   */
  export type ExtractedUnitFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ExtractedUnit
     */
    select?: ExtractedUnitSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ExtractedUnit
     */
    omit?: ExtractedUnitOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExtractedUnitInclude<ExtArgs> | null;
    /**
     * Filter, which ExtractedUnit to fetch.
     */
    where: ExtractedUnitWhereUniqueInput;
  };

  /**
   * ExtractedUnit findFirst
   */
  export type ExtractedUnitFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ExtractedUnit
     */
    select?: ExtractedUnitSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ExtractedUnit
     */
    omit?: ExtractedUnitOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExtractedUnitInclude<ExtArgs> | null;
    /**
     * Filter, which ExtractedUnit to fetch.
     */
    where?: ExtractedUnitWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ExtractedUnits to fetch.
     */
    orderBy?:
      | ExtractedUnitOrderByWithRelationInput
      | ExtractedUnitOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ExtractedUnits.
     */
    cursor?: ExtractedUnitWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ExtractedUnits from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ExtractedUnits.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ExtractedUnits.
     */
    distinct?: ExtractedUnitScalarFieldEnum | ExtractedUnitScalarFieldEnum[];
  };

  /**
   * ExtractedUnit findFirstOrThrow
   */
  export type ExtractedUnitFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ExtractedUnit
     */
    select?: ExtractedUnitSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ExtractedUnit
     */
    omit?: ExtractedUnitOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExtractedUnitInclude<ExtArgs> | null;
    /**
     * Filter, which ExtractedUnit to fetch.
     */
    where?: ExtractedUnitWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ExtractedUnits to fetch.
     */
    orderBy?:
      | ExtractedUnitOrderByWithRelationInput
      | ExtractedUnitOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ExtractedUnits.
     */
    cursor?: ExtractedUnitWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ExtractedUnits from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ExtractedUnits.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ExtractedUnits.
     */
    distinct?: ExtractedUnitScalarFieldEnum | ExtractedUnitScalarFieldEnum[];
  };

  /**
   * ExtractedUnit findMany
   */
  export type ExtractedUnitFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ExtractedUnit
     */
    select?: ExtractedUnitSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ExtractedUnit
     */
    omit?: ExtractedUnitOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExtractedUnitInclude<ExtArgs> | null;
    /**
     * Filter, which ExtractedUnits to fetch.
     */
    where?: ExtractedUnitWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ExtractedUnits to fetch.
     */
    orderBy?:
      | ExtractedUnitOrderByWithRelationInput
      | ExtractedUnitOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing ExtractedUnits.
     */
    cursor?: ExtractedUnitWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ExtractedUnits from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ExtractedUnits.
     */
    skip?: number;
    distinct?: ExtractedUnitScalarFieldEnum | ExtractedUnitScalarFieldEnum[];
  };

  /**
   * ExtractedUnit create
   */
  export type ExtractedUnitCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ExtractedUnit
     */
    select?: ExtractedUnitSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ExtractedUnit
     */
    omit?: ExtractedUnitOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExtractedUnitInclude<ExtArgs> | null;
    /**
     * The data needed to create a ExtractedUnit.
     */
    data: XOR<ExtractedUnitCreateInput, ExtractedUnitUncheckedCreateInput>;
  };

  /**
   * ExtractedUnit createMany
   */
  export type ExtractedUnitCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many ExtractedUnits.
     */
    data: ExtractedUnitCreateManyInput | ExtractedUnitCreateManyInput[];
  };

  /**
   * ExtractedUnit update
   */
  export type ExtractedUnitUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ExtractedUnit
     */
    select?: ExtractedUnitSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ExtractedUnit
     */
    omit?: ExtractedUnitOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExtractedUnitInclude<ExtArgs> | null;
    /**
     * The data needed to update a ExtractedUnit.
     */
    data: XOR<ExtractedUnitUpdateInput, ExtractedUnitUncheckedUpdateInput>;
    /**
     * Choose, which ExtractedUnit to update.
     */
    where: ExtractedUnitWhereUniqueInput;
  };

  /**
   * ExtractedUnit updateMany
   */
  export type ExtractedUnitUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update ExtractedUnits.
     */
    data: XOR<
      ExtractedUnitUpdateManyMutationInput,
      ExtractedUnitUncheckedUpdateManyInput
    >;
    /**
     * Filter which ExtractedUnits to update
     */
    where?: ExtractedUnitWhereInput;
    /**
     * Limit how many ExtractedUnits to update.
     */
    limit?: number;
  };

  /**
   * ExtractedUnit upsert
   */
  export type ExtractedUnitUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ExtractedUnit
     */
    select?: ExtractedUnitSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ExtractedUnit
     */
    omit?: ExtractedUnitOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExtractedUnitInclude<ExtArgs> | null;
    /**
     * The filter to search for the ExtractedUnit to update in case it exists.
     */
    where: ExtractedUnitWhereUniqueInput;
    /**
     * In case the ExtractedUnit found by the `where` argument doesn't exist, create a new ExtractedUnit with this data.
     */
    create: XOR<ExtractedUnitCreateInput, ExtractedUnitUncheckedCreateInput>;
    /**
     * In case the ExtractedUnit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExtractedUnitUpdateInput, ExtractedUnitUncheckedUpdateInput>;
  };

  /**
   * ExtractedUnit delete
   */
  export type ExtractedUnitDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ExtractedUnit
     */
    select?: ExtractedUnitSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ExtractedUnit
     */
    omit?: ExtractedUnitOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExtractedUnitInclude<ExtArgs> | null;
    /**
     * Filter which ExtractedUnit to delete.
     */
    where: ExtractedUnitWhereUniqueInput;
  };

  /**
   * ExtractedUnit deleteMany
   */
  export type ExtractedUnitDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which ExtractedUnits to delete
     */
    where?: ExtractedUnitWhereInput;
    /**
     * Limit how many ExtractedUnits to delete.
     */
    limit?: number;
  };

  /**
   * ExtractedUnit findRaw
   */
  export type ExtractedUnitFindRawArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue;
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue;
  };

  /**
   * ExtractedUnit aggregateRaw
   */
  export type ExtractedUnitAggregateRawArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[];
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue;
  };

  /**
   * ExtractedUnit.item
   */
  export type ExtractedUnit$itemArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ContentItem
     */
    select?: ContentItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ContentItem
     */
    omit?: ContentItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentItemInclude<ExtArgs> | null;
    where?: ContentItemWhereInput;
  };

  /**
   * ExtractedUnit.claim
   */
  export type ExtractedUnit$claimArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactcheckClaim
     */
    select?: FactcheckClaimSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FactcheckClaim
     */
    omit?: FactcheckClaimOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactcheckClaimInclude<ExtArgs> | null;
    where?: FactcheckClaimWhereInput;
  };

  /**
   * ExtractedUnit without action
   */
  export type ExtractedUnitDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ExtractedUnit
     */
    select?: ExtractedUnitSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ExtractedUnit
     */
    omit?: ExtractedUnitOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExtractedUnitInclude<ExtArgs> | null;
  };

  /**
   * Model Finding
   */

  export type AggregateFinding = {
    _count: FindingCountAggregateOutputType | null;
    _min: FindingMinAggregateOutputType | null;
    _max: FindingMaxAggregateOutputType | null;
  };

  export type FindingMinAggregateOutputType = {
    id: string | null;
    claimId: string | null;
    summary: string | null;
    outcome: string | null;
    rationale: string | null;
    lastChecked: Date | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type FindingMaxAggregateOutputType = {
    id: string | null;
    claimId: string | null;
    summary: string | null;
    outcome: string | null;
    rationale: string | null;
    lastChecked: Date | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type FindingCountAggregateOutputType = {
    id: number;
    claimId: number;
    summary: number;
    outcome: number;
    rationale: number;
    metrics: number;
    comparedJurisdictions: number;
    lastChecked: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type FindingMinAggregateInputType = {
    id?: true;
    claimId?: true;
    summary?: true;
    outcome?: true;
    rationale?: true;
    lastChecked?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type FindingMaxAggregateInputType = {
    id?: true;
    claimId?: true;
    summary?: true;
    outcome?: true;
    rationale?: true;
    lastChecked?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type FindingCountAggregateInputType = {
    id?: true;
    claimId?: true;
    summary?: true;
    outcome?: true;
    rationale?: true;
    metrics?: true;
    comparedJurisdictions?: true;
    lastChecked?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type FindingAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Finding to aggregate.
     */
    where?: FindingWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Findings to fetch.
     */
    orderBy?:
      | FindingOrderByWithRelationInput
      | FindingOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: FindingWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Findings from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Findings.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Findings
     **/
    _count?: true | FindingCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: FindingMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: FindingMaxAggregateInputType;
  };

  export type GetFindingAggregateType<T extends FindingAggregateArgs> = {
    [P in keyof T & keyof AggregateFinding]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFinding[P]>
      : GetScalarType<T[P], AggregateFinding[P]>;
  };

  export type FindingGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: FindingWhereInput;
    orderBy?:
      | FindingOrderByWithAggregationInput
      | FindingOrderByWithAggregationInput[];
    by: FindingScalarFieldEnum[] | FindingScalarFieldEnum;
    having?: FindingScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: FindingCountAggregateInputType | true;
    _min?: FindingMinAggregateInputType;
    _max?: FindingMaxAggregateInputType;
  };

  export type FindingGroupByOutputType = {
    id: string;
    claimId: string;
    summary: string;
    outcome: string;
    rationale: string;
    metrics: JsonValue | null;
    comparedJurisdictions: JsonValue | null;
    lastChecked: Date;
    createdAt: Date;
    updatedAt: Date;
    _count: FindingCountAggregateOutputType | null;
    _min: FindingMinAggregateOutputType | null;
    _max: FindingMaxAggregateOutputType | null;
  };

  type GetFindingGroupByPayload<T extends FindingGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<FindingGroupByOutputType, T["by"]> & {
          [P in keyof T & keyof FindingGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FindingGroupByOutputType[P]>
            : GetScalarType<T[P], FindingGroupByOutputType[P]>;
        }
      >
    >;

  export type FindingSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      claimId?: boolean;
      summary?: boolean;
      outcome?: boolean;
      rationale?: boolean;
      metrics?: boolean;
      comparedJurisdictions?: boolean;
      lastChecked?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      claim?: boolean | FactcheckClaimDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["finding"]
  >;

  export type FindingSelectScalar = {
    id?: boolean;
    claimId?: boolean;
    summary?: boolean;
    outcome?: boolean;
    rationale?: boolean;
    metrics?: boolean;
    comparedJurisdictions?: boolean;
    lastChecked?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type FindingOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | "id"
    | "claimId"
    | "summary"
    | "outcome"
    | "rationale"
    | "metrics"
    | "comparedJurisdictions"
    | "lastChecked"
    | "createdAt"
    | "updatedAt",
    ExtArgs["result"]["finding"]
  >;
  export type FindingInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    claim?: boolean | FactcheckClaimDefaultArgs<ExtArgs>;
  };

  export type $FindingPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "Finding";
    objects: {
      claim: Prisma.$FactcheckClaimPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        claimId: string;
        summary: string;
        outcome: string;
        rationale: string;
        metrics: Prisma.JsonValue | null;
        comparedJurisdictions: Prisma.JsonValue | null;
        lastChecked: Date;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs["result"]["finding"]
    >;
    composites: {};
  };

  type FindingGetPayload<
    S extends boolean | null | undefined | FindingDefaultArgs,
  > = $Result.GetResult<Prisma.$FindingPayload, S>;

  type FindingCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<FindingFindManyArgs, "select" | "include" | "distinct" | "omit"> & {
    select?: FindingCountAggregateInputType | true;
  };

  export interface FindingDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["Finding"];
      meta: { name: "Finding" };
    };
    /**
     * Find zero or one Finding that matches the filter.
     * @param {FindingFindUniqueArgs} args - Arguments to find a Finding
     * @example
     * // Get one Finding
     * const finding = await prisma.finding.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FindingFindUniqueArgs>(
      args: SelectSubset<T, FindingFindUniqueArgs<ExtArgs>>,
    ): Prisma__FindingClient<
      $Result.GetResult<
        Prisma.$FindingPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Finding that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FindingFindUniqueOrThrowArgs} args - Arguments to find a Finding
     * @example
     * // Get one Finding
     * const finding = await prisma.finding.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FindingFindUniqueOrThrowArgs>(
      args: SelectSubset<T, FindingFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__FindingClient<
      $Result.GetResult<
        Prisma.$FindingPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Finding that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FindingFindFirstArgs} args - Arguments to find a Finding
     * @example
     * // Get one Finding
     * const finding = await prisma.finding.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FindingFindFirstArgs>(
      args?: SelectSubset<T, FindingFindFirstArgs<ExtArgs>>,
    ): Prisma__FindingClient<
      $Result.GetResult<
        Prisma.$FindingPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Finding that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FindingFindFirstOrThrowArgs} args - Arguments to find a Finding
     * @example
     * // Get one Finding
     * const finding = await prisma.finding.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FindingFindFirstOrThrowArgs>(
      args?: SelectSubset<T, FindingFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__FindingClient<
      $Result.GetResult<
        Prisma.$FindingPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Findings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FindingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Findings
     * const findings = await prisma.finding.findMany()
     *
     * // Get first 10 Findings
     * const findings = await prisma.finding.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const findingWithIdOnly = await prisma.finding.findMany({ select: { id: true } })
     *
     */
    findMany<T extends FindingFindManyArgs>(
      args?: SelectSubset<T, FindingFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$FindingPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Finding.
     * @param {FindingCreateArgs} args - Arguments to create a Finding.
     * @example
     * // Create one Finding
     * const Finding = await prisma.finding.create({
     *   data: {
     *     // ... data to create a Finding
     *   }
     * })
     *
     */
    create<T extends FindingCreateArgs>(
      args: SelectSubset<T, FindingCreateArgs<ExtArgs>>,
    ): Prisma__FindingClient<
      $Result.GetResult<
        Prisma.$FindingPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Findings.
     * @param {FindingCreateManyArgs} args - Arguments to create many Findings.
     * @example
     * // Create many Findings
     * const finding = await prisma.finding.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends FindingCreateManyArgs>(
      args?: SelectSubset<T, FindingCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a Finding.
     * @param {FindingDeleteArgs} args - Arguments to delete one Finding.
     * @example
     * // Delete one Finding
     * const Finding = await prisma.finding.delete({
     *   where: {
     *     // ... filter to delete one Finding
     *   }
     * })
     *
     */
    delete<T extends FindingDeleteArgs>(
      args: SelectSubset<T, FindingDeleteArgs<ExtArgs>>,
    ): Prisma__FindingClient<
      $Result.GetResult<
        Prisma.$FindingPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Finding.
     * @param {FindingUpdateArgs} args - Arguments to update one Finding.
     * @example
     * // Update one Finding
     * const finding = await prisma.finding.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends FindingUpdateArgs>(
      args: SelectSubset<T, FindingUpdateArgs<ExtArgs>>,
    ): Prisma__FindingClient<
      $Result.GetResult<
        Prisma.$FindingPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Findings.
     * @param {FindingDeleteManyArgs} args - Arguments to filter Findings to delete.
     * @example
     * // Delete a few Findings
     * const { count } = await prisma.finding.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends FindingDeleteManyArgs>(
      args?: SelectSubset<T, FindingDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Findings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FindingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Findings
     * const finding = await prisma.finding.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends FindingUpdateManyArgs>(
      args: SelectSubset<T, FindingUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one Finding.
     * @param {FindingUpsertArgs} args - Arguments to update or create a Finding.
     * @example
     * // Update or create a Finding
     * const finding = await prisma.finding.upsert({
     *   create: {
     *     // ... data to create a Finding
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Finding we want to update
     *   }
     * })
     */
    upsert<T extends FindingUpsertArgs>(
      args: SelectSubset<T, FindingUpsertArgs<ExtArgs>>,
    ): Prisma__FindingClient<
      $Result.GetResult<
        Prisma.$FindingPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Findings that matches the filter.
     * @param {FindingFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const finding = await prisma.finding.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: FindingFindRawArgs): Prisma.PrismaPromise<JsonObject>;

    /**
     * Perform aggregation operations on a Finding.
     * @param {FindingAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const finding = await prisma.finding.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(
      args?: FindingAggregateRawArgs,
    ): Prisma.PrismaPromise<JsonObject>;

    /**
     * Count the number of Findings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FindingCountArgs} args - Arguments to filter Findings to count.
     * @example
     * // Count the number of Findings
     * const count = await prisma.finding.count({
     *   where: {
     *     // ... the filter for the Findings we want to count
     *   }
     * })
     **/
    count<T extends FindingCountArgs>(
      args?: Subset<T, FindingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], FindingCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Finding.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FindingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends FindingAggregateArgs>(
      args: Subset<T, FindingAggregateArgs>,
    ): Prisma.PrismaPromise<GetFindingAggregateType<T>>;

    /**
     * Group by Finding.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FindingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends FindingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FindingGroupByArgs["orderBy"] }
        : { orderBy?: FindingGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, FindingGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetFindingGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Finding model
     */
    readonly fields: FindingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Finding.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FindingClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    claim<T extends FactcheckClaimDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, FactcheckClaimDefaultArgs<ExtArgs>>,
    ): Prisma__FactcheckClaimClient<
      | $Result.GetResult<
          Prisma.$FactcheckClaimPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Finding model
   */
  interface FindingFieldRefs {
    readonly id: FieldRef<"Finding", "String">;
    readonly claimId: FieldRef<"Finding", "String">;
    readonly summary: FieldRef<"Finding", "String">;
    readonly outcome: FieldRef<"Finding", "String">;
    readonly rationale: FieldRef<"Finding", "String">;
    readonly metrics: FieldRef<"Finding", "Json">;
    readonly comparedJurisdictions: FieldRef<"Finding", "Json">;
    readonly lastChecked: FieldRef<"Finding", "DateTime">;
    readonly createdAt: FieldRef<"Finding", "DateTime">;
    readonly updatedAt: FieldRef<"Finding", "DateTime">;
  }

  // Custom InputTypes
  /**
   * Finding findUnique
   */
  export type FindingFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Finding
     */
    select?: FindingSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Finding
     */
    omit?: FindingOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FindingInclude<ExtArgs> | null;
    /**
     * Filter, which Finding to fetch.
     */
    where: FindingWhereUniqueInput;
  };

  /**
   * Finding findUniqueOrThrow
   */
  export type FindingFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Finding
     */
    select?: FindingSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Finding
     */
    omit?: FindingOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FindingInclude<ExtArgs> | null;
    /**
     * Filter, which Finding to fetch.
     */
    where: FindingWhereUniqueInput;
  };

  /**
   * Finding findFirst
   */
  export type FindingFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Finding
     */
    select?: FindingSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Finding
     */
    omit?: FindingOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FindingInclude<ExtArgs> | null;
    /**
     * Filter, which Finding to fetch.
     */
    where?: FindingWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Findings to fetch.
     */
    orderBy?:
      | FindingOrderByWithRelationInput
      | FindingOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Findings.
     */
    cursor?: FindingWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Findings from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Findings.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Findings.
     */
    distinct?: FindingScalarFieldEnum | FindingScalarFieldEnum[];
  };

  /**
   * Finding findFirstOrThrow
   */
  export type FindingFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Finding
     */
    select?: FindingSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Finding
     */
    omit?: FindingOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FindingInclude<ExtArgs> | null;
    /**
     * Filter, which Finding to fetch.
     */
    where?: FindingWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Findings to fetch.
     */
    orderBy?:
      | FindingOrderByWithRelationInput
      | FindingOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Findings.
     */
    cursor?: FindingWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Findings from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Findings.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Findings.
     */
    distinct?: FindingScalarFieldEnum | FindingScalarFieldEnum[];
  };

  /**
   * Finding findMany
   */
  export type FindingFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Finding
     */
    select?: FindingSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Finding
     */
    omit?: FindingOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FindingInclude<ExtArgs> | null;
    /**
     * Filter, which Findings to fetch.
     */
    where?: FindingWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Findings to fetch.
     */
    orderBy?:
      | FindingOrderByWithRelationInput
      | FindingOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Findings.
     */
    cursor?: FindingWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Findings from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Findings.
     */
    skip?: number;
    distinct?: FindingScalarFieldEnum | FindingScalarFieldEnum[];
  };

  /**
   * Finding create
   */
  export type FindingCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Finding
     */
    select?: FindingSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Finding
     */
    omit?: FindingOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FindingInclude<ExtArgs> | null;
    /**
     * The data needed to create a Finding.
     */
    data: XOR<FindingCreateInput, FindingUncheckedCreateInput>;
  };

  /**
   * Finding createMany
   */
  export type FindingCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Findings.
     */
    data: FindingCreateManyInput | FindingCreateManyInput[];
  };

  /**
   * Finding update
   */
  export type FindingUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Finding
     */
    select?: FindingSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Finding
     */
    omit?: FindingOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FindingInclude<ExtArgs> | null;
    /**
     * The data needed to update a Finding.
     */
    data: XOR<FindingUpdateInput, FindingUncheckedUpdateInput>;
    /**
     * Choose, which Finding to update.
     */
    where: FindingWhereUniqueInput;
  };

  /**
   * Finding updateMany
   */
  export type FindingUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Findings.
     */
    data: XOR<FindingUpdateManyMutationInput, FindingUncheckedUpdateManyInput>;
    /**
     * Filter which Findings to update
     */
    where?: FindingWhereInput;
    /**
     * Limit how many Findings to update.
     */
    limit?: number;
  };

  /**
   * Finding upsert
   */
  export type FindingUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Finding
     */
    select?: FindingSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Finding
     */
    omit?: FindingOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FindingInclude<ExtArgs> | null;
    /**
     * The filter to search for the Finding to update in case it exists.
     */
    where: FindingWhereUniqueInput;
    /**
     * In case the Finding found by the `where` argument doesn't exist, create a new Finding with this data.
     */
    create: XOR<FindingCreateInput, FindingUncheckedCreateInput>;
    /**
     * In case the Finding was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FindingUpdateInput, FindingUncheckedUpdateInput>;
  };

  /**
   * Finding delete
   */
  export type FindingDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Finding
     */
    select?: FindingSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Finding
     */
    omit?: FindingOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FindingInclude<ExtArgs> | null;
    /**
     * Filter which Finding to delete.
     */
    where: FindingWhereUniqueInput;
  };

  /**
   * Finding deleteMany
   */
  export type FindingDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Findings to delete
     */
    where?: FindingWhereInput;
    /**
     * Limit how many Findings to delete.
     */
    limit?: number;
  };

  /**
   * Finding findRaw
   */
  export type FindingFindRawArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue;
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue;
  };

  /**
   * Finding aggregateRaw
   */
  export type FindingAggregateRawArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[];
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue;
  };

  /**
   * Finding without action
   */
  export type FindingDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Finding
     */
    select?: FindingSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Finding
     */
    omit?: FindingOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FindingInclude<ExtArgs> | null;
  };

  /**
   * Model AdminSettings
   */

  export type AggregateAdminSettings = {
    _count: AdminSettingsCountAggregateOutputType | null;
    _min: AdminSettingsMinAggregateOutputType | null;
    _max: AdminSettingsMaxAggregateOutputType | null;
  };

  export type AdminSettingsMinAggregateOutputType = {
    id: string | null;
    updatedAt: Date | null;
  };

  export type AdminSettingsMaxAggregateOutputType = {
    id: string | null;
    updatedAt: Date | null;
  };

  export type AdminSettingsCountAggregateOutputType = {
    id: number;
    onboarding: number;
    csp: number;
    updatedAt: number;
    _all: number;
  };

  export type AdminSettingsMinAggregateInputType = {
    id?: true;
    updatedAt?: true;
  };

  export type AdminSettingsMaxAggregateInputType = {
    id?: true;
    updatedAt?: true;
  };

  export type AdminSettingsCountAggregateInputType = {
    id?: true;
    onboarding?: true;
    csp?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type AdminSettingsAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which AdminSettings to aggregate.
     */
    where?: AdminSettingsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AdminSettings to fetch.
     */
    orderBy?:
      | AdminSettingsOrderByWithRelationInput
      | AdminSettingsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: AdminSettingsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AdminSettings from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AdminSettings.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned AdminSettings
     **/
    _count?: true | AdminSettingsCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: AdminSettingsMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: AdminSettingsMaxAggregateInputType;
  };

  export type GetAdminSettingsAggregateType<
    T extends AdminSettingsAggregateArgs,
  > = {
    [P in keyof T & keyof AggregateAdminSettings]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdminSettings[P]>
      : GetScalarType<T[P], AggregateAdminSettings[P]>;
  };

  export type AdminSettingsGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: AdminSettingsWhereInput;
    orderBy?:
      | AdminSettingsOrderByWithAggregationInput
      | AdminSettingsOrderByWithAggregationInput[];
    by: AdminSettingsScalarFieldEnum[] | AdminSettingsScalarFieldEnum;
    having?: AdminSettingsScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: AdminSettingsCountAggregateInputType | true;
    _min?: AdminSettingsMinAggregateInputType;
    _max?: AdminSettingsMaxAggregateInputType;
  };

  export type AdminSettingsGroupByOutputType = {
    id: string;
    onboarding: JsonValue | null;
    csp: JsonValue | null;
    updatedAt: Date;
    _count: AdminSettingsCountAggregateOutputType | null;
    _min: AdminSettingsMinAggregateOutputType | null;
    _max: AdminSettingsMaxAggregateOutputType | null;
  };

  type GetAdminSettingsGroupByPayload<T extends AdminSettingsGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<AdminSettingsGroupByOutputType, T["by"]> & {
          [P in keyof T &
            keyof AdminSettingsGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminSettingsGroupByOutputType[P]>
            : GetScalarType<T[P], AdminSettingsGroupByOutputType[P]>;
        }
      >
    >;

  export type AdminSettingsSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      onboarding?: boolean;
      csp?: boolean;
      updatedAt?: boolean;
    },
    ExtArgs["result"]["adminSettings"]
  >;

  export type AdminSettingsSelectScalar = {
    id?: boolean;
    onboarding?: boolean;
    csp?: boolean;
    updatedAt?: boolean;
  };

  export type AdminSettingsOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    "id" | "onboarding" | "csp" | "updatedAt",
    ExtArgs["result"]["adminSettings"]
  >;

  export type $AdminSettingsPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "AdminSettings";
    objects: {};
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        onboarding: Prisma.JsonValue | null;
        csp: Prisma.JsonValue | null;
        updatedAt: Date;
      },
      ExtArgs["result"]["adminSettings"]
    >;
    composites: {};
  };

  type AdminSettingsGetPayload<
    S extends boolean | null | undefined | AdminSettingsDefaultArgs,
  > = $Result.GetResult<Prisma.$AdminSettingsPayload, S>;

  type AdminSettingsCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    AdminSettingsFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: AdminSettingsCountAggregateInputType | true;
  };

  export interface AdminSettingsDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["AdminSettings"];
      meta: { name: "AdminSettings" };
    };
    /**
     * Find zero or one AdminSettings that matches the filter.
     * @param {AdminSettingsFindUniqueArgs} args - Arguments to find a AdminSettings
     * @example
     * // Get one AdminSettings
     * const adminSettings = await prisma.adminSettings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminSettingsFindUniqueArgs>(
      args: SelectSubset<T, AdminSettingsFindUniqueArgs<ExtArgs>>,
    ): Prisma__AdminSettingsClient<
      $Result.GetResult<
        Prisma.$AdminSettingsPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one AdminSettings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdminSettingsFindUniqueOrThrowArgs} args - Arguments to find a AdminSettings
     * @example
     * // Get one AdminSettings
     * const adminSettings = await prisma.adminSettings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminSettingsFindUniqueOrThrowArgs>(
      args: SelectSubset<T, AdminSettingsFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__AdminSettingsClient<
      $Result.GetResult<
        Prisma.$AdminSettingsPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first AdminSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminSettingsFindFirstArgs} args - Arguments to find a AdminSettings
     * @example
     * // Get one AdminSettings
     * const adminSettings = await prisma.adminSettings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminSettingsFindFirstArgs>(
      args?: SelectSubset<T, AdminSettingsFindFirstArgs<ExtArgs>>,
    ): Prisma__AdminSettingsClient<
      $Result.GetResult<
        Prisma.$AdminSettingsPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first AdminSettings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminSettingsFindFirstOrThrowArgs} args - Arguments to find a AdminSettings
     * @example
     * // Get one AdminSettings
     * const adminSettings = await prisma.adminSettings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminSettingsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, AdminSettingsFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__AdminSettingsClient<
      $Result.GetResult<
        Prisma.$AdminSettingsPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more AdminSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminSettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdminSettings
     * const adminSettings = await prisma.adminSettings.findMany()
     *
     * // Get first 10 AdminSettings
     * const adminSettings = await prisma.adminSettings.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const adminSettingsWithIdOnly = await prisma.adminSettings.findMany({ select: { id: true } })
     *
     */
    findMany<T extends AdminSettingsFindManyArgs>(
      args?: SelectSubset<T, AdminSettingsFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$AdminSettingsPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a AdminSettings.
     * @param {AdminSettingsCreateArgs} args - Arguments to create a AdminSettings.
     * @example
     * // Create one AdminSettings
     * const AdminSettings = await prisma.adminSettings.create({
     *   data: {
     *     // ... data to create a AdminSettings
     *   }
     * })
     *
     */
    create<T extends AdminSettingsCreateArgs>(
      args: SelectSubset<T, AdminSettingsCreateArgs<ExtArgs>>,
    ): Prisma__AdminSettingsClient<
      $Result.GetResult<
        Prisma.$AdminSettingsPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many AdminSettings.
     * @param {AdminSettingsCreateManyArgs} args - Arguments to create many AdminSettings.
     * @example
     * // Create many AdminSettings
     * const adminSettings = await prisma.adminSettings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends AdminSettingsCreateManyArgs>(
      args?: SelectSubset<T, AdminSettingsCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a AdminSettings.
     * @param {AdminSettingsDeleteArgs} args - Arguments to delete one AdminSettings.
     * @example
     * // Delete one AdminSettings
     * const AdminSettings = await prisma.adminSettings.delete({
     *   where: {
     *     // ... filter to delete one AdminSettings
     *   }
     * })
     *
     */
    delete<T extends AdminSettingsDeleteArgs>(
      args: SelectSubset<T, AdminSettingsDeleteArgs<ExtArgs>>,
    ): Prisma__AdminSettingsClient<
      $Result.GetResult<
        Prisma.$AdminSettingsPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one AdminSettings.
     * @param {AdminSettingsUpdateArgs} args - Arguments to update one AdminSettings.
     * @example
     * // Update one AdminSettings
     * const adminSettings = await prisma.adminSettings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends AdminSettingsUpdateArgs>(
      args: SelectSubset<T, AdminSettingsUpdateArgs<ExtArgs>>,
    ): Prisma__AdminSettingsClient<
      $Result.GetResult<
        Prisma.$AdminSettingsPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more AdminSettings.
     * @param {AdminSettingsDeleteManyArgs} args - Arguments to filter AdminSettings to delete.
     * @example
     * // Delete a few AdminSettings
     * const { count } = await prisma.adminSettings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends AdminSettingsDeleteManyArgs>(
      args?: SelectSubset<T, AdminSettingsDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more AdminSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminSettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdminSettings
     * const adminSettings = await prisma.adminSettings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends AdminSettingsUpdateManyArgs>(
      args: SelectSubset<T, AdminSettingsUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one AdminSettings.
     * @param {AdminSettingsUpsertArgs} args - Arguments to update or create a AdminSettings.
     * @example
     * // Update or create a AdminSettings
     * const adminSettings = await prisma.adminSettings.upsert({
     *   create: {
     *     // ... data to create a AdminSettings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdminSettings we want to update
     *   }
     * })
     */
    upsert<T extends AdminSettingsUpsertArgs>(
      args: SelectSubset<T, AdminSettingsUpsertArgs<ExtArgs>>,
    ): Prisma__AdminSettingsClient<
      $Result.GetResult<
        Prisma.$AdminSettingsPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more AdminSettings that matches the filter.
     * @param {AdminSettingsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const adminSettings = await prisma.adminSettings.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: AdminSettingsFindRawArgs): Prisma.PrismaPromise<JsonObject>;

    /**
     * Perform aggregation operations on a AdminSettings.
     * @param {AdminSettingsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const adminSettings = await prisma.adminSettings.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(
      args?: AdminSettingsAggregateRawArgs,
    ): Prisma.PrismaPromise<JsonObject>;

    /**
     * Count the number of AdminSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminSettingsCountArgs} args - Arguments to filter AdminSettings to count.
     * @example
     * // Count the number of AdminSettings
     * const count = await prisma.adminSettings.count({
     *   where: {
     *     // ... the filter for the AdminSettings we want to count
     *   }
     * })
     **/
    count<T extends AdminSettingsCountArgs>(
      args?: Subset<T, AdminSettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], AdminSettingsCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a AdminSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminSettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends AdminSettingsAggregateArgs>(
      args: Subset<T, AdminSettingsAggregateArgs>,
    ): Prisma.PrismaPromise<GetAdminSettingsAggregateType<T>>;

    /**
     * Group by AdminSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminSettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends AdminSettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminSettingsGroupByArgs["orderBy"] }
        : { orderBy?: AdminSettingsGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, AdminSettingsGroupByArgs, OrderByArg> &
        InputErrors,
    ): {} extends InputErrors
      ? GetAdminSettingsGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the AdminSettings model
     */
    readonly fields: AdminSettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdminSettings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminSettingsClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the AdminSettings model
   */
  interface AdminSettingsFieldRefs {
    readonly id: FieldRef<"AdminSettings", "String">;
    readonly onboarding: FieldRef<"AdminSettings", "Json">;
    readonly csp: FieldRef<"AdminSettings", "Json">;
    readonly updatedAt: FieldRef<"AdminSettings", "DateTime">;
  }

  // Custom InputTypes
  /**
   * AdminSettings findUnique
   */
  export type AdminSettingsFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AdminSettings
     */
    select?: AdminSettingsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AdminSettings
     */
    omit?: AdminSettingsOmit<ExtArgs> | null;
    /**
     * Filter, which AdminSettings to fetch.
     */
    where: AdminSettingsWhereUniqueInput;
  };

  /**
   * AdminSettings findUniqueOrThrow
   */
  export type AdminSettingsFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AdminSettings
     */
    select?: AdminSettingsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AdminSettings
     */
    omit?: AdminSettingsOmit<ExtArgs> | null;
    /**
     * Filter, which AdminSettings to fetch.
     */
    where: AdminSettingsWhereUniqueInput;
  };

  /**
   * AdminSettings findFirst
   */
  export type AdminSettingsFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AdminSettings
     */
    select?: AdminSettingsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AdminSettings
     */
    omit?: AdminSettingsOmit<ExtArgs> | null;
    /**
     * Filter, which AdminSettings to fetch.
     */
    where?: AdminSettingsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AdminSettings to fetch.
     */
    orderBy?:
      | AdminSettingsOrderByWithRelationInput
      | AdminSettingsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for AdminSettings.
     */
    cursor?: AdminSettingsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AdminSettings from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AdminSettings.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of AdminSettings.
     */
    distinct?: AdminSettingsScalarFieldEnum | AdminSettingsScalarFieldEnum[];
  };

  /**
   * AdminSettings findFirstOrThrow
   */
  export type AdminSettingsFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AdminSettings
     */
    select?: AdminSettingsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AdminSettings
     */
    omit?: AdminSettingsOmit<ExtArgs> | null;
    /**
     * Filter, which AdminSettings to fetch.
     */
    where?: AdminSettingsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AdminSettings to fetch.
     */
    orderBy?:
      | AdminSettingsOrderByWithRelationInput
      | AdminSettingsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for AdminSettings.
     */
    cursor?: AdminSettingsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AdminSettings from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AdminSettings.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of AdminSettings.
     */
    distinct?: AdminSettingsScalarFieldEnum | AdminSettingsScalarFieldEnum[];
  };

  /**
   * AdminSettings findMany
   */
  export type AdminSettingsFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AdminSettings
     */
    select?: AdminSettingsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AdminSettings
     */
    omit?: AdminSettingsOmit<ExtArgs> | null;
    /**
     * Filter, which AdminSettings to fetch.
     */
    where?: AdminSettingsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AdminSettings to fetch.
     */
    orderBy?:
      | AdminSettingsOrderByWithRelationInput
      | AdminSettingsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing AdminSettings.
     */
    cursor?: AdminSettingsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AdminSettings from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AdminSettings.
     */
    skip?: number;
    distinct?: AdminSettingsScalarFieldEnum | AdminSettingsScalarFieldEnum[];
  };

  /**
   * AdminSettings create
   */
  export type AdminSettingsCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AdminSettings
     */
    select?: AdminSettingsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AdminSettings
     */
    omit?: AdminSettingsOmit<ExtArgs> | null;
    /**
     * The data needed to create a AdminSettings.
     */
    data: XOR<AdminSettingsCreateInput, AdminSettingsUncheckedCreateInput>;
  };

  /**
   * AdminSettings createMany
   */
  export type AdminSettingsCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many AdminSettings.
     */
    data: AdminSettingsCreateManyInput | AdminSettingsCreateManyInput[];
  };

  /**
   * AdminSettings update
   */
  export type AdminSettingsUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AdminSettings
     */
    select?: AdminSettingsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AdminSettings
     */
    omit?: AdminSettingsOmit<ExtArgs> | null;
    /**
     * The data needed to update a AdminSettings.
     */
    data: XOR<AdminSettingsUpdateInput, AdminSettingsUncheckedUpdateInput>;
    /**
     * Choose, which AdminSettings to update.
     */
    where: AdminSettingsWhereUniqueInput;
  };

  /**
   * AdminSettings updateMany
   */
  export type AdminSettingsUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update AdminSettings.
     */
    data: XOR<
      AdminSettingsUpdateManyMutationInput,
      AdminSettingsUncheckedUpdateManyInput
    >;
    /**
     * Filter which AdminSettings to update
     */
    where?: AdminSettingsWhereInput;
    /**
     * Limit how many AdminSettings to update.
     */
    limit?: number;
  };

  /**
   * AdminSettings upsert
   */
  export type AdminSettingsUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AdminSettings
     */
    select?: AdminSettingsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AdminSettings
     */
    omit?: AdminSettingsOmit<ExtArgs> | null;
    /**
     * The filter to search for the AdminSettings to update in case it exists.
     */
    where: AdminSettingsWhereUniqueInput;
    /**
     * In case the AdminSettings found by the `where` argument doesn't exist, create a new AdminSettings with this data.
     */
    create: XOR<AdminSettingsCreateInput, AdminSettingsUncheckedCreateInput>;
    /**
     * In case the AdminSettings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminSettingsUpdateInput, AdminSettingsUncheckedUpdateInput>;
  };

  /**
   * AdminSettings delete
   */
  export type AdminSettingsDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AdminSettings
     */
    select?: AdminSettingsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AdminSettings
     */
    omit?: AdminSettingsOmit<ExtArgs> | null;
    /**
     * Filter which AdminSettings to delete.
     */
    where: AdminSettingsWhereUniqueInput;
  };

  /**
   * AdminSettings deleteMany
   */
  export type AdminSettingsDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which AdminSettings to delete
     */
    where?: AdminSettingsWhereInput;
    /**
     * Limit how many AdminSettings to delete.
     */
    limit?: number;
  };

  /**
   * AdminSettings findRaw
   */
  export type AdminSettingsFindRawArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue;
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue;
  };

  /**
   * AdminSettings aggregateRaw
   */
  export type AdminSettingsAggregateRawArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[];
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue;
  };

  /**
   * AdminSettings without action
   */
  export type AdminSettingsDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AdminSettings
     */
    select?: AdminSettingsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AdminSettings
     */
    omit?: AdminSettingsOmit<ExtArgs> | null;
  };

  /**
   * Enums
   */

  export const TopicScalarFieldEnum: {
    id: "id";
    slug: "slug";
    title: "title";
    description: "description";
    locale: "locale";
    createdAt: "createdAt";
    updatedAt: "updatedAt";
  };

  export type TopicScalarFieldEnum =
    (typeof TopicScalarFieldEnum)[keyof typeof TopicScalarFieldEnum];

  export const TagScalarFieldEnum: {
    id: "id";
    slug: "slug";
    label: "label";
  };

  export type TagScalarFieldEnum =
    (typeof TagScalarFieldEnum)[keyof typeof TagScalarFieldEnum];

  export const TopicTagScalarFieldEnum: {
    id: "id";
    topicId: "topicId";
    tagId: "tagId";
  };

  export type TopicTagScalarFieldEnum =
    (typeof TopicTagScalarFieldEnum)[keyof typeof TopicTagScalarFieldEnum];

  export const ItemTagScalarFieldEnum: {
    id: "id";
    itemId: "itemId";
    tagId: "tagId";
  };

  export type ItemTagScalarFieldEnum =
    (typeof ItemTagScalarFieldEnum)[keyof typeof ItemTagScalarFieldEnum];

  export const RegionScalarFieldEnum: {
    id: "id";
    code: "code";
    name: "name";
    level: "level";
    parentId: "parentId";
    meta: "meta";
    createdAt: "createdAt";
    updatedAt: "updatedAt";
  };

  export type RegionScalarFieldEnum =
    (typeof RegionScalarFieldEnum)[keyof typeof RegionScalarFieldEnum];

  export const RegionClosureScalarFieldEnum: {
    id: "id";
    ancestorId: "ancestorId";
    descendantId: "descendantId";
    depth: "depth";
  };

  export type RegionClosureScalarFieldEnum =
    (typeof RegionClosureScalarFieldEnum)[keyof typeof RegionClosureScalarFieldEnum];

  export const ContentItemScalarFieldEnum: {
    id: "id";
    kind: "kind";
    topicId: "topicId";
    locale: "locale";
    title: "title";
    text: "text";
    richText: "richText";
    sortOrder: "sortOrder";
    status: "status";
    authorName: "authorName";
    createdAt: "createdAt";
    updatedAt: "updatedAt";
    publishAt: "publishAt";
    expireAt: "expireAt";
    regionMode: "regionMode";
    regionManualId: "regionManualId";
    regionAuto: "regionAuto";
    regionEffectiveId: "regionEffectiveId";
    validation: "validation";
    meta: "meta";
  };

  export type ContentItemScalarFieldEnum =
    (typeof ContentItemScalarFieldEnum)[keyof typeof ContentItemScalarFieldEnum];

  export const AnswerOptionScalarFieldEnum: {
    id: "id";
    itemId: "itemId";
    label: "label";
    value: "value";
    sortOrder: "sortOrder";
    exclusive: "exclusive";
    meta: "meta";
  };

  export type AnswerOptionScalarFieldEnum =
    (typeof AnswerOptionScalarFieldEnum)[keyof typeof AnswerOptionScalarFieldEnum];

  export const FactcheckJobScalarFieldEnum: {
    id: "id";
    jobId: "jobId";
    contributionId: "contributionId";
    status: "status";
    tokensUsed: "tokensUsed";
    durationMs: "durationMs";
    createdAt: "createdAt";
    updatedAt: "updatedAt";
  };

  export type FactcheckJobScalarFieldEnum =
    (typeof FactcheckJobScalarFieldEnum)[keyof typeof FactcheckJobScalarFieldEnum];

  export const FactcheckClaimScalarFieldEnum: {
    id: "id";
    jobId: "jobId";
    text: "text";
    language: "language";
    topic: "topic";
    falsifiable: "falsifiable";
    frames: "frames";
    rhetoricalFlags: "rhetoricalFlags";
    canonicalKey: "canonicalKey";
    scope: "scope";
    timeframe: "timeframe";
    status: "status";
    createdAt: "createdAt";
    updatedAt: "updatedAt";
  };

  export type FactcheckClaimScalarFieldEnum =
    (typeof FactcheckClaimScalarFieldEnum)[keyof typeof FactcheckClaimScalarFieldEnum];

  export const ProviderRunScalarFieldEnum: {
    id: "id";
    claimId: "claimId";
    provider: "provider";
    verdict: "verdict";
    confidence: "confidence";
    costTokens: "costTokens";
    latencyMs: "latencyMs";
    raw: "raw";
    createdAt: "createdAt";
  };

  export type ProviderRunScalarFieldEnum =
    (typeof ProviderRunScalarFieldEnum)[keyof typeof ProviderRunScalarFieldEnum];

  export const ConsensusRunScalarFieldEnum: {
    id: "id";
    claimId: "claimId";
    method: "method";
    verdict: "verdict";
    confidence: "confidence";
    balanceScore: "balanceScore";
    diversityIndex: "diversityIndex";
    providers: "providers";
    createdAt: "createdAt";
  };

  export type ConsensusRunScalarFieldEnum =
    (typeof ConsensusRunScalarFieldEnum)[keyof typeof ConsensusRunScalarFieldEnum];

  export const EvidenceScalarFieldEnum: {
    id: "id";
    claimId: "claimId";
    url: "url";
    domain: "domain";
    stance: "stance";
    snapshotHash: "snapshotHash";
    firstSeenAt: "firstSeenAt";
    trustScore: "trustScore";
  };

  export type EvidenceScalarFieldEnum =
    (typeof EvidenceScalarFieldEnum)[keyof typeof EvidenceScalarFieldEnum];

  export const VerdictVersionScalarFieldEnum: {
    id: "id";
    claimId: "claimId";
    verdict: "verdict";
    confidence: "confidence";
    asOf: "asOf";
    supersedes: "supersedes";
  };

  export type VerdictVersionScalarFieldEnum =
    (typeof VerdictVersionScalarFieldEnum)[keyof typeof VerdictVersionScalarFieldEnum];

  export const FactcheckResultScalarFieldEnum: {
    id: "id";
    jobId: "jobId";
    verdict: "verdict";
    rawOutput: "rawOutput";
    createdAt: "createdAt";
  };

  export type FactcheckResultScalarFieldEnum =
    (typeof FactcheckResultScalarFieldEnum)[keyof typeof FactcheckResultScalarFieldEnum];

  export const AuditLogScalarFieldEnum: {
    id: "id";
    entityType: "entityType";
    entityId: "entityId";
    action: "action";
    actor: "actor";
    at: "at";
    meta: "meta";
  };

  export type AuditLogScalarFieldEnum =
    (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum];

  export const ExtractedUnitScalarFieldEnum: {
    id: "id";
    itemId: "itemId";
    statementId: "statementId";
    kind: "kind";
    text: "text";
    spanStart: "spanStart";
    spanEnd: "spanEnd";
    confidence: "confidence";
    canonicalKey: "canonicalKey";
    scope: "scope";
    timeframe: "timeframe";
    claimId: "claimId";
    interest: "interest";
    triage: "triage";
    editorNote: "editorNote";
    createdAt: "createdAt";
    updatedAt: "updatedAt";
  };

  export type ExtractedUnitScalarFieldEnum =
    (typeof ExtractedUnitScalarFieldEnum)[keyof typeof ExtractedUnitScalarFieldEnum];

  export const FindingScalarFieldEnum: {
    id: "id";
    claimId: "claimId";
    summary: "summary";
    outcome: "outcome";
    rationale: "rationale";
    metrics: "metrics";
    comparedJurisdictions: "comparedJurisdictions";
    lastChecked: "lastChecked";
    createdAt: "createdAt";
    updatedAt: "updatedAt";
  };

  export type FindingScalarFieldEnum =
    (typeof FindingScalarFieldEnum)[keyof typeof FindingScalarFieldEnum];

  export const AdminSettingsScalarFieldEnum: {
    id: "id";
    onboarding: "onboarding";
    csp: "csp";
    updatedAt: "updatedAt";
  };

  export type AdminSettingsScalarFieldEnum =
    (typeof AdminSettingsScalarFieldEnum)[keyof typeof AdminSettingsScalarFieldEnum];

  export const SortOrder: {
    asc: "asc";
    desc: "desc";
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder];

  export const QueryMode: {
    default: "default";
    insensitive: "insensitive";
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode];

  /**
   * Field references
   */

  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "String"
  >;

  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "String[]"
  >;

  /**
   * Reference to a field of type 'Locale'
   */
  export type EnumLocaleFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "Locale"
  >;

  /**
   * Reference to a field of type 'Locale[]'
   */
  export type ListEnumLocaleFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "Locale[]"
  >;

  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "DateTime"
  >;

  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "DateTime[]"
  >;

  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "Int"
  >;

  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "Int[]"
  >;

  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "Json"
  >;

  /**
   * Reference to a field of type 'ContentKind'
   */
  export type EnumContentKindFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "ContentKind"
  >;

  /**
   * Reference to a field of type 'ContentKind[]'
   */
  export type ListEnumContentKindFieldRefInput<$PrismaModel> =
    FieldRefInputType<$PrismaModel, "ContentKind[]">;

  /**
   * Reference to a field of type 'PublishStatus'
   */
  export type EnumPublishStatusFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "PublishStatus"
  >;

  /**
   * Reference to a field of type 'PublishStatus[]'
   */
  export type ListEnumPublishStatusFieldRefInput<$PrismaModel> =
    FieldRefInputType<$PrismaModel, "PublishStatus[]">;

  /**
   * Reference to a field of type 'RegionMode'
   */
  export type EnumRegionModeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "RegionMode"
  >;

  /**
   * Reference to a field of type 'RegionMode[]'
   */
  export type ListEnumRegionModeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "RegionMode[]"
  >;

  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "Boolean"
  >;

  /**
   * Reference to a field of type 'ReviewStatus'
   */
  export type EnumReviewStatusFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "ReviewStatus"
  >;

  /**
   * Reference to a field of type 'ReviewStatus[]'
   */
  export type ListEnumReviewStatusFieldRefInput<$PrismaModel> =
    FieldRefInputType<$PrismaModel, "ReviewStatus[]">;

  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "Float"
  >;

  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "Float[]"
  >;

  /**
   * Reference to a field of type 'Stance'
   */
  export type EnumStanceFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "Stance"
  >;

  /**
   * Reference to a field of type 'Stance[]'
   */
  export type ListEnumStanceFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "Stance[]"
  >;

  /**
   * Reference to a field of type 'UnitKind'
   */
  export type EnumUnitKindFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "UnitKind"
  >;

  /**
   * Reference to a field of type 'UnitKind[]'
   */
  export type ListEnumUnitKindFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "UnitKind[]"
  >;

  /**
   * Reference to a field of type 'Interest'
   */
  export type EnumInterestFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "Interest"
  >;

  /**
   * Reference to a field of type 'Interest[]'
   */
  export type ListEnumInterestFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "Interest[]"
  >;

  /**
   * Reference to a field of type 'Triage'
   */
  export type EnumTriageFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "Triage"
  >;

  /**
   * Reference to a field of type 'Triage[]'
   */
  export type ListEnumTriageFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "Triage[]"
  >;

  /**
   * Deep Input Types
   */

  export type TopicWhereInput = {
    AND?: TopicWhereInput | TopicWhereInput[];
    OR?: TopicWhereInput[];
    NOT?: TopicWhereInput | TopicWhereInput[];
    id?: StringFilter<"Topic"> | string;
    slug?: StringFilter<"Topic"> | string;
    title?: StringFilter<"Topic"> | string;
    description?: StringNullableFilter<"Topic"> | string | null;
    locale?: EnumLocaleFilter<"Topic"> | $Enums.Locale;
    createdAt?: DateTimeFilter<"Topic"> | Date | string;
    updatedAt?: DateTimeFilter<"Topic"> | Date | string;
    items?: ContentItemListRelationFilter;
    tags?: TopicTagListRelationFilter;
  };

  export type TopicOrderByWithRelationInput = {
    id?: SortOrder;
    slug?: SortOrder;
    title?: SortOrder;
    description?: SortOrder;
    locale?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    items?: ContentItemOrderByRelationAggregateInput;
    tags?: TopicTagOrderByRelationAggregateInput;
  };

  export type TopicWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      slug?: string;
      AND?: TopicWhereInput | TopicWhereInput[];
      OR?: TopicWhereInput[];
      NOT?: TopicWhereInput | TopicWhereInput[];
      title?: StringFilter<"Topic"> | string;
      description?: StringNullableFilter<"Topic"> | string | null;
      locale?: EnumLocaleFilter<"Topic"> | $Enums.Locale;
      createdAt?: DateTimeFilter<"Topic"> | Date | string;
      updatedAt?: DateTimeFilter<"Topic"> | Date | string;
      items?: ContentItemListRelationFilter;
      tags?: TopicTagListRelationFilter;
    },
    "id" | "slug"
  >;

  export type TopicOrderByWithAggregationInput = {
    id?: SortOrder;
    slug?: SortOrder;
    title?: SortOrder;
    description?: SortOrder;
    locale?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: TopicCountOrderByAggregateInput;
    _max?: TopicMaxOrderByAggregateInput;
    _min?: TopicMinOrderByAggregateInput;
  };

  export type TopicScalarWhereWithAggregatesInput = {
    AND?:
      | TopicScalarWhereWithAggregatesInput
      | TopicScalarWhereWithAggregatesInput[];
    OR?: TopicScalarWhereWithAggregatesInput[];
    NOT?:
      | TopicScalarWhereWithAggregatesInput
      | TopicScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"Topic"> | string;
    slug?: StringWithAggregatesFilter<"Topic"> | string;
    title?: StringWithAggregatesFilter<"Topic"> | string;
    description?: StringNullableWithAggregatesFilter<"Topic"> | string | null;
    locale?: EnumLocaleWithAggregatesFilter<"Topic"> | $Enums.Locale;
    createdAt?: DateTimeWithAggregatesFilter<"Topic"> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<"Topic"> | Date | string;
  };

  export type TagWhereInput = {
    AND?: TagWhereInput | TagWhereInput[];
    OR?: TagWhereInput[];
    NOT?: TagWhereInput | TagWhereInput[];
    id?: StringFilter<"Tag"> | string;
    slug?: StringFilter<"Tag"> | string;
    label?: StringFilter<"Tag"> | string;
    topics?: TopicTagListRelationFilter;
    items?: ItemTagListRelationFilter;
  };

  export type TagOrderByWithRelationInput = {
    id?: SortOrder;
    slug?: SortOrder;
    label?: SortOrder;
    topics?: TopicTagOrderByRelationAggregateInput;
    items?: ItemTagOrderByRelationAggregateInput;
  };

  export type TagWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      slug?: string;
      AND?: TagWhereInput | TagWhereInput[];
      OR?: TagWhereInput[];
      NOT?: TagWhereInput | TagWhereInput[];
      label?: StringFilter<"Tag"> | string;
      topics?: TopicTagListRelationFilter;
      items?: ItemTagListRelationFilter;
    },
    "id" | "slug"
  >;

  export type TagOrderByWithAggregationInput = {
    id?: SortOrder;
    slug?: SortOrder;
    label?: SortOrder;
    _count?: TagCountOrderByAggregateInput;
    _max?: TagMaxOrderByAggregateInput;
    _min?: TagMinOrderByAggregateInput;
  };

  export type TagScalarWhereWithAggregatesInput = {
    AND?:
      | TagScalarWhereWithAggregatesInput
      | TagScalarWhereWithAggregatesInput[];
    OR?: TagScalarWhereWithAggregatesInput[];
    NOT?:
      | TagScalarWhereWithAggregatesInput
      | TagScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"Tag"> | string;
    slug?: StringWithAggregatesFilter<"Tag"> | string;
    label?: StringWithAggregatesFilter<"Tag"> | string;
  };

  export type TopicTagWhereInput = {
    AND?: TopicTagWhereInput | TopicTagWhereInput[];
    OR?: TopicTagWhereInput[];
    NOT?: TopicTagWhereInput | TopicTagWhereInput[];
    id?: StringFilter<"TopicTag"> | string;
    topicId?: StringFilter<"TopicTag"> | string;
    tagId?: StringFilter<"TopicTag"> | string;
    topic?: XOR<TopicScalarRelationFilter, TopicWhereInput>;
    tag?: XOR<TagScalarRelationFilter, TagWhereInput>;
  };

  export type TopicTagOrderByWithRelationInput = {
    id?: SortOrder;
    topicId?: SortOrder;
    tagId?: SortOrder;
    topic?: TopicOrderByWithRelationInput;
    tag?: TagOrderByWithRelationInput;
  };

  export type TopicTagWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      topicId_tagId?: TopicTagTopicIdTagIdCompoundUniqueInput;
      AND?: TopicTagWhereInput | TopicTagWhereInput[];
      OR?: TopicTagWhereInput[];
      NOT?: TopicTagWhereInput | TopicTagWhereInput[];
      topicId?: StringFilter<"TopicTag"> | string;
      tagId?: StringFilter<"TopicTag"> | string;
      topic?: XOR<TopicScalarRelationFilter, TopicWhereInput>;
      tag?: XOR<TagScalarRelationFilter, TagWhereInput>;
    },
    "id" | "topicId_tagId"
  >;

  export type TopicTagOrderByWithAggregationInput = {
    id?: SortOrder;
    topicId?: SortOrder;
    tagId?: SortOrder;
    _count?: TopicTagCountOrderByAggregateInput;
    _max?: TopicTagMaxOrderByAggregateInput;
    _min?: TopicTagMinOrderByAggregateInput;
  };

  export type TopicTagScalarWhereWithAggregatesInput = {
    AND?:
      | TopicTagScalarWhereWithAggregatesInput
      | TopicTagScalarWhereWithAggregatesInput[];
    OR?: TopicTagScalarWhereWithAggregatesInput[];
    NOT?:
      | TopicTagScalarWhereWithAggregatesInput
      | TopicTagScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"TopicTag"> | string;
    topicId?: StringWithAggregatesFilter<"TopicTag"> | string;
    tagId?: StringWithAggregatesFilter<"TopicTag"> | string;
  };

  export type ItemTagWhereInput = {
    AND?: ItemTagWhereInput | ItemTagWhereInput[];
    OR?: ItemTagWhereInput[];
    NOT?: ItemTagWhereInput | ItemTagWhereInput[];
    id?: StringFilter<"ItemTag"> | string;
    itemId?: StringFilter<"ItemTag"> | string;
    tagId?: StringFilter<"ItemTag"> | string;
    item?: XOR<ContentItemScalarRelationFilter, ContentItemWhereInput>;
    tag?: XOR<TagScalarRelationFilter, TagWhereInput>;
  };

  export type ItemTagOrderByWithRelationInput = {
    id?: SortOrder;
    itemId?: SortOrder;
    tagId?: SortOrder;
    item?: ContentItemOrderByWithRelationInput;
    tag?: TagOrderByWithRelationInput;
  };

  export type ItemTagWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      itemId_tagId?: ItemTagItemIdTagIdCompoundUniqueInput;
      AND?: ItemTagWhereInput | ItemTagWhereInput[];
      OR?: ItemTagWhereInput[];
      NOT?: ItemTagWhereInput | ItemTagWhereInput[];
      itemId?: StringFilter<"ItemTag"> | string;
      tagId?: StringFilter<"ItemTag"> | string;
      item?: XOR<ContentItemScalarRelationFilter, ContentItemWhereInput>;
      tag?: XOR<TagScalarRelationFilter, TagWhereInput>;
    },
    "id" | "itemId_tagId"
  >;

  export type ItemTagOrderByWithAggregationInput = {
    id?: SortOrder;
    itemId?: SortOrder;
    tagId?: SortOrder;
    _count?: ItemTagCountOrderByAggregateInput;
    _max?: ItemTagMaxOrderByAggregateInput;
    _min?: ItemTagMinOrderByAggregateInput;
  };

  export type ItemTagScalarWhereWithAggregatesInput = {
    AND?:
      | ItemTagScalarWhereWithAggregatesInput
      | ItemTagScalarWhereWithAggregatesInput[];
    OR?: ItemTagScalarWhereWithAggregatesInput[];
    NOT?:
      | ItemTagScalarWhereWithAggregatesInput
      | ItemTagScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"ItemTag"> | string;
    itemId?: StringWithAggregatesFilter<"ItemTag"> | string;
    tagId?: StringWithAggregatesFilter<"ItemTag"> | string;
  };

  export type RegionWhereInput = {
    AND?: RegionWhereInput | RegionWhereInput[];
    OR?: RegionWhereInput[];
    NOT?: RegionWhereInput | RegionWhereInput[];
    id?: StringFilter<"Region"> | string;
    code?: StringFilter<"Region"> | string;
    name?: StringFilter<"Region"> | string;
    level?: IntFilter<"Region"> | number;
    parentId?: StringNullableFilter<"Region"> | string | null;
    meta?: JsonNullableFilter<"Region">;
    createdAt?: DateTimeFilter<"Region"> | Date | string;
    updatedAt?: DateTimeFilter<"Region"> | Date | string;
    parent?: XOR<RegionNullableScalarRelationFilter, RegionWhereInput> | null;
    children?: RegionListRelationFilter;
    itemsManual?: ContentItemListRelationFilter;
    itemsEffective?: ContentItemListRelationFilter;
    ancestors?: RegionClosureListRelationFilter;
    descendants?: RegionClosureListRelationFilter;
  };

  export type RegionOrderByWithRelationInput = {
    id?: SortOrder;
    code?: SortOrder;
    name?: SortOrder;
    level?: SortOrder;
    parentId?: SortOrder;
    meta?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    parent?: RegionOrderByWithRelationInput;
    children?: RegionOrderByRelationAggregateInput;
    itemsManual?: ContentItemOrderByRelationAggregateInput;
    itemsEffective?: ContentItemOrderByRelationAggregateInput;
    ancestors?: RegionClosureOrderByRelationAggregateInput;
    descendants?: RegionClosureOrderByRelationAggregateInput;
  };

  export type RegionWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      code?: string;
      AND?: RegionWhereInput | RegionWhereInput[];
      OR?: RegionWhereInput[];
      NOT?: RegionWhereInput | RegionWhereInput[];
      name?: StringFilter<"Region"> | string;
      level?: IntFilter<"Region"> | number;
      parentId?: StringNullableFilter<"Region"> | string | null;
      meta?: JsonNullableFilter<"Region">;
      createdAt?: DateTimeFilter<"Region"> | Date | string;
      updatedAt?: DateTimeFilter<"Region"> | Date | string;
      parent?: XOR<RegionNullableScalarRelationFilter, RegionWhereInput> | null;
      children?: RegionListRelationFilter;
      itemsManual?: ContentItemListRelationFilter;
      itemsEffective?: ContentItemListRelationFilter;
      ancestors?: RegionClosureListRelationFilter;
      descendants?: RegionClosureListRelationFilter;
    },
    "id" | "code"
  >;

  export type RegionOrderByWithAggregationInput = {
    id?: SortOrder;
    code?: SortOrder;
    name?: SortOrder;
    level?: SortOrder;
    parentId?: SortOrder;
    meta?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: RegionCountOrderByAggregateInput;
    _avg?: RegionAvgOrderByAggregateInput;
    _max?: RegionMaxOrderByAggregateInput;
    _min?: RegionMinOrderByAggregateInput;
    _sum?: RegionSumOrderByAggregateInput;
  };

  export type RegionScalarWhereWithAggregatesInput = {
    AND?:
      | RegionScalarWhereWithAggregatesInput
      | RegionScalarWhereWithAggregatesInput[];
    OR?: RegionScalarWhereWithAggregatesInput[];
    NOT?:
      | RegionScalarWhereWithAggregatesInput
      | RegionScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"Region"> | string;
    code?: StringWithAggregatesFilter<"Region"> | string;
    name?: StringWithAggregatesFilter<"Region"> | string;
    level?: IntWithAggregatesFilter<"Region"> | number;
    parentId?: StringNullableWithAggregatesFilter<"Region"> | string | null;
    meta?: JsonNullableWithAggregatesFilter<"Region">;
    createdAt?: DateTimeWithAggregatesFilter<"Region"> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<"Region"> | Date | string;
  };

  export type RegionClosureWhereInput = {
    AND?: RegionClosureWhereInput | RegionClosureWhereInput[];
    OR?: RegionClosureWhereInput[];
    NOT?: RegionClosureWhereInput | RegionClosureWhereInput[];
    id?: StringFilter<"RegionClosure"> | string;
    ancestorId?: StringFilter<"RegionClosure"> | string;
    descendantId?: StringFilter<"RegionClosure"> | string;
    depth?: IntFilter<"RegionClosure"> | number;
    ancestor?: XOR<RegionScalarRelationFilter, RegionWhereInput>;
    descendant?: XOR<RegionScalarRelationFilter, RegionWhereInput>;
  };

  export type RegionClosureOrderByWithRelationInput = {
    id?: SortOrder;
    ancestorId?: SortOrder;
    descendantId?: SortOrder;
    depth?: SortOrder;
    ancestor?: RegionOrderByWithRelationInput;
    descendant?: RegionOrderByWithRelationInput;
  };

  export type RegionClosureWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      ancestorId_descendantId?: RegionClosureAncestorIdDescendantIdCompoundUniqueInput;
      AND?: RegionClosureWhereInput | RegionClosureWhereInput[];
      OR?: RegionClosureWhereInput[];
      NOT?: RegionClosureWhereInput | RegionClosureWhereInput[];
      ancestorId?: StringFilter<"RegionClosure"> | string;
      descendantId?: StringFilter<"RegionClosure"> | string;
      depth?: IntFilter<"RegionClosure"> | number;
      ancestor?: XOR<RegionScalarRelationFilter, RegionWhereInput>;
      descendant?: XOR<RegionScalarRelationFilter, RegionWhereInput>;
    },
    "id" | "ancestorId_descendantId"
  >;

  export type RegionClosureOrderByWithAggregationInput = {
    id?: SortOrder;
    ancestorId?: SortOrder;
    descendantId?: SortOrder;
    depth?: SortOrder;
    _count?: RegionClosureCountOrderByAggregateInput;
    _avg?: RegionClosureAvgOrderByAggregateInput;
    _max?: RegionClosureMaxOrderByAggregateInput;
    _min?: RegionClosureMinOrderByAggregateInput;
    _sum?: RegionClosureSumOrderByAggregateInput;
  };

  export type RegionClosureScalarWhereWithAggregatesInput = {
    AND?:
      | RegionClosureScalarWhereWithAggregatesInput
      | RegionClosureScalarWhereWithAggregatesInput[];
    OR?: RegionClosureScalarWhereWithAggregatesInput[];
    NOT?:
      | RegionClosureScalarWhereWithAggregatesInput
      | RegionClosureScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"RegionClosure"> | string;
    ancestorId?: StringWithAggregatesFilter<"RegionClosure"> | string;
    descendantId?: StringWithAggregatesFilter<"RegionClosure"> | string;
    depth?: IntWithAggregatesFilter<"RegionClosure"> | number;
  };

  export type ContentItemWhereInput = {
    AND?: ContentItemWhereInput | ContentItemWhereInput[];
    OR?: ContentItemWhereInput[];
    NOT?: ContentItemWhereInput | ContentItemWhereInput[];
    id?: StringFilter<"ContentItem"> | string;
    kind?: EnumContentKindFilter<"ContentItem"> | $Enums.ContentKind;
    topicId?: StringFilter<"ContentItem"> | string;
    locale?: EnumLocaleFilter<"ContentItem"> | $Enums.Locale;
    title?: StringNullableFilter<"ContentItem"> | string | null;
    text?: StringFilter<"ContentItem"> | string;
    richText?: StringNullableFilter<"ContentItem"> | string | null;
    sortOrder?: IntFilter<"ContentItem"> | number;
    status?: EnumPublishStatusFilter<"ContentItem"> | $Enums.PublishStatus;
    authorName?: StringNullableFilter<"ContentItem"> | string | null;
    createdAt?: DateTimeFilter<"ContentItem"> | Date | string;
    updatedAt?: DateTimeFilter<"ContentItem"> | Date | string;
    publishAt?: DateTimeNullableFilter<"ContentItem"> | Date | string | null;
    expireAt?: DateTimeNullableFilter<"ContentItem"> | Date | string | null;
    regionMode?: EnumRegionModeFilter<"ContentItem"> | $Enums.RegionMode;
    regionManualId?: StringNullableFilter<"ContentItem"> | string | null;
    regionAuto?: JsonNullableFilter<"ContentItem">;
    regionEffectiveId?: StringNullableFilter<"ContentItem"> | string | null;
    validation?: JsonNullableFilter<"ContentItem">;
    meta?: JsonNullableFilter<"ContentItem">;
    topic?: XOR<TopicScalarRelationFilter, TopicWhereInput>;
    units?: ExtractedUnitListRelationFilter;
    regionManual?: XOR<
      RegionNullableScalarRelationFilter,
      RegionWhereInput
    > | null;
    regionEffective?: XOR<
      RegionNullableScalarRelationFilter,
      RegionWhereInput
    > | null;
    answerOptions?: AnswerOptionListRelationFilter;
    tags?: ItemTagListRelationFilter;
  };

  export type ContentItemOrderByWithRelationInput = {
    id?: SortOrder;
    kind?: SortOrder;
    topicId?: SortOrder;
    locale?: SortOrder;
    title?: SortOrder;
    text?: SortOrder;
    richText?: SortOrder;
    sortOrder?: SortOrder;
    status?: SortOrder;
    authorName?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    publishAt?: SortOrder;
    expireAt?: SortOrder;
    regionMode?: SortOrder;
    regionManualId?: SortOrder;
    regionAuto?: SortOrder;
    regionEffectiveId?: SortOrder;
    validation?: SortOrder;
    meta?: SortOrder;
    topic?: TopicOrderByWithRelationInput;
    units?: ExtractedUnitOrderByRelationAggregateInput;
    regionManual?: RegionOrderByWithRelationInput;
    regionEffective?: RegionOrderByWithRelationInput;
    answerOptions?: AnswerOptionOrderByRelationAggregateInput;
    tags?: ItemTagOrderByRelationAggregateInput;
  };

  export type ContentItemWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: ContentItemWhereInput | ContentItemWhereInput[];
      OR?: ContentItemWhereInput[];
      NOT?: ContentItemWhereInput | ContentItemWhereInput[];
      kind?: EnumContentKindFilter<"ContentItem"> | $Enums.ContentKind;
      topicId?: StringFilter<"ContentItem"> | string;
      locale?: EnumLocaleFilter<"ContentItem"> | $Enums.Locale;
      title?: StringNullableFilter<"ContentItem"> | string | null;
      text?: StringFilter<"ContentItem"> | string;
      richText?: StringNullableFilter<"ContentItem"> | string | null;
      sortOrder?: IntFilter<"ContentItem"> | number;
      status?: EnumPublishStatusFilter<"ContentItem"> | $Enums.PublishStatus;
      authorName?: StringNullableFilter<"ContentItem"> | string | null;
      createdAt?: DateTimeFilter<"ContentItem"> | Date | string;
      updatedAt?: DateTimeFilter<"ContentItem"> | Date | string;
      publishAt?: DateTimeNullableFilter<"ContentItem"> | Date | string | null;
      expireAt?: DateTimeNullableFilter<"ContentItem"> | Date | string | null;
      regionMode?: EnumRegionModeFilter<"ContentItem"> | $Enums.RegionMode;
      regionManualId?: StringNullableFilter<"ContentItem"> | string | null;
      regionAuto?: JsonNullableFilter<"ContentItem">;
      regionEffectiveId?: StringNullableFilter<"ContentItem"> | string | null;
      validation?: JsonNullableFilter<"ContentItem">;
      meta?: JsonNullableFilter<"ContentItem">;
      topic?: XOR<TopicScalarRelationFilter, TopicWhereInput>;
      units?: ExtractedUnitListRelationFilter;
      regionManual?: XOR<
        RegionNullableScalarRelationFilter,
        RegionWhereInput
      > | null;
      regionEffective?: XOR<
        RegionNullableScalarRelationFilter,
        RegionWhereInput
      > | null;
      answerOptions?: AnswerOptionListRelationFilter;
      tags?: ItemTagListRelationFilter;
    },
    "id"
  >;

  export type ContentItemOrderByWithAggregationInput = {
    id?: SortOrder;
    kind?: SortOrder;
    topicId?: SortOrder;
    locale?: SortOrder;
    title?: SortOrder;
    text?: SortOrder;
    richText?: SortOrder;
    sortOrder?: SortOrder;
    status?: SortOrder;
    authorName?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    publishAt?: SortOrder;
    expireAt?: SortOrder;
    regionMode?: SortOrder;
    regionManualId?: SortOrder;
    regionAuto?: SortOrder;
    regionEffectiveId?: SortOrder;
    validation?: SortOrder;
    meta?: SortOrder;
    _count?: ContentItemCountOrderByAggregateInput;
    _avg?: ContentItemAvgOrderByAggregateInput;
    _max?: ContentItemMaxOrderByAggregateInput;
    _min?: ContentItemMinOrderByAggregateInput;
    _sum?: ContentItemSumOrderByAggregateInput;
  };

  export type ContentItemScalarWhereWithAggregatesInput = {
    AND?:
      | ContentItemScalarWhereWithAggregatesInput
      | ContentItemScalarWhereWithAggregatesInput[];
    OR?: ContentItemScalarWhereWithAggregatesInput[];
    NOT?:
      | ContentItemScalarWhereWithAggregatesInput
      | ContentItemScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"ContentItem"> | string;
    kind?:
      | EnumContentKindWithAggregatesFilter<"ContentItem">
      | $Enums.ContentKind;
    topicId?: StringWithAggregatesFilter<"ContentItem"> | string;
    locale?: EnumLocaleWithAggregatesFilter<"ContentItem"> | $Enums.Locale;
    title?: StringNullableWithAggregatesFilter<"ContentItem"> | string | null;
    text?: StringWithAggregatesFilter<"ContentItem"> | string;
    richText?:
      | StringNullableWithAggregatesFilter<"ContentItem">
      | string
      | null;
    sortOrder?: IntWithAggregatesFilter<"ContentItem"> | number;
    status?:
      | EnumPublishStatusWithAggregatesFilter<"ContentItem">
      | $Enums.PublishStatus;
    authorName?:
      | StringNullableWithAggregatesFilter<"ContentItem">
      | string
      | null;
    createdAt?: DateTimeWithAggregatesFilter<"ContentItem"> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<"ContentItem"> | Date | string;
    publishAt?:
      | DateTimeNullableWithAggregatesFilter<"ContentItem">
      | Date
      | string
      | null;
    expireAt?:
      | DateTimeNullableWithAggregatesFilter<"ContentItem">
      | Date
      | string
      | null;
    regionMode?:
      | EnumRegionModeWithAggregatesFilter<"ContentItem">
      | $Enums.RegionMode;
    regionManualId?:
      | StringNullableWithAggregatesFilter<"ContentItem">
      | string
      | null;
    regionAuto?: JsonNullableWithAggregatesFilter<"ContentItem">;
    regionEffectiveId?:
      | StringNullableWithAggregatesFilter<"ContentItem">
      | string
      | null;
    validation?: JsonNullableWithAggregatesFilter<"ContentItem">;
    meta?: JsonNullableWithAggregatesFilter<"ContentItem">;
  };

  export type AnswerOptionWhereInput = {
    AND?: AnswerOptionWhereInput | AnswerOptionWhereInput[];
    OR?: AnswerOptionWhereInput[];
    NOT?: AnswerOptionWhereInput | AnswerOptionWhereInput[];
    id?: StringFilter<"AnswerOption"> | string;
    itemId?: StringFilter<"AnswerOption"> | string;
    label?: StringFilter<"AnswerOption"> | string;
    value?: StringFilter<"AnswerOption"> | string;
    sortOrder?: IntFilter<"AnswerOption"> | number;
    exclusive?: BoolFilter<"AnswerOption"> | boolean;
    meta?: JsonNullableFilter<"AnswerOption">;
    item?: XOR<ContentItemScalarRelationFilter, ContentItemWhereInput>;
  };

  export type AnswerOptionOrderByWithRelationInput = {
    id?: SortOrder;
    itemId?: SortOrder;
    label?: SortOrder;
    value?: SortOrder;
    sortOrder?: SortOrder;
    exclusive?: SortOrder;
    meta?: SortOrder;
    item?: ContentItemOrderByWithRelationInput;
  };

  export type AnswerOptionWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      itemId_sortOrder?: AnswerOptionItemIdSortOrderCompoundUniqueInput;
      itemId_value?: AnswerOptionItemIdValueCompoundUniqueInput;
      AND?: AnswerOptionWhereInput | AnswerOptionWhereInput[];
      OR?: AnswerOptionWhereInput[];
      NOT?: AnswerOptionWhereInput | AnswerOptionWhereInput[];
      itemId?: StringFilter<"AnswerOption"> | string;
      label?: StringFilter<"AnswerOption"> | string;
      value?: StringFilter<"AnswerOption"> | string;
      sortOrder?: IntFilter<"AnswerOption"> | number;
      exclusive?: BoolFilter<"AnswerOption"> | boolean;
      meta?: JsonNullableFilter<"AnswerOption">;
      item?: XOR<ContentItemScalarRelationFilter, ContentItemWhereInput>;
    },
    "id" | "itemId_sortOrder" | "itemId_value"
  >;

  export type AnswerOptionOrderByWithAggregationInput = {
    id?: SortOrder;
    itemId?: SortOrder;
    label?: SortOrder;
    value?: SortOrder;
    sortOrder?: SortOrder;
    exclusive?: SortOrder;
    meta?: SortOrder;
    _count?: AnswerOptionCountOrderByAggregateInput;
    _avg?: AnswerOptionAvgOrderByAggregateInput;
    _max?: AnswerOptionMaxOrderByAggregateInput;
    _min?: AnswerOptionMinOrderByAggregateInput;
    _sum?: AnswerOptionSumOrderByAggregateInput;
  };

  export type AnswerOptionScalarWhereWithAggregatesInput = {
    AND?:
      | AnswerOptionScalarWhereWithAggregatesInput
      | AnswerOptionScalarWhereWithAggregatesInput[];
    OR?: AnswerOptionScalarWhereWithAggregatesInput[];
    NOT?:
      | AnswerOptionScalarWhereWithAggregatesInput
      | AnswerOptionScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"AnswerOption"> | string;
    itemId?: StringWithAggregatesFilter<"AnswerOption"> | string;
    label?: StringWithAggregatesFilter<"AnswerOption"> | string;
    value?: StringWithAggregatesFilter<"AnswerOption"> | string;
    sortOrder?: IntWithAggregatesFilter<"AnswerOption"> | number;
    exclusive?: BoolWithAggregatesFilter<"AnswerOption"> | boolean;
    meta?: JsonNullableWithAggregatesFilter<"AnswerOption">;
  };

  export type FactcheckJobWhereInput = {
    AND?: FactcheckJobWhereInput | FactcheckJobWhereInput[];
    OR?: FactcheckJobWhereInput[];
    NOT?: FactcheckJobWhereInput | FactcheckJobWhereInput[];
    id?: StringFilter<"FactcheckJob"> | string;
    jobId?: StringFilter<"FactcheckJob"> | string;
    contributionId?: StringFilter<"FactcheckJob"> | string;
    status?: StringFilter<"FactcheckJob"> | string;
    tokensUsed?: IntFilter<"FactcheckJob"> | number;
    durationMs?: IntFilter<"FactcheckJob"> | number;
    createdAt?: DateTimeFilter<"FactcheckJob"> | Date | string;
    updatedAt?: DateTimeFilter<"FactcheckJob"> | Date | string;
    claims?: FactcheckClaimListRelationFilter;
    results?: FactcheckResultListRelationFilter;
  };

  export type FactcheckJobOrderByWithRelationInput = {
    id?: SortOrder;
    jobId?: SortOrder;
    contributionId?: SortOrder;
    status?: SortOrder;
    tokensUsed?: SortOrder;
    durationMs?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    claims?: FactcheckClaimOrderByRelationAggregateInput;
    results?: FactcheckResultOrderByRelationAggregateInput;
  };

  export type FactcheckJobWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      jobId?: string;
      AND?: FactcheckJobWhereInput | FactcheckJobWhereInput[];
      OR?: FactcheckJobWhereInput[];
      NOT?: FactcheckJobWhereInput | FactcheckJobWhereInput[];
      contributionId?: StringFilter<"FactcheckJob"> | string;
      status?: StringFilter<"FactcheckJob"> | string;
      tokensUsed?: IntFilter<"FactcheckJob"> | number;
      durationMs?: IntFilter<"FactcheckJob"> | number;
      createdAt?: DateTimeFilter<"FactcheckJob"> | Date | string;
      updatedAt?: DateTimeFilter<"FactcheckJob"> | Date | string;
      claims?: FactcheckClaimListRelationFilter;
      results?: FactcheckResultListRelationFilter;
    },
    "id" | "jobId"
  >;

  export type FactcheckJobOrderByWithAggregationInput = {
    id?: SortOrder;
    jobId?: SortOrder;
    contributionId?: SortOrder;
    status?: SortOrder;
    tokensUsed?: SortOrder;
    durationMs?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: FactcheckJobCountOrderByAggregateInput;
    _avg?: FactcheckJobAvgOrderByAggregateInput;
    _max?: FactcheckJobMaxOrderByAggregateInput;
    _min?: FactcheckJobMinOrderByAggregateInput;
    _sum?: FactcheckJobSumOrderByAggregateInput;
  };

  export type FactcheckJobScalarWhereWithAggregatesInput = {
    AND?:
      | FactcheckJobScalarWhereWithAggregatesInput
      | FactcheckJobScalarWhereWithAggregatesInput[];
    OR?: FactcheckJobScalarWhereWithAggregatesInput[];
    NOT?:
      | FactcheckJobScalarWhereWithAggregatesInput
      | FactcheckJobScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"FactcheckJob"> | string;
    jobId?: StringWithAggregatesFilter<"FactcheckJob"> | string;
    contributionId?: StringWithAggregatesFilter<"FactcheckJob"> | string;
    status?: StringWithAggregatesFilter<"FactcheckJob"> | string;
    tokensUsed?: IntWithAggregatesFilter<"FactcheckJob"> | number;
    durationMs?: IntWithAggregatesFilter<"FactcheckJob"> | number;
    createdAt?: DateTimeWithAggregatesFilter<"FactcheckJob"> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<"FactcheckJob"> | Date | string;
  };

  export type FactcheckClaimWhereInput = {
    AND?: FactcheckClaimWhereInput | FactcheckClaimWhereInput[];
    OR?: FactcheckClaimWhereInput[];
    NOT?: FactcheckClaimWhereInput | FactcheckClaimWhereInput[];
    id?: StringFilter<"FactcheckClaim"> | string;
    jobId?: StringFilter<"FactcheckClaim"> | string;
    text?: StringFilter<"FactcheckClaim"> | string;
    language?: StringNullableFilter<"FactcheckClaim"> | string | null;
    topic?: StringNullableFilter<"FactcheckClaim"> | string | null;
    falsifiable?: BoolFilter<"FactcheckClaim"> | boolean;
    frames?: StringNullableListFilter<"FactcheckClaim">;
    rhetoricalFlags?: StringNullableListFilter<"FactcheckClaim">;
    canonicalKey?: StringFilter<"FactcheckClaim"> | string;
    scope?: StringNullableFilter<"FactcheckClaim"> | string | null;
    timeframe?: StringNullableFilter<"FactcheckClaim"> | string | null;
    status?: EnumReviewStatusFilter<"FactcheckClaim"> | $Enums.ReviewStatus;
    createdAt?: DateTimeFilter<"FactcheckClaim"> | Date | string;
    updatedAt?: DateTimeFilter<"FactcheckClaim"> | Date | string;
    job?: XOR<FactcheckJobScalarRelationFilter, FactcheckJobWhereInput>;
    providerRuns?: ProviderRunListRelationFilter;
    evidences?: EvidenceListRelationFilter;
    consensus?: XOR<
      ConsensusRunNullableScalarRelationFilter,
      ConsensusRunWhereInput
    > | null;
    verdictVersions?: VerdictVersionListRelationFilter;
    units?: ExtractedUnitListRelationFilter;
    finding?: XOR<
      FindingNullableScalarRelationFilter,
      FindingWhereInput
    > | null;
  };

  export type FactcheckClaimOrderByWithRelationInput = {
    id?: SortOrder;
    jobId?: SortOrder;
    text?: SortOrder;
    language?: SortOrder;
    topic?: SortOrder;
    falsifiable?: SortOrder;
    frames?: SortOrder;
    rhetoricalFlags?: SortOrder;
    canonicalKey?: SortOrder;
    scope?: SortOrder;
    timeframe?: SortOrder;
    status?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    job?: FactcheckJobOrderByWithRelationInput;
    providerRuns?: ProviderRunOrderByRelationAggregateInput;
    evidences?: EvidenceOrderByRelationAggregateInput;
    consensus?: ConsensusRunOrderByWithRelationInput;
    verdictVersions?: VerdictVersionOrderByRelationAggregateInput;
    units?: ExtractedUnitOrderByRelationAggregateInput;
    finding?: FindingOrderByWithRelationInput;
  };

  export type FactcheckClaimWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      canonicalKey?: string;
      AND?: FactcheckClaimWhereInput | FactcheckClaimWhereInput[];
      OR?: FactcheckClaimWhereInput[];
      NOT?: FactcheckClaimWhereInput | FactcheckClaimWhereInput[];
      jobId?: StringFilter<"FactcheckClaim"> | string;
      text?: StringFilter<"FactcheckClaim"> | string;
      language?: StringNullableFilter<"FactcheckClaim"> | string | null;
      topic?: StringNullableFilter<"FactcheckClaim"> | string | null;
      falsifiable?: BoolFilter<"FactcheckClaim"> | boolean;
      frames?: StringNullableListFilter<"FactcheckClaim">;
      rhetoricalFlags?: StringNullableListFilter<"FactcheckClaim">;
      scope?: StringNullableFilter<"FactcheckClaim"> | string | null;
      timeframe?: StringNullableFilter<"FactcheckClaim"> | string | null;
      status?: EnumReviewStatusFilter<"FactcheckClaim"> | $Enums.ReviewStatus;
      createdAt?: DateTimeFilter<"FactcheckClaim"> | Date | string;
      updatedAt?: DateTimeFilter<"FactcheckClaim"> | Date | string;
      job?: XOR<FactcheckJobScalarRelationFilter, FactcheckJobWhereInput>;
      providerRuns?: ProviderRunListRelationFilter;
      evidences?: EvidenceListRelationFilter;
      consensus?: XOR<
        ConsensusRunNullableScalarRelationFilter,
        ConsensusRunWhereInput
      > | null;
      verdictVersions?: VerdictVersionListRelationFilter;
      units?: ExtractedUnitListRelationFilter;
      finding?: XOR<
        FindingNullableScalarRelationFilter,
        FindingWhereInput
      > | null;
    },
    "id" | "canonicalKey"
  >;

  export type FactcheckClaimOrderByWithAggregationInput = {
    id?: SortOrder;
    jobId?: SortOrder;
    text?: SortOrder;
    language?: SortOrder;
    topic?: SortOrder;
    falsifiable?: SortOrder;
    frames?: SortOrder;
    rhetoricalFlags?: SortOrder;
    canonicalKey?: SortOrder;
    scope?: SortOrder;
    timeframe?: SortOrder;
    status?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: FactcheckClaimCountOrderByAggregateInput;
    _max?: FactcheckClaimMaxOrderByAggregateInput;
    _min?: FactcheckClaimMinOrderByAggregateInput;
  };

  export type FactcheckClaimScalarWhereWithAggregatesInput = {
    AND?:
      | FactcheckClaimScalarWhereWithAggregatesInput
      | FactcheckClaimScalarWhereWithAggregatesInput[];
    OR?: FactcheckClaimScalarWhereWithAggregatesInput[];
    NOT?:
      | FactcheckClaimScalarWhereWithAggregatesInput
      | FactcheckClaimScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"FactcheckClaim"> | string;
    jobId?: StringWithAggregatesFilter<"FactcheckClaim"> | string;
    text?: StringWithAggregatesFilter<"FactcheckClaim"> | string;
    language?:
      | StringNullableWithAggregatesFilter<"FactcheckClaim">
      | string
      | null;
    topic?:
      | StringNullableWithAggregatesFilter<"FactcheckClaim">
      | string
      | null;
    falsifiable?: BoolWithAggregatesFilter<"FactcheckClaim"> | boolean;
    frames?: StringNullableListFilter<"FactcheckClaim">;
    rhetoricalFlags?: StringNullableListFilter<"FactcheckClaim">;
    canonicalKey?: StringWithAggregatesFilter<"FactcheckClaim"> | string;
    scope?:
      | StringNullableWithAggregatesFilter<"FactcheckClaim">
      | string
      | null;
    timeframe?:
      | StringNullableWithAggregatesFilter<"FactcheckClaim">
      | string
      | null;
    status?:
      | EnumReviewStatusWithAggregatesFilter<"FactcheckClaim">
      | $Enums.ReviewStatus;
    createdAt?: DateTimeWithAggregatesFilter<"FactcheckClaim"> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<"FactcheckClaim"> | Date | string;
  };

  export type ProviderRunWhereInput = {
    AND?: ProviderRunWhereInput | ProviderRunWhereInput[];
    OR?: ProviderRunWhereInput[];
    NOT?: ProviderRunWhereInput | ProviderRunWhereInput[];
    id?: StringFilter<"ProviderRun"> | string;
    claimId?: StringFilter<"ProviderRun"> | string;
    provider?: StringFilter<"ProviderRun"> | string;
    verdict?: StringFilter<"ProviderRun"> | string;
    confidence?: FloatFilter<"ProviderRun"> | number;
    costTokens?: IntFilter<"ProviderRun"> | number;
    latencyMs?: IntFilter<"ProviderRun"> | number;
    raw?: JsonFilter<"ProviderRun">;
    createdAt?: DateTimeFilter<"ProviderRun"> | Date | string;
    claim?: XOR<FactcheckClaimScalarRelationFilter, FactcheckClaimWhereInput>;
  };

  export type ProviderRunOrderByWithRelationInput = {
    id?: SortOrder;
    claimId?: SortOrder;
    provider?: SortOrder;
    verdict?: SortOrder;
    confidence?: SortOrder;
    costTokens?: SortOrder;
    latencyMs?: SortOrder;
    raw?: SortOrder;
    createdAt?: SortOrder;
    claim?: FactcheckClaimOrderByWithRelationInput;
  };

  export type ProviderRunWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: ProviderRunWhereInput | ProviderRunWhereInput[];
      OR?: ProviderRunWhereInput[];
      NOT?: ProviderRunWhereInput | ProviderRunWhereInput[];
      claimId?: StringFilter<"ProviderRun"> | string;
      provider?: StringFilter<"ProviderRun"> | string;
      verdict?: StringFilter<"ProviderRun"> | string;
      confidence?: FloatFilter<"ProviderRun"> | number;
      costTokens?: IntFilter<"ProviderRun"> | number;
      latencyMs?: IntFilter<"ProviderRun"> | number;
      raw?: JsonFilter<"ProviderRun">;
      createdAt?: DateTimeFilter<"ProviderRun"> | Date | string;
      claim?: XOR<FactcheckClaimScalarRelationFilter, FactcheckClaimWhereInput>;
    },
    "id"
  >;

  export type ProviderRunOrderByWithAggregationInput = {
    id?: SortOrder;
    claimId?: SortOrder;
    provider?: SortOrder;
    verdict?: SortOrder;
    confidence?: SortOrder;
    costTokens?: SortOrder;
    latencyMs?: SortOrder;
    raw?: SortOrder;
    createdAt?: SortOrder;
    _count?: ProviderRunCountOrderByAggregateInput;
    _avg?: ProviderRunAvgOrderByAggregateInput;
    _max?: ProviderRunMaxOrderByAggregateInput;
    _min?: ProviderRunMinOrderByAggregateInput;
    _sum?: ProviderRunSumOrderByAggregateInput;
  };

  export type ProviderRunScalarWhereWithAggregatesInput = {
    AND?:
      | ProviderRunScalarWhereWithAggregatesInput
      | ProviderRunScalarWhereWithAggregatesInput[];
    OR?: ProviderRunScalarWhereWithAggregatesInput[];
    NOT?:
      | ProviderRunScalarWhereWithAggregatesInput
      | ProviderRunScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"ProviderRun"> | string;
    claimId?: StringWithAggregatesFilter<"ProviderRun"> | string;
    provider?: StringWithAggregatesFilter<"ProviderRun"> | string;
    verdict?: StringWithAggregatesFilter<"ProviderRun"> | string;
    confidence?: FloatWithAggregatesFilter<"ProviderRun"> | number;
    costTokens?: IntWithAggregatesFilter<"ProviderRun"> | number;
    latencyMs?: IntWithAggregatesFilter<"ProviderRun"> | number;
    raw?: JsonWithAggregatesFilter<"ProviderRun">;
    createdAt?: DateTimeWithAggregatesFilter<"ProviderRun"> | Date | string;
  };

  export type ConsensusRunWhereInput = {
    AND?: ConsensusRunWhereInput | ConsensusRunWhereInput[];
    OR?: ConsensusRunWhereInput[];
    NOT?: ConsensusRunWhereInput | ConsensusRunWhereInput[];
    id?: StringFilter<"ConsensusRun"> | string;
    claimId?: StringFilter<"ConsensusRun"> | string;
    method?: StringFilter<"ConsensusRun"> | string;
    verdict?: StringFilter<"ConsensusRun"> | string;
    confidence?: FloatFilter<"ConsensusRun"> | number;
    balanceScore?: FloatFilter<"ConsensusRun"> | number;
    diversityIndex?: FloatFilter<"ConsensusRun"> | number;
    providers?: JsonFilter<"ConsensusRun">;
    createdAt?: DateTimeFilter<"ConsensusRun"> | Date | string;
    claim?: XOR<FactcheckClaimScalarRelationFilter, FactcheckClaimWhereInput>;
  };

  export type ConsensusRunOrderByWithRelationInput = {
    id?: SortOrder;
    claimId?: SortOrder;
    method?: SortOrder;
    verdict?: SortOrder;
    confidence?: SortOrder;
    balanceScore?: SortOrder;
    diversityIndex?: SortOrder;
    providers?: SortOrder;
    createdAt?: SortOrder;
    claim?: FactcheckClaimOrderByWithRelationInput;
  };

  export type ConsensusRunWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      claimId?: string;
      AND?: ConsensusRunWhereInput | ConsensusRunWhereInput[];
      OR?: ConsensusRunWhereInput[];
      NOT?: ConsensusRunWhereInput | ConsensusRunWhereInput[];
      method?: StringFilter<"ConsensusRun"> | string;
      verdict?: StringFilter<"ConsensusRun"> | string;
      confidence?: FloatFilter<"ConsensusRun"> | number;
      balanceScore?: FloatFilter<"ConsensusRun"> | number;
      diversityIndex?: FloatFilter<"ConsensusRun"> | number;
      providers?: JsonFilter<"ConsensusRun">;
      createdAt?: DateTimeFilter<"ConsensusRun"> | Date | string;
      claim?: XOR<FactcheckClaimScalarRelationFilter, FactcheckClaimWhereInput>;
    },
    "id" | "claimId"
  >;

  export type ConsensusRunOrderByWithAggregationInput = {
    id?: SortOrder;
    claimId?: SortOrder;
    method?: SortOrder;
    verdict?: SortOrder;
    confidence?: SortOrder;
    balanceScore?: SortOrder;
    diversityIndex?: SortOrder;
    providers?: SortOrder;
    createdAt?: SortOrder;
    _count?: ConsensusRunCountOrderByAggregateInput;
    _avg?: ConsensusRunAvgOrderByAggregateInput;
    _max?: ConsensusRunMaxOrderByAggregateInput;
    _min?: ConsensusRunMinOrderByAggregateInput;
    _sum?: ConsensusRunSumOrderByAggregateInput;
  };

  export type ConsensusRunScalarWhereWithAggregatesInput = {
    AND?:
      | ConsensusRunScalarWhereWithAggregatesInput
      | ConsensusRunScalarWhereWithAggregatesInput[];
    OR?: ConsensusRunScalarWhereWithAggregatesInput[];
    NOT?:
      | ConsensusRunScalarWhereWithAggregatesInput
      | ConsensusRunScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"ConsensusRun"> | string;
    claimId?: StringWithAggregatesFilter<"ConsensusRun"> | string;
    method?: StringWithAggregatesFilter<"ConsensusRun"> | string;
    verdict?: StringWithAggregatesFilter<"ConsensusRun"> | string;
    confidence?: FloatWithAggregatesFilter<"ConsensusRun"> | number;
    balanceScore?: FloatWithAggregatesFilter<"ConsensusRun"> | number;
    diversityIndex?: FloatWithAggregatesFilter<"ConsensusRun"> | number;
    providers?: JsonWithAggregatesFilter<"ConsensusRun">;
    createdAt?: DateTimeWithAggregatesFilter<"ConsensusRun"> | Date | string;
  };

  export type EvidenceWhereInput = {
    AND?: EvidenceWhereInput | EvidenceWhereInput[];
    OR?: EvidenceWhereInput[];
    NOT?: EvidenceWhereInput | EvidenceWhereInput[];
    id?: StringFilter<"Evidence"> | string;
    claimId?: StringFilter<"Evidence"> | string;
    url?: StringFilter<"Evidence"> | string;
    domain?: StringFilter<"Evidence"> | string;
    stance?: EnumStanceFilter<"Evidence"> | $Enums.Stance;
    snapshotHash?: StringNullableFilter<"Evidence"> | string | null;
    firstSeenAt?: DateTimeNullableFilter<"Evidence"> | Date | string | null;
    trustScore?: IntNullableFilter<"Evidence"> | number | null;
    claim?: XOR<FactcheckClaimScalarRelationFilter, FactcheckClaimWhereInput>;
  };

  export type EvidenceOrderByWithRelationInput = {
    id?: SortOrder;
    claimId?: SortOrder;
    url?: SortOrder;
    domain?: SortOrder;
    stance?: SortOrder;
    snapshotHash?: SortOrder;
    firstSeenAt?: SortOrder;
    trustScore?: SortOrder;
    claim?: FactcheckClaimOrderByWithRelationInput;
  };

  export type EvidenceWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: EvidenceWhereInput | EvidenceWhereInput[];
      OR?: EvidenceWhereInput[];
      NOT?: EvidenceWhereInput | EvidenceWhereInput[];
      claimId?: StringFilter<"Evidence"> | string;
      url?: StringFilter<"Evidence"> | string;
      domain?: StringFilter<"Evidence"> | string;
      stance?: EnumStanceFilter<"Evidence"> | $Enums.Stance;
      snapshotHash?: StringNullableFilter<"Evidence"> | string | null;
      firstSeenAt?: DateTimeNullableFilter<"Evidence"> | Date | string | null;
      trustScore?: IntNullableFilter<"Evidence"> | number | null;
      claim?: XOR<FactcheckClaimScalarRelationFilter, FactcheckClaimWhereInput>;
    },
    "id"
  >;

  export type EvidenceOrderByWithAggregationInput = {
    id?: SortOrder;
    claimId?: SortOrder;
    url?: SortOrder;
    domain?: SortOrder;
    stance?: SortOrder;
    snapshotHash?: SortOrder;
    firstSeenAt?: SortOrder;
    trustScore?: SortOrder;
    _count?: EvidenceCountOrderByAggregateInput;
    _avg?: EvidenceAvgOrderByAggregateInput;
    _max?: EvidenceMaxOrderByAggregateInput;
    _min?: EvidenceMinOrderByAggregateInput;
    _sum?: EvidenceSumOrderByAggregateInput;
  };

  export type EvidenceScalarWhereWithAggregatesInput = {
    AND?:
      | EvidenceScalarWhereWithAggregatesInput
      | EvidenceScalarWhereWithAggregatesInput[];
    OR?: EvidenceScalarWhereWithAggregatesInput[];
    NOT?:
      | EvidenceScalarWhereWithAggregatesInput
      | EvidenceScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"Evidence"> | string;
    claimId?: StringWithAggregatesFilter<"Evidence"> | string;
    url?: StringWithAggregatesFilter<"Evidence"> | string;
    domain?: StringWithAggregatesFilter<"Evidence"> | string;
    stance?: EnumStanceWithAggregatesFilter<"Evidence"> | $Enums.Stance;
    snapshotHash?:
      | StringNullableWithAggregatesFilter<"Evidence">
      | string
      | null;
    firstSeenAt?:
      | DateTimeNullableWithAggregatesFilter<"Evidence">
      | Date
      | string
      | null;
    trustScore?: IntNullableWithAggregatesFilter<"Evidence"> | number | null;
  };

  export type VerdictVersionWhereInput = {
    AND?: VerdictVersionWhereInput | VerdictVersionWhereInput[];
    OR?: VerdictVersionWhereInput[];
    NOT?: VerdictVersionWhereInput | VerdictVersionWhereInput[];
    id?: StringFilter<"VerdictVersion"> | string;
    claimId?: StringFilter<"VerdictVersion"> | string;
    verdict?: StringFilter<"VerdictVersion"> | string;
    confidence?: FloatFilter<"VerdictVersion"> | number;
    asOf?: DateTimeFilter<"VerdictVersion"> | Date | string;
    supersedes?: StringNullableFilter<"VerdictVersion"> | string | null;
    claim?: XOR<FactcheckClaimScalarRelationFilter, FactcheckClaimWhereInput>;
  };

  export type VerdictVersionOrderByWithRelationInput = {
    id?: SortOrder;
    claimId?: SortOrder;
    verdict?: SortOrder;
    confidence?: SortOrder;
    asOf?: SortOrder;
    supersedes?: SortOrder;
    claim?: FactcheckClaimOrderByWithRelationInput;
  };

  export type VerdictVersionWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: VerdictVersionWhereInput | VerdictVersionWhereInput[];
      OR?: VerdictVersionWhereInput[];
      NOT?: VerdictVersionWhereInput | VerdictVersionWhereInput[];
      claimId?: StringFilter<"VerdictVersion"> | string;
      verdict?: StringFilter<"VerdictVersion"> | string;
      confidence?: FloatFilter<"VerdictVersion"> | number;
      asOf?: DateTimeFilter<"VerdictVersion"> | Date | string;
      supersedes?: StringNullableFilter<"VerdictVersion"> | string | null;
      claim?: XOR<FactcheckClaimScalarRelationFilter, FactcheckClaimWhereInput>;
    },
    "id"
  >;

  export type VerdictVersionOrderByWithAggregationInput = {
    id?: SortOrder;
    claimId?: SortOrder;
    verdict?: SortOrder;
    confidence?: SortOrder;
    asOf?: SortOrder;
    supersedes?: SortOrder;
    _count?: VerdictVersionCountOrderByAggregateInput;
    _avg?: VerdictVersionAvgOrderByAggregateInput;
    _max?: VerdictVersionMaxOrderByAggregateInput;
    _min?: VerdictVersionMinOrderByAggregateInput;
    _sum?: VerdictVersionSumOrderByAggregateInput;
  };

  export type VerdictVersionScalarWhereWithAggregatesInput = {
    AND?:
      | VerdictVersionScalarWhereWithAggregatesInput
      | VerdictVersionScalarWhereWithAggregatesInput[];
    OR?: VerdictVersionScalarWhereWithAggregatesInput[];
    NOT?:
      | VerdictVersionScalarWhereWithAggregatesInput
      | VerdictVersionScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"VerdictVersion"> | string;
    claimId?: StringWithAggregatesFilter<"VerdictVersion"> | string;
    verdict?: StringWithAggregatesFilter<"VerdictVersion"> | string;
    confidence?: FloatWithAggregatesFilter<"VerdictVersion"> | number;
    asOf?: DateTimeWithAggregatesFilter<"VerdictVersion"> | Date | string;
    supersedes?:
      | StringNullableWithAggregatesFilter<"VerdictVersion">
      | string
      | null;
  };

  export type FactcheckResultWhereInput = {
    AND?: FactcheckResultWhereInput | FactcheckResultWhereInput[];
    OR?: FactcheckResultWhereInput[];
    NOT?: FactcheckResultWhereInput | FactcheckResultWhereInput[];
    id?: StringFilter<"FactcheckResult"> | string;
    jobId?: StringFilter<"FactcheckResult"> | string;
    verdict?: StringFilter<"FactcheckResult"> | string;
    rawOutput?: JsonFilter<"FactcheckResult">;
    createdAt?: DateTimeFilter<"FactcheckResult"> | Date | string;
    job?: XOR<FactcheckJobScalarRelationFilter, FactcheckJobWhereInput>;
  };

  export type FactcheckResultOrderByWithRelationInput = {
    id?: SortOrder;
    jobId?: SortOrder;
    verdict?: SortOrder;
    rawOutput?: SortOrder;
    createdAt?: SortOrder;
    job?: FactcheckJobOrderByWithRelationInput;
  };

  export type FactcheckResultWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: FactcheckResultWhereInput | FactcheckResultWhereInput[];
      OR?: FactcheckResultWhereInput[];
      NOT?: FactcheckResultWhereInput | FactcheckResultWhereInput[];
      jobId?: StringFilter<"FactcheckResult"> | string;
      verdict?: StringFilter<"FactcheckResult"> | string;
      rawOutput?: JsonFilter<"FactcheckResult">;
      createdAt?: DateTimeFilter<"FactcheckResult"> | Date | string;
      job?: XOR<FactcheckJobScalarRelationFilter, FactcheckJobWhereInput>;
    },
    "id"
  >;

  export type FactcheckResultOrderByWithAggregationInput = {
    id?: SortOrder;
    jobId?: SortOrder;
    verdict?: SortOrder;
    rawOutput?: SortOrder;
    createdAt?: SortOrder;
    _count?: FactcheckResultCountOrderByAggregateInput;
    _max?: FactcheckResultMaxOrderByAggregateInput;
    _min?: FactcheckResultMinOrderByAggregateInput;
  };

  export type FactcheckResultScalarWhereWithAggregatesInput = {
    AND?:
      | FactcheckResultScalarWhereWithAggregatesInput
      | FactcheckResultScalarWhereWithAggregatesInput[];
    OR?: FactcheckResultScalarWhereWithAggregatesInput[];
    NOT?:
      | FactcheckResultScalarWhereWithAggregatesInput
      | FactcheckResultScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"FactcheckResult"> | string;
    jobId?: StringWithAggregatesFilter<"FactcheckResult"> | string;
    verdict?: StringWithAggregatesFilter<"FactcheckResult"> | string;
    rawOutput?: JsonWithAggregatesFilter<"FactcheckResult">;
    createdAt?: DateTimeWithAggregatesFilter<"FactcheckResult"> | Date | string;
  };

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[];
    OR?: AuditLogWhereInput[];
    NOT?: AuditLogWhereInput | AuditLogWhereInput[];
    id?: StringFilter<"AuditLog"> | string;
    entityType?: StringFilter<"AuditLog"> | string;
    entityId?: StringFilter<"AuditLog"> | string;
    action?: StringFilter<"AuditLog"> | string;
    actor?: StringFilter<"AuditLog"> | string;
    at?: DateTimeFilter<"AuditLog"> | Date | string;
    meta?: JsonFilter<"AuditLog">;
  };

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder;
    entityType?: SortOrder;
    entityId?: SortOrder;
    action?: SortOrder;
    actor?: SortOrder;
    at?: SortOrder;
    meta?: SortOrder;
  };

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: AuditLogWhereInput | AuditLogWhereInput[];
      OR?: AuditLogWhereInput[];
      NOT?: AuditLogWhereInput | AuditLogWhereInput[];
      entityType?: StringFilter<"AuditLog"> | string;
      entityId?: StringFilter<"AuditLog"> | string;
      action?: StringFilter<"AuditLog"> | string;
      actor?: StringFilter<"AuditLog"> | string;
      at?: DateTimeFilter<"AuditLog"> | Date | string;
      meta?: JsonFilter<"AuditLog">;
    },
    "id"
  >;

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder;
    entityType?: SortOrder;
    entityId?: SortOrder;
    action?: SortOrder;
    actor?: SortOrder;
    at?: SortOrder;
    meta?: SortOrder;
    _count?: AuditLogCountOrderByAggregateInput;
    _max?: AuditLogMaxOrderByAggregateInput;
    _min?: AuditLogMinOrderByAggregateInput;
  };

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?:
      | AuditLogScalarWhereWithAggregatesInput
      | AuditLogScalarWhereWithAggregatesInput[];
    OR?: AuditLogScalarWhereWithAggregatesInput[];
    NOT?:
      | AuditLogScalarWhereWithAggregatesInput
      | AuditLogScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"AuditLog"> | string;
    entityType?: StringWithAggregatesFilter<"AuditLog"> | string;
    entityId?: StringWithAggregatesFilter<"AuditLog"> | string;
    action?: StringWithAggregatesFilter<"AuditLog"> | string;
    actor?: StringWithAggregatesFilter<"AuditLog"> | string;
    at?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string;
    meta?: JsonWithAggregatesFilter<"AuditLog">;
  };

  export type ExtractedUnitWhereInput = {
    AND?: ExtractedUnitWhereInput | ExtractedUnitWhereInput[];
    OR?: ExtractedUnitWhereInput[];
    NOT?: ExtractedUnitWhereInput | ExtractedUnitWhereInput[];
    id?: StringFilter<"ExtractedUnit"> | string;
    itemId?: StringNullableFilter<"ExtractedUnit"> | string | null;
    statementId?: StringNullableFilter<"ExtractedUnit"> | string | null;
    kind?: EnumUnitKindFilter<"ExtractedUnit"> | $Enums.UnitKind;
    text?: StringFilter<"ExtractedUnit"> | string;
    spanStart?: IntFilter<"ExtractedUnit"> | number;
    spanEnd?: IntFilter<"ExtractedUnit"> | number;
    confidence?: FloatFilter<"ExtractedUnit"> | number;
    canonicalKey?: StringFilter<"ExtractedUnit"> | string;
    scope?: StringNullableFilter<"ExtractedUnit"> | string | null;
    timeframe?: StringNullableFilter<"ExtractedUnit"> | string | null;
    claimId?: StringNullableFilter<"ExtractedUnit"> | string | null;
    interest?: EnumInterestFilter<"ExtractedUnit"> | $Enums.Interest;
    triage?: EnumTriageFilter<"ExtractedUnit"> | $Enums.Triage;
    editorNote?: StringNullableFilter<"ExtractedUnit"> | string | null;
    createdAt?: DateTimeFilter<"ExtractedUnit"> | Date | string;
    updatedAt?: DateTimeFilter<"ExtractedUnit"> | Date | string;
    item?: XOR<
      ContentItemNullableScalarRelationFilter,
      ContentItemWhereInput
    > | null;
    claim?: XOR<
      FactcheckClaimNullableScalarRelationFilter,
      FactcheckClaimWhereInput
    > | null;
  };

  export type ExtractedUnitOrderByWithRelationInput = {
    id?: SortOrder;
    itemId?: SortOrder;
    statementId?: SortOrder;
    kind?: SortOrder;
    text?: SortOrder;
    spanStart?: SortOrder;
    spanEnd?: SortOrder;
    confidence?: SortOrder;
    canonicalKey?: SortOrder;
    scope?: SortOrder;
    timeframe?: SortOrder;
    claimId?: SortOrder;
    interest?: SortOrder;
    triage?: SortOrder;
    editorNote?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    item?: ContentItemOrderByWithRelationInput;
    claim?: FactcheckClaimOrderByWithRelationInput;
  };

  export type ExtractedUnitWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: ExtractedUnitWhereInput | ExtractedUnitWhereInput[];
      OR?: ExtractedUnitWhereInput[];
      NOT?: ExtractedUnitWhereInput | ExtractedUnitWhereInput[];
      itemId?: StringNullableFilter<"ExtractedUnit"> | string | null;
      statementId?: StringNullableFilter<"ExtractedUnit"> | string | null;
      kind?: EnumUnitKindFilter<"ExtractedUnit"> | $Enums.UnitKind;
      text?: StringFilter<"ExtractedUnit"> | string;
      spanStart?: IntFilter<"ExtractedUnit"> | number;
      spanEnd?: IntFilter<"ExtractedUnit"> | number;
      confidence?: FloatFilter<"ExtractedUnit"> | number;
      canonicalKey?: StringFilter<"ExtractedUnit"> | string;
      scope?: StringNullableFilter<"ExtractedUnit"> | string | null;
      timeframe?: StringNullableFilter<"ExtractedUnit"> | string | null;
      claimId?: StringNullableFilter<"ExtractedUnit"> | string | null;
      interest?: EnumInterestFilter<"ExtractedUnit"> | $Enums.Interest;
      triage?: EnumTriageFilter<"ExtractedUnit"> | $Enums.Triage;
      editorNote?: StringNullableFilter<"ExtractedUnit"> | string | null;
      createdAt?: DateTimeFilter<"ExtractedUnit"> | Date | string;
      updatedAt?: DateTimeFilter<"ExtractedUnit"> | Date | string;
      item?: XOR<
        ContentItemNullableScalarRelationFilter,
        ContentItemWhereInput
      > | null;
      claim?: XOR<
        FactcheckClaimNullableScalarRelationFilter,
        FactcheckClaimWhereInput
      > | null;
    },
    "id"
  >;

  export type ExtractedUnitOrderByWithAggregationInput = {
    id?: SortOrder;
    itemId?: SortOrder;
    statementId?: SortOrder;
    kind?: SortOrder;
    text?: SortOrder;
    spanStart?: SortOrder;
    spanEnd?: SortOrder;
    confidence?: SortOrder;
    canonicalKey?: SortOrder;
    scope?: SortOrder;
    timeframe?: SortOrder;
    claimId?: SortOrder;
    interest?: SortOrder;
    triage?: SortOrder;
    editorNote?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: ExtractedUnitCountOrderByAggregateInput;
    _avg?: ExtractedUnitAvgOrderByAggregateInput;
    _max?: ExtractedUnitMaxOrderByAggregateInput;
    _min?: ExtractedUnitMinOrderByAggregateInput;
    _sum?: ExtractedUnitSumOrderByAggregateInput;
  };

  export type ExtractedUnitScalarWhereWithAggregatesInput = {
    AND?:
      | ExtractedUnitScalarWhereWithAggregatesInput
      | ExtractedUnitScalarWhereWithAggregatesInput[];
    OR?: ExtractedUnitScalarWhereWithAggregatesInput[];
    NOT?:
      | ExtractedUnitScalarWhereWithAggregatesInput
      | ExtractedUnitScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"ExtractedUnit"> | string;
    itemId?:
      | StringNullableWithAggregatesFilter<"ExtractedUnit">
      | string
      | null;
    statementId?:
      | StringNullableWithAggregatesFilter<"ExtractedUnit">
      | string
      | null;
    kind?: EnumUnitKindWithAggregatesFilter<"ExtractedUnit"> | $Enums.UnitKind;
    text?: StringWithAggregatesFilter<"ExtractedUnit"> | string;
    spanStart?: IntWithAggregatesFilter<"ExtractedUnit"> | number;
    spanEnd?: IntWithAggregatesFilter<"ExtractedUnit"> | number;
    confidence?: FloatWithAggregatesFilter<"ExtractedUnit"> | number;
    canonicalKey?: StringWithAggregatesFilter<"ExtractedUnit"> | string;
    scope?: StringNullableWithAggregatesFilter<"ExtractedUnit"> | string | null;
    timeframe?:
      | StringNullableWithAggregatesFilter<"ExtractedUnit">
      | string
      | null;
    claimId?:
      | StringNullableWithAggregatesFilter<"ExtractedUnit">
      | string
      | null;
    interest?:
      | EnumInterestWithAggregatesFilter<"ExtractedUnit">
      | $Enums.Interest;
    triage?: EnumTriageWithAggregatesFilter<"ExtractedUnit"> | $Enums.Triage;
    editorNote?:
      | StringNullableWithAggregatesFilter<"ExtractedUnit">
      | string
      | null;
    createdAt?: DateTimeWithAggregatesFilter<"ExtractedUnit"> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<"ExtractedUnit"> | Date | string;
  };

  export type FindingWhereInput = {
    AND?: FindingWhereInput | FindingWhereInput[];
    OR?: FindingWhereInput[];
    NOT?: FindingWhereInput | FindingWhereInput[];
    id?: StringFilter<"Finding"> | string;
    claimId?: StringFilter<"Finding"> | string;
    summary?: StringFilter<"Finding"> | string;
    outcome?: StringFilter<"Finding"> | string;
    rationale?: StringFilter<"Finding"> | string;
    metrics?: JsonNullableFilter<"Finding">;
    comparedJurisdictions?: JsonNullableFilter<"Finding">;
    lastChecked?: DateTimeFilter<"Finding"> | Date | string;
    createdAt?: DateTimeFilter<"Finding"> | Date | string;
    updatedAt?: DateTimeFilter<"Finding"> | Date | string;
    claim?: XOR<FactcheckClaimScalarRelationFilter, FactcheckClaimWhereInput>;
  };

  export type FindingOrderByWithRelationInput = {
    id?: SortOrder;
    claimId?: SortOrder;
    summary?: SortOrder;
    outcome?: SortOrder;
    rationale?: SortOrder;
    metrics?: SortOrder;
    comparedJurisdictions?: SortOrder;
    lastChecked?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    claim?: FactcheckClaimOrderByWithRelationInput;
  };

  export type FindingWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      claimId?: string;
      AND?: FindingWhereInput | FindingWhereInput[];
      OR?: FindingWhereInput[];
      NOT?: FindingWhereInput | FindingWhereInput[];
      summary?: StringFilter<"Finding"> | string;
      outcome?: StringFilter<"Finding"> | string;
      rationale?: StringFilter<"Finding"> | string;
      metrics?: JsonNullableFilter<"Finding">;
      comparedJurisdictions?: JsonNullableFilter<"Finding">;
      lastChecked?: DateTimeFilter<"Finding"> | Date | string;
      createdAt?: DateTimeFilter<"Finding"> | Date | string;
      updatedAt?: DateTimeFilter<"Finding"> | Date | string;
      claim?: XOR<FactcheckClaimScalarRelationFilter, FactcheckClaimWhereInput>;
    },
    "id" | "claimId"
  >;

  export type FindingOrderByWithAggregationInput = {
    id?: SortOrder;
    claimId?: SortOrder;
    summary?: SortOrder;
    outcome?: SortOrder;
    rationale?: SortOrder;
    metrics?: SortOrder;
    comparedJurisdictions?: SortOrder;
    lastChecked?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: FindingCountOrderByAggregateInput;
    _max?: FindingMaxOrderByAggregateInput;
    _min?: FindingMinOrderByAggregateInput;
  };

  export type FindingScalarWhereWithAggregatesInput = {
    AND?:
      | FindingScalarWhereWithAggregatesInput
      | FindingScalarWhereWithAggregatesInput[];
    OR?: FindingScalarWhereWithAggregatesInput[];
    NOT?:
      | FindingScalarWhereWithAggregatesInput
      | FindingScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"Finding"> | string;
    claimId?: StringWithAggregatesFilter<"Finding"> | string;
    summary?: StringWithAggregatesFilter<"Finding"> | string;
    outcome?: StringWithAggregatesFilter<"Finding"> | string;
    rationale?: StringWithAggregatesFilter<"Finding"> | string;
    metrics?: JsonNullableWithAggregatesFilter<"Finding">;
    comparedJurisdictions?: JsonNullableWithAggregatesFilter<"Finding">;
    lastChecked?: DateTimeWithAggregatesFilter<"Finding"> | Date | string;
    createdAt?: DateTimeWithAggregatesFilter<"Finding"> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<"Finding"> | Date | string;
  };

  export type AdminSettingsWhereInput = {
    AND?: AdminSettingsWhereInput | AdminSettingsWhereInput[];
    OR?: AdminSettingsWhereInput[];
    NOT?: AdminSettingsWhereInput | AdminSettingsWhereInput[];
    id?: StringFilter<"AdminSettings"> | string;
    onboarding?: JsonNullableFilter<"AdminSettings">;
    csp?: JsonNullableFilter<"AdminSettings">;
    updatedAt?: DateTimeFilter<"AdminSettings"> | Date | string;
  };

  export type AdminSettingsOrderByWithRelationInput = {
    id?: SortOrder;
    onboarding?: SortOrder;
    csp?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type AdminSettingsWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: AdminSettingsWhereInput | AdminSettingsWhereInput[];
      OR?: AdminSettingsWhereInput[];
      NOT?: AdminSettingsWhereInput | AdminSettingsWhereInput[];
      onboarding?: JsonNullableFilter<"AdminSettings">;
      csp?: JsonNullableFilter<"AdminSettings">;
      updatedAt?: DateTimeFilter<"AdminSettings"> | Date | string;
    },
    "id"
  >;

  export type AdminSettingsOrderByWithAggregationInput = {
    id?: SortOrder;
    onboarding?: SortOrder;
    csp?: SortOrder;
    updatedAt?: SortOrder;
    _count?: AdminSettingsCountOrderByAggregateInput;
    _max?: AdminSettingsMaxOrderByAggregateInput;
    _min?: AdminSettingsMinOrderByAggregateInput;
  };

  export type AdminSettingsScalarWhereWithAggregatesInput = {
    AND?:
      | AdminSettingsScalarWhereWithAggregatesInput
      | AdminSettingsScalarWhereWithAggregatesInput[];
    OR?: AdminSettingsScalarWhereWithAggregatesInput[];
    NOT?:
      | AdminSettingsScalarWhereWithAggregatesInput
      | AdminSettingsScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"AdminSettings"> | string;
    onboarding?: JsonNullableWithAggregatesFilter<"AdminSettings">;
    csp?: JsonNullableWithAggregatesFilter<"AdminSettings">;
    updatedAt?: DateTimeWithAggregatesFilter<"AdminSettings"> | Date | string;
  };

  export type TopicCreateInput = {
    id?: string;
    slug: string;
    title: string;
    description?: string | null;
    locale?: $Enums.Locale;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    items?: ContentItemCreateNestedManyWithoutTopicInput;
    tags?: TopicTagCreateNestedManyWithoutTopicInput;
  };

  export type TopicUncheckedCreateInput = {
    id?: string;
    slug: string;
    title: string;
    description?: string | null;
    locale?: $Enums.Locale;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    items?: ContentItemUncheckedCreateNestedManyWithoutTopicInput;
    tags?: TopicTagUncheckedCreateNestedManyWithoutTopicInput;
  };

  export type TopicUpdateInput = {
    slug?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    locale?: EnumLocaleFieldUpdateOperationsInput | $Enums.Locale;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    items?: ContentItemUpdateManyWithoutTopicNestedInput;
    tags?: TopicTagUpdateManyWithoutTopicNestedInput;
  };

  export type TopicUncheckedUpdateInput = {
    slug?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    locale?: EnumLocaleFieldUpdateOperationsInput | $Enums.Locale;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    items?: ContentItemUncheckedUpdateManyWithoutTopicNestedInput;
    tags?: TopicTagUncheckedUpdateManyWithoutTopicNestedInput;
  };

  export type TopicCreateManyInput = {
    id?: string;
    slug: string;
    title: string;
    description?: string | null;
    locale?: $Enums.Locale;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type TopicUpdateManyMutationInput = {
    slug?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    locale?: EnumLocaleFieldUpdateOperationsInput | $Enums.Locale;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type TopicUncheckedUpdateManyInput = {
    slug?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    locale?: EnumLocaleFieldUpdateOperationsInput | $Enums.Locale;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type TagCreateInput = {
    id?: string;
    slug: string;
    label: string;
    topics?: TopicTagCreateNestedManyWithoutTagInput;
    items?: ItemTagCreateNestedManyWithoutTagInput;
  };

  export type TagUncheckedCreateInput = {
    id?: string;
    slug: string;
    label: string;
    topics?: TopicTagUncheckedCreateNestedManyWithoutTagInput;
    items?: ItemTagUncheckedCreateNestedManyWithoutTagInput;
  };

  export type TagUpdateInput = {
    slug?: StringFieldUpdateOperationsInput | string;
    label?: StringFieldUpdateOperationsInput | string;
    topics?: TopicTagUpdateManyWithoutTagNestedInput;
    items?: ItemTagUpdateManyWithoutTagNestedInput;
  };

  export type TagUncheckedUpdateInput = {
    slug?: StringFieldUpdateOperationsInput | string;
    label?: StringFieldUpdateOperationsInput | string;
    topics?: TopicTagUncheckedUpdateManyWithoutTagNestedInput;
    items?: ItemTagUncheckedUpdateManyWithoutTagNestedInput;
  };

  export type TagCreateManyInput = {
    id?: string;
    slug: string;
    label: string;
  };

  export type TagUpdateManyMutationInput = {
    slug?: StringFieldUpdateOperationsInput | string;
    label?: StringFieldUpdateOperationsInput | string;
  };

  export type TagUncheckedUpdateManyInput = {
    slug?: StringFieldUpdateOperationsInput | string;
    label?: StringFieldUpdateOperationsInput | string;
  };

  export type TopicTagCreateInput = {
    id?: string;
    topic: TopicCreateNestedOneWithoutTagsInput;
    tag: TagCreateNestedOneWithoutTopicsInput;
  };

  export type TopicTagUncheckedCreateInput = {
    id?: string;
    topicId: string;
    tagId: string;
  };

  export type TopicTagUpdateInput = {
    topic?: TopicUpdateOneRequiredWithoutTagsNestedInput;
    tag?: TagUpdateOneRequiredWithoutTopicsNestedInput;
  };

  export type TopicTagUncheckedUpdateInput = {
    topicId?: StringFieldUpdateOperationsInput | string;
    tagId?: StringFieldUpdateOperationsInput | string;
  };

  export type TopicTagCreateManyInput = {
    id?: string;
    topicId: string;
    tagId: string;
  };

  export type TopicTagUpdateManyMutationInput = {};

  export type TopicTagUncheckedUpdateManyInput = {
    topicId?: StringFieldUpdateOperationsInput | string;
    tagId?: StringFieldUpdateOperationsInput | string;
  };

  export type ItemTagCreateInput = {
    id?: string;
    item: ContentItemCreateNestedOneWithoutTagsInput;
    tag: TagCreateNestedOneWithoutItemsInput;
  };

  export type ItemTagUncheckedCreateInput = {
    id?: string;
    itemId: string;
    tagId: string;
  };

  export type ItemTagUpdateInput = {
    item?: ContentItemUpdateOneRequiredWithoutTagsNestedInput;
    tag?: TagUpdateOneRequiredWithoutItemsNestedInput;
  };

  export type ItemTagUncheckedUpdateInput = {
    itemId?: StringFieldUpdateOperationsInput | string;
    tagId?: StringFieldUpdateOperationsInput | string;
  };

  export type ItemTagCreateManyInput = {
    id?: string;
    itemId: string;
    tagId: string;
  };

  export type ItemTagUpdateManyMutationInput = {};

  export type ItemTagUncheckedUpdateManyInput = {
    itemId?: StringFieldUpdateOperationsInput | string;
    tagId?: StringFieldUpdateOperationsInput | string;
  };

  export type RegionCreateInput = {
    id?: string;
    code: string;
    name: string;
    level: number;
    meta?: InputJsonValue | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    parent?: RegionCreateNestedOneWithoutChildrenInput;
    children?: RegionCreateNestedManyWithoutParentInput;
    itemsManual?: ContentItemCreateNestedManyWithoutRegionManualInput;
    itemsEffective?: ContentItemCreateNestedManyWithoutRegionEffectiveInput;
    ancestors?: RegionClosureCreateNestedManyWithoutAncestorInput;
    descendants?: RegionClosureCreateNestedManyWithoutDescendantInput;
  };

  export type RegionUncheckedCreateInput = {
    id?: string;
    code: string;
    name: string;
    level: number;
    parentId?: string | null;
    meta?: InputJsonValue | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    children?: RegionUncheckedCreateNestedManyWithoutParentInput;
    itemsManual?: ContentItemUncheckedCreateNestedManyWithoutRegionManualInput;
    itemsEffective?: ContentItemUncheckedCreateNestedManyWithoutRegionEffectiveInput;
    ancestors?: RegionClosureUncheckedCreateNestedManyWithoutAncestorInput;
    descendants?: RegionClosureUncheckedCreateNestedManyWithoutDescendantInput;
  };

  export type RegionUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    level?: IntFieldUpdateOperationsInput | number;
    meta?: InputJsonValue | InputJsonValue | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    parent?: RegionUpdateOneWithoutChildrenNestedInput;
    children?: RegionUpdateManyWithoutParentNestedInput;
    itemsManual?: ContentItemUpdateManyWithoutRegionManualNestedInput;
    itemsEffective?: ContentItemUpdateManyWithoutRegionEffectiveNestedInput;
    ancestors?: RegionClosureUpdateManyWithoutAncestorNestedInput;
    descendants?: RegionClosureUpdateManyWithoutDescendantNestedInput;
  };

  export type RegionUncheckedUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    level?: IntFieldUpdateOperationsInput | number;
    parentId?: NullableStringFieldUpdateOperationsInput | string | null;
    meta?: InputJsonValue | InputJsonValue | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    children?: RegionUncheckedUpdateManyWithoutParentNestedInput;
    itemsManual?: ContentItemUncheckedUpdateManyWithoutRegionManualNestedInput;
    itemsEffective?: ContentItemUncheckedUpdateManyWithoutRegionEffectiveNestedInput;
    ancestors?: RegionClosureUncheckedUpdateManyWithoutAncestorNestedInput;
    descendants?: RegionClosureUncheckedUpdateManyWithoutDescendantNestedInput;
  };

  export type RegionCreateManyInput = {
    id?: string;
    code: string;
    name: string;
    level: number;
    parentId?: string | null;
    meta?: InputJsonValue | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type RegionUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    level?: IntFieldUpdateOperationsInput | number;
    meta?: InputJsonValue | InputJsonValue | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type RegionUncheckedUpdateManyInput = {
    code?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    level?: IntFieldUpdateOperationsInput | number;
    parentId?: NullableStringFieldUpdateOperationsInput | string | null;
    meta?: InputJsonValue | InputJsonValue | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type RegionClosureCreateInput = {
    id?: string;
    depth: number;
    ancestor: RegionCreateNestedOneWithoutAncestorsInput;
    descendant: RegionCreateNestedOneWithoutDescendantsInput;
  };

  export type RegionClosureUncheckedCreateInput = {
    id?: string;
    ancestorId: string;
    descendantId: string;
    depth: number;
  };

  export type RegionClosureUpdateInput = {
    depth?: IntFieldUpdateOperationsInput | number;
    ancestor?: RegionUpdateOneRequiredWithoutAncestorsNestedInput;
    descendant?: RegionUpdateOneRequiredWithoutDescendantsNestedInput;
  };

  export type RegionClosureUncheckedUpdateInput = {
    ancestorId?: StringFieldUpdateOperationsInput | string;
    descendantId?: StringFieldUpdateOperationsInput | string;
    depth?: IntFieldUpdateOperationsInput | number;
  };

  export type RegionClosureCreateManyInput = {
    id?: string;
    ancestorId: string;
    descendantId: string;
    depth: number;
  };

  export type RegionClosureUpdateManyMutationInput = {
    depth?: IntFieldUpdateOperationsInput | number;
  };

  export type RegionClosureUncheckedUpdateManyInput = {
    ancestorId?: StringFieldUpdateOperationsInput | string;
    descendantId?: StringFieldUpdateOperationsInput | string;
    depth?: IntFieldUpdateOperationsInput | number;
  };

  export type ContentItemCreateInput = {
    id?: string;
    kind: $Enums.ContentKind;
    locale?: $Enums.Locale;
    title?: string | null;
    text: string;
    richText?: string | null;
    sortOrder?: number;
    status?: $Enums.PublishStatus;
    authorName?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    publishAt?: Date | string | null;
    expireAt?: Date | string | null;
    regionMode?: $Enums.RegionMode;
    regionAuto?: InputJsonValue | null;
    validation?: InputJsonValue | null;
    meta?: InputJsonValue | null;
    topic: TopicCreateNestedOneWithoutItemsInput;
    units?: ExtractedUnitCreateNestedManyWithoutItemInput;
    regionManual?: RegionCreateNestedOneWithoutItemsManualInput;
    regionEffective?: RegionCreateNestedOneWithoutItemsEffectiveInput;
    answerOptions?: AnswerOptionCreateNestedManyWithoutItemInput;
    tags?: ItemTagCreateNestedManyWithoutItemInput;
  };

  export type ContentItemUncheckedCreateInput = {
    id?: string;
    kind: $Enums.ContentKind;
    topicId: string;
    locale?: $Enums.Locale;
    title?: string | null;
    text: string;
    richText?: string | null;
    sortOrder?: number;
    status?: $Enums.PublishStatus;
    authorName?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    publishAt?: Date | string | null;
    expireAt?: Date | string | null;
    regionMode?: $Enums.RegionMode;
    regionManualId?: string | null;
    regionAuto?: InputJsonValue | null;
    regionEffectiveId?: string | null;
    validation?: InputJsonValue | null;
    meta?: InputJsonValue | null;
    units?: ExtractedUnitUncheckedCreateNestedManyWithoutItemInput;
    answerOptions?: AnswerOptionUncheckedCreateNestedManyWithoutItemInput;
    tags?: ItemTagUncheckedCreateNestedManyWithoutItemInput;
  };

  export type ContentItemUpdateInput = {
    kind?: EnumContentKindFieldUpdateOperationsInput | $Enums.ContentKind;
    locale?: EnumLocaleFieldUpdateOperationsInput | $Enums.Locale;
    title?: NullableStringFieldUpdateOperationsInput | string | null;
    text?: StringFieldUpdateOperationsInput | string;
    richText?: NullableStringFieldUpdateOperationsInput | string | null;
    sortOrder?: IntFieldUpdateOperationsInput | number;
    status?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus;
    authorName?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    publishAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    expireAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    regionMode?: EnumRegionModeFieldUpdateOperationsInput | $Enums.RegionMode;
    regionAuto?: InputJsonValue | InputJsonValue | null;
    validation?: InputJsonValue | InputJsonValue | null;
    meta?: InputJsonValue | InputJsonValue | null;
    topic?: TopicUpdateOneRequiredWithoutItemsNestedInput;
    units?: ExtractedUnitUpdateManyWithoutItemNestedInput;
    regionManual?: RegionUpdateOneWithoutItemsManualNestedInput;
    regionEffective?: RegionUpdateOneWithoutItemsEffectiveNestedInput;
    answerOptions?: AnswerOptionUpdateManyWithoutItemNestedInput;
    tags?: ItemTagUpdateManyWithoutItemNestedInput;
  };

  export type ContentItemUncheckedUpdateInput = {
    kind?: EnumContentKindFieldUpdateOperationsInput | $Enums.ContentKind;
    topicId?: StringFieldUpdateOperationsInput | string;
    locale?: EnumLocaleFieldUpdateOperationsInput | $Enums.Locale;
    title?: NullableStringFieldUpdateOperationsInput | string | null;
    text?: StringFieldUpdateOperationsInput | string;
    richText?: NullableStringFieldUpdateOperationsInput | string | null;
    sortOrder?: IntFieldUpdateOperationsInput | number;
    status?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus;
    authorName?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    publishAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    expireAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    regionMode?: EnumRegionModeFieldUpdateOperationsInput | $Enums.RegionMode;
    regionManualId?: NullableStringFieldUpdateOperationsInput | string | null;
    regionAuto?: InputJsonValue | InputJsonValue | null;
    regionEffectiveId?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    validation?: InputJsonValue | InputJsonValue | null;
    meta?: InputJsonValue | InputJsonValue | null;
    units?: ExtractedUnitUncheckedUpdateManyWithoutItemNestedInput;
    answerOptions?: AnswerOptionUncheckedUpdateManyWithoutItemNestedInput;
    tags?: ItemTagUncheckedUpdateManyWithoutItemNestedInput;
  };

  export type ContentItemCreateManyInput = {
    id?: string;
    kind: $Enums.ContentKind;
    topicId: string;
    locale?: $Enums.Locale;
    title?: string | null;
    text: string;
    richText?: string | null;
    sortOrder?: number;
    status?: $Enums.PublishStatus;
    authorName?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    publishAt?: Date | string | null;
    expireAt?: Date | string | null;
    regionMode?: $Enums.RegionMode;
    regionManualId?: string | null;
    regionAuto?: InputJsonValue | null;
    regionEffectiveId?: string | null;
    validation?: InputJsonValue | null;
    meta?: InputJsonValue | null;
  };

  export type ContentItemUpdateManyMutationInput = {
    kind?: EnumContentKindFieldUpdateOperationsInput | $Enums.ContentKind;
    locale?: EnumLocaleFieldUpdateOperationsInput | $Enums.Locale;
    title?: NullableStringFieldUpdateOperationsInput | string | null;
    text?: StringFieldUpdateOperationsInput | string;
    richText?: NullableStringFieldUpdateOperationsInput | string | null;
    sortOrder?: IntFieldUpdateOperationsInput | number;
    status?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus;
    authorName?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    publishAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    expireAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    regionMode?: EnumRegionModeFieldUpdateOperationsInput | $Enums.RegionMode;
    regionAuto?: InputJsonValue | InputJsonValue | null;
    validation?: InputJsonValue | InputJsonValue | null;
    meta?: InputJsonValue | InputJsonValue | null;
  };

  export type ContentItemUncheckedUpdateManyInput = {
    kind?: EnumContentKindFieldUpdateOperationsInput | $Enums.ContentKind;
    topicId?: StringFieldUpdateOperationsInput | string;
    locale?: EnumLocaleFieldUpdateOperationsInput | $Enums.Locale;
    title?: NullableStringFieldUpdateOperationsInput | string | null;
    text?: StringFieldUpdateOperationsInput | string;
    richText?: NullableStringFieldUpdateOperationsInput | string | null;
    sortOrder?: IntFieldUpdateOperationsInput | number;
    status?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus;
    authorName?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    publishAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    expireAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    regionMode?: EnumRegionModeFieldUpdateOperationsInput | $Enums.RegionMode;
    regionManualId?: NullableStringFieldUpdateOperationsInput | string | null;
    regionAuto?: InputJsonValue | InputJsonValue | null;
    regionEffectiveId?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    validation?: InputJsonValue | InputJsonValue | null;
    meta?: InputJsonValue | InputJsonValue | null;
  };

  export type AnswerOptionCreateInput = {
    id?: string;
    label: string;
    value: string;
    sortOrder?: number;
    exclusive?: boolean;
    meta?: InputJsonValue | null;
    item: ContentItemCreateNestedOneWithoutAnswerOptionsInput;
  };

  export type AnswerOptionUncheckedCreateInput = {
    id?: string;
    itemId: string;
    label: string;
    value: string;
    sortOrder?: number;
    exclusive?: boolean;
    meta?: InputJsonValue | null;
  };

  export type AnswerOptionUpdateInput = {
    label?: StringFieldUpdateOperationsInput | string;
    value?: StringFieldUpdateOperationsInput | string;
    sortOrder?: IntFieldUpdateOperationsInput | number;
    exclusive?: BoolFieldUpdateOperationsInput | boolean;
    meta?: InputJsonValue | InputJsonValue | null;
    item?: ContentItemUpdateOneRequiredWithoutAnswerOptionsNestedInput;
  };

  export type AnswerOptionUncheckedUpdateInput = {
    itemId?: StringFieldUpdateOperationsInput | string;
    label?: StringFieldUpdateOperationsInput | string;
    value?: StringFieldUpdateOperationsInput | string;
    sortOrder?: IntFieldUpdateOperationsInput | number;
    exclusive?: BoolFieldUpdateOperationsInput | boolean;
    meta?: InputJsonValue | InputJsonValue | null;
  };

  export type AnswerOptionCreateManyInput = {
    id?: string;
    itemId: string;
    label: string;
    value: string;
    sortOrder?: number;
    exclusive?: boolean;
    meta?: InputJsonValue | null;
  };

  export type AnswerOptionUpdateManyMutationInput = {
    label?: StringFieldUpdateOperationsInput | string;
    value?: StringFieldUpdateOperationsInput | string;
    sortOrder?: IntFieldUpdateOperationsInput | number;
    exclusive?: BoolFieldUpdateOperationsInput | boolean;
    meta?: InputJsonValue | InputJsonValue | null;
  };

  export type AnswerOptionUncheckedUpdateManyInput = {
    itemId?: StringFieldUpdateOperationsInput | string;
    label?: StringFieldUpdateOperationsInput | string;
    value?: StringFieldUpdateOperationsInput | string;
    sortOrder?: IntFieldUpdateOperationsInput | number;
    exclusive?: BoolFieldUpdateOperationsInput | boolean;
    meta?: InputJsonValue | InputJsonValue | null;
  };

  export type FactcheckJobCreateInput = {
    id?: string;
    jobId: string;
    contributionId: string;
    status: string;
    tokensUsed?: number;
    durationMs?: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    claims?: FactcheckClaimCreateNestedManyWithoutJobInput;
    results?: FactcheckResultCreateNestedManyWithoutJobInput;
  };

  export type FactcheckJobUncheckedCreateInput = {
    id?: string;
    jobId: string;
    contributionId: string;
    status: string;
    tokensUsed?: number;
    durationMs?: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    claims?: FactcheckClaimUncheckedCreateNestedManyWithoutJobInput;
    results?: FactcheckResultUncheckedCreateNestedManyWithoutJobInput;
  };

  export type FactcheckJobUpdateInput = {
    jobId?: StringFieldUpdateOperationsInput | string;
    contributionId?: StringFieldUpdateOperationsInput | string;
    status?: StringFieldUpdateOperationsInput | string;
    tokensUsed?: IntFieldUpdateOperationsInput | number;
    durationMs?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    claims?: FactcheckClaimUpdateManyWithoutJobNestedInput;
    results?: FactcheckResultUpdateManyWithoutJobNestedInput;
  };

  export type FactcheckJobUncheckedUpdateInput = {
    jobId?: StringFieldUpdateOperationsInput | string;
    contributionId?: StringFieldUpdateOperationsInput | string;
    status?: StringFieldUpdateOperationsInput | string;
    tokensUsed?: IntFieldUpdateOperationsInput | number;
    durationMs?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    claims?: FactcheckClaimUncheckedUpdateManyWithoutJobNestedInput;
    results?: FactcheckResultUncheckedUpdateManyWithoutJobNestedInput;
  };

  export type FactcheckJobCreateManyInput = {
    id?: string;
    jobId: string;
    contributionId: string;
    status: string;
    tokensUsed?: number;
    durationMs?: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type FactcheckJobUpdateManyMutationInput = {
    jobId?: StringFieldUpdateOperationsInput | string;
    contributionId?: StringFieldUpdateOperationsInput | string;
    status?: StringFieldUpdateOperationsInput | string;
    tokensUsed?: IntFieldUpdateOperationsInput | number;
    durationMs?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type FactcheckJobUncheckedUpdateManyInput = {
    jobId?: StringFieldUpdateOperationsInput | string;
    contributionId?: StringFieldUpdateOperationsInput | string;
    status?: StringFieldUpdateOperationsInput | string;
    tokensUsed?: IntFieldUpdateOperationsInput | number;
    durationMs?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type FactcheckClaimCreateInput = {
    id?: string;
    text: string;
    language?: string | null;
    topic?: string | null;
    falsifiable?: boolean;
    frames?: FactcheckClaimCreateframesInput | string[];
    rhetoricalFlags?: FactcheckClaimCreaterhetoricalFlagsInput | string[];
    canonicalKey: string;
    scope?: string | null;
    timeframe?: string | null;
    status?: $Enums.ReviewStatus;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    job: FactcheckJobCreateNestedOneWithoutClaimsInput;
    providerRuns?: ProviderRunCreateNestedManyWithoutClaimInput;
    evidences?: EvidenceCreateNestedManyWithoutClaimInput;
    consensus?: ConsensusRunCreateNestedOneWithoutClaimInput;
    verdictVersions?: VerdictVersionCreateNestedManyWithoutClaimInput;
    units?: ExtractedUnitCreateNestedManyWithoutClaimInput;
    finding?: FindingCreateNestedOneWithoutClaimInput;
  };

  export type FactcheckClaimUncheckedCreateInput = {
    id?: string;
    jobId: string;
    text: string;
    language?: string | null;
    topic?: string | null;
    falsifiable?: boolean;
    frames?: FactcheckClaimCreateframesInput | string[];
    rhetoricalFlags?: FactcheckClaimCreaterhetoricalFlagsInput | string[];
    canonicalKey: string;
    scope?: string | null;
    timeframe?: string | null;
    status?: $Enums.ReviewStatus;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    providerRuns?: ProviderRunUncheckedCreateNestedManyWithoutClaimInput;
    evidences?: EvidenceUncheckedCreateNestedManyWithoutClaimInput;
    consensus?: ConsensusRunUncheckedCreateNestedOneWithoutClaimInput;
    verdictVersions?: VerdictVersionUncheckedCreateNestedManyWithoutClaimInput;
    units?: ExtractedUnitUncheckedCreateNestedManyWithoutClaimInput;
    finding?: FindingUncheckedCreateNestedOneWithoutClaimInput;
  };

  export type FactcheckClaimUpdateInput = {
    text?: StringFieldUpdateOperationsInput | string;
    language?: NullableStringFieldUpdateOperationsInput | string | null;
    topic?: NullableStringFieldUpdateOperationsInput | string | null;
    falsifiable?: BoolFieldUpdateOperationsInput | boolean;
    frames?: FactcheckClaimUpdateframesInput | string[];
    rhetoricalFlags?: FactcheckClaimUpdaterhetoricalFlagsInput | string[];
    canonicalKey?: StringFieldUpdateOperationsInput | string;
    scope?: NullableStringFieldUpdateOperationsInput | string | null;
    timeframe?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumReviewStatusFieldUpdateOperationsInput | $Enums.ReviewStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    job?: FactcheckJobUpdateOneRequiredWithoutClaimsNestedInput;
    providerRuns?: ProviderRunUpdateManyWithoutClaimNestedInput;
    evidences?: EvidenceUpdateManyWithoutClaimNestedInput;
    consensus?: ConsensusRunUpdateOneWithoutClaimNestedInput;
    verdictVersions?: VerdictVersionUpdateManyWithoutClaimNestedInput;
    units?: ExtractedUnitUpdateManyWithoutClaimNestedInput;
    finding?: FindingUpdateOneWithoutClaimNestedInput;
  };

  export type FactcheckClaimUncheckedUpdateInput = {
    jobId?: StringFieldUpdateOperationsInput | string;
    text?: StringFieldUpdateOperationsInput | string;
    language?: NullableStringFieldUpdateOperationsInput | string | null;
    topic?: NullableStringFieldUpdateOperationsInput | string | null;
    falsifiable?: BoolFieldUpdateOperationsInput | boolean;
    frames?: FactcheckClaimUpdateframesInput | string[];
    rhetoricalFlags?: FactcheckClaimUpdaterhetoricalFlagsInput | string[];
    canonicalKey?: StringFieldUpdateOperationsInput | string;
    scope?: NullableStringFieldUpdateOperationsInput | string | null;
    timeframe?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumReviewStatusFieldUpdateOperationsInput | $Enums.ReviewStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    providerRuns?: ProviderRunUncheckedUpdateManyWithoutClaimNestedInput;
    evidences?: EvidenceUncheckedUpdateManyWithoutClaimNestedInput;
    consensus?: ConsensusRunUncheckedUpdateOneWithoutClaimNestedInput;
    verdictVersions?: VerdictVersionUncheckedUpdateManyWithoutClaimNestedInput;
    units?: ExtractedUnitUncheckedUpdateManyWithoutClaimNestedInput;
    finding?: FindingUncheckedUpdateOneWithoutClaimNestedInput;
  };

  export type FactcheckClaimCreateManyInput = {
    id?: string;
    jobId: string;
    text: string;
    language?: string | null;
    topic?: string | null;
    falsifiable?: boolean;
    frames?: FactcheckClaimCreateframesInput | string[];
    rhetoricalFlags?: FactcheckClaimCreaterhetoricalFlagsInput | string[];
    canonicalKey: string;
    scope?: string | null;
    timeframe?: string | null;
    status?: $Enums.ReviewStatus;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type FactcheckClaimUpdateManyMutationInput = {
    text?: StringFieldUpdateOperationsInput | string;
    language?: NullableStringFieldUpdateOperationsInput | string | null;
    topic?: NullableStringFieldUpdateOperationsInput | string | null;
    falsifiable?: BoolFieldUpdateOperationsInput | boolean;
    frames?: FactcheckClaimUpdateframesInput | string[];
    rhetoricalFlags?: FactcheckClaimUpdaterhetoricalFlagsInput | string[];
    canonicalKey?: StringFieldUpdateOperationsInput | string;
    scope?: NullableStringFieldUpdateOperationsInput | string | null;
    timeframe?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumReviewStatusFieldUpdateOperationsInput | $Enums.ReviewStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type FactcheckClaimUncheckedUpdateManyInput = {
    jobId?: StringFieldUpdateOperationsInput | string;
    text?: StringFieldUpdateOperationsInput | string;
    language?: NullableStringFieldUpdateOperationsInput | string | null;
    topic?: NullableStringFieldUpdateOperationsInput | string | null;
    falsifiable?: BoolFieldUpdateOperationsInput | boolean;
    frames?: FactcheckClaimUpdateframesInput | string[];
    rhetoricalFlags?: FactcheckClaimUpdaterhetoricalFlagsInput | string[];
    canonicalKey?: StringFieldUpdateOperationsInput | string;
    scope?: NullableStringFieldUpdateOperationsInput | string | null;
    timeframe?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumReviewStatusFieldUpdateOperationsInput | $Enums.ReviewStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ProviderRunCreateInput = {
    id?: string;
    provider: string;
    verdict: string;
    confidence: number;
    costTokens?: number;
    latencyMs?: number;
    raw: InputJsonValue;
    createdAt?: Date | string;
    claim: FactcheckClaimCreateNestedOneWithoutProviderRunsInput;
  };

  export type ProviderRunUncheckedCreateInput = {
    id?: string;
    claimId: string;
    provider: string;
    verdict: string;
    confidence: number;
    costTokens?: number;
    latencyMs?: number;
    raw: InputJsonValue;
    createdAt?: Date | string;
  };

  export type ProviderRunUpdateInput = {
    provider?: StringFieldUpdateOperationsInput | string;
    verdict?: StringFieldUpdateOperationsInput | string;
    confidence?: FloatFieldUpdateOperationsInput | number;
    costTokens?: IntFieldUpdateOperationsInput | number;
    latencyMs?: IntFieldUpdateOperationsInput | number;
    raw?: InputJsonValue | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    claim?: FactcheckClaimUpdateOneRequiredWithoutProviderRunsNestedInput;
  };

  export type ProviderRunUncheckedUpdateInput = {
    claimId?: StringFieldUpdateOperationsInput | string;
    provider?: StringFieldUpdateOperationsInput | string;
    verdict?: StringFieldUpdateOperationsInput | string;
    confidence?: FloatFieldUpdateOperationsInput | number;
    costTokens?: IntFieldUpdateOperationsInput | number;
    latencyMs?: IntFieldUpdateOperationsInput | number;
    raw?: InputJsonValue | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ProviderRunCreateManyInput = {
    id?: string;
    claimId: string;
    provider: string;
    verdict: string;
    confidence: number;
    costTokens?: number;
    latencyMs?: number;
    raw: InputJsonValue;
    createdAt?: Date | string;
  };

  export type ProviderRunUpdateManyMutationInput = {
    provider?: StringFieldUpdateOperationsInput | string;
    verdict?: StringFieldUpdateOperationsInput | string;
    confidence?: FloatFieldUpdateOperationsInput | number;
    costTokens?: IntFieldUpdateOperationsInput | number;
    latencyMs?: IntFieldUpdateOperationsInput | number;
    raw?: InputJsonValue | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ProviderRunUncheckedUpdateManyInput = {
    claimId?: StringFieldUpdateOperationsInput | string;
    provider?: StringFieldUpdateOperationsInput | string;
    verdict?: StringFieldUpdateOperationsInput | string;
    confidence?: FloatFieldUpdateOperationsInput | number;
    costTokens?: IntFieldUpdateOperationsInput | number;
    latencyMs?: IntFieldUpdateOperationsInput | number;
    raw?: InputJsonValue | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ConsensusRunCreateInput = {
    id?: string;
    method: string;
    verdict: string;
    confidence: number;
    balanceScore: number;
    diversityIndex: number;
    providers: InputJsonValue;
    createdAt?: Date | string;
    claim: FactcheckClaimCreateNestedOneWithoutConsensusInput;
  };

  export type ConsensusRunUncheckedCreateInput = {
    id?: string;
    claimId: string;
    method: string;
    verdict: string;
    confidence: number;
    balanceScore: number;
    diversityIndex: number;
    providers: InputJsonValue;
    createdAt?: Date | string;
  };

  export type ConsensusRunUpdateInput = {
    method?: StringFieldUpdateOperationsInput | string;
    verdict?: StringFieldUpdateOperationsInput | string;
    confidence?: FloatFieldUpdateOperationsInput | number;
    balanceScore?: FloatFieldUpdateOperationsInput | number;
    diversityIndex?: FloatFieldUpdateOperationsInput | number;
    providers?: InputJsonValue | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    claim?: FactcheckClaimUpdateOneRequiredWithoutConsensusNestedInput;
  };

  export type ConsensusRunUncheckedUpdateInput = {
    claimId?: StringFieldUpdateOperationsInput | string;
    method?: StringFieldUpdateOperationsInput | string;
    verdict?: StringFieldUpdateOperationsInput | string;
    confidence?: FloatFieldUpdateOperationsInput | number;
    balanceScore?: FloatFieldUpdateOperationsInput | number;
    diversityIndex?: FloatFieldUpdateOperationsInput | number;
    providers?: InputJsonValue | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ConsensusRunCreateManyInput = {
    id?: string;
    claimId: string;
    method: string;
    verdict: string;
    confidence: number;
    balanceScore: number;
    diversityIndex: number;
    providers: InputJsonValue;
    createdAt?: Date | string;
  };

  export type ConsensusRunUpdateManyMutationInput = {
    method?: StringFieldUpdateOperationsInput | string;
    verdict?: StringFieldUpdateOperationsInput | string;
    confidence?: FloatFieldUpdateOperationsInput | number;
    balanceScore?: FloatFieldUpdateOperationsInput | number;
    diversityIndex?: FloatFieldUpdateOperationsInput | number;
    providers?: InputJsonValue | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ConsensusRunUncheckedUpdateManyInput = {
    claimId?: StringFieldUpdateOperationsInput | string;
    method?: StringFieldUpdateOperationsInput | string;
    verdict?: StringFieldUpdateOperationsInput | string;
    confidence?: FloatFieldUpdateOperationsInput | number;
    balanceScore?: FloatFieldUpdateOperationsInput | number;
    diversityIndex?: FloatFieldUpdateOperationsInput | number;
    providers?: InputJsonValue | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type EvidenceCreateInput = {
    id?: string;
    url: string;
    domain: string;
    stance: $Enums.Stance;
    snapshotHash?: string | null;
    firstSeenAt?: Date | string | null;
    trustScore?: number | null;
    claim: FactcheckClaimCreateNestedOneWithoutEvidencesInput;
  };

  export type EvidenceUncheckedCreateInput = {
    id?: string;
    claimId: string;
    url: string;
    domain: string;
    stance: $Enums.Stance;
    snapshotHash?: string | null;
    firstSeenAt?: Date | string | null;
    trustScore?: number | null;
  };

  export type EvidenceUpdateInput = {
    url?: StringFieldUpdateOperationsInput | string;
    domain?: StringFieldUpdateOperationsInput | string;
    stance?: EnumStanceFieldUpdateOperationsInput | $Enums.Stance;
    snapshotHash?: NullableStringFieldUpdateOperationsInput | string | null;
    firstSeenAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    trustScore?: NullableIntFieldUpdateOperationsInput | number | null;
    claim?: FactcheckClaimUpdateOneRequiredWithoutEvidencesNestedInput;
  };

  export type EvidenceUncheckedUpdateInput = {
    claimId?: StringFieldUpdateOperationsInput | string;
    url?: StringFieldUpdateOperationsInput | string;
    domain?: StringFieldUpdateOperationsInput | string;
    stance?: EnumStanceFieldUpdateOperationsInput | $Enums.Stance;
    snapshotHash?: NullableStringFieldUpdateOperationsInput | string | null;
    firstSeenAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    trustScore?: NullableIntFieldUpdateOperationsInput | number | null;
  };

  export type EvidenceCreateManyInput = {
    id?: string;
    claimId: string;
    url: string;
    domain: string;
    stance: $Enums.Stance;
    snapshotHash?: string | null;
    firstSeenAt?: Date | string | null;
    trustScore?: number | null;
  };

  export type EvidenceUpdateManyMutationInput = {
    url?: StringFieldUpdateOperationsInput | string;
    domain?: StringFieldUpdateOperationsInput | string;
    stance?: EnumStanceFieldUpdateOperationsInput | $Enums.Stance;
    snapshotHash?: NullableStringFieldUpdateOperationsInput | string | null;
    firstSeenAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    trustScore?: NullableIntFieldUpdateOperationsInput | number | null;
  };

  export type EvidenceUncheckedUpdateManyInput = {
    claimId?: StringFieldUpdateOperationsInput | string;
    url?: StringFieldUpdateOperationsInput | string;
    domain?: StringFieldUpdateOperationsInput | string;
    stance?: EnumStanceFieldUpdateOperationsInput | $Enums.Stance;
    snapshotHash?: NullableStringFieldUpdateOperationsInput | string | null;
    firstSeenAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    trustScore?: NullableIntFieldUpdateOperationsInput | number | null;
  };

  export type VerdictVersionCreateInput = {
    id?: string;
    verdict: string;
    confidence: number;
    asOf?: Date | string;
    supersedes?: string | null;
    claim: FactcheckClaimCreateNestedOneWithoutVerdictVersionsInput;
  };

  export type VerdictVersionUncheckedCreateInput = {
    id?: string;
    claimId: string;
    verdict: string;
    confidence: number;
    asOf?: Date | string;
    supersedes?: string | null;
  };

  export type VerdictVersionUpdateInput = {
    verdict?: StringFieldUpdateOperationsInput | string;
    confidence?: FloatFieldUpdateOperationsInput | number;
    asOf?: DateTimeFieldUpdateOperationsInput | Date | string;
    supersedes?: NullableStringFieldUpdateOperationsInput | string | null;
    claim?: FactcheckClaimUpdateOneRequiredWithoutVerdictVersionsNestedInput;
  };

  export type VerdictVersionUncheckedUpdateInput = {
    claimId?: StringFieldUpdateOperationsInput | string;
    verdict?: StringFieldUpdateOperationsInput | string;
    confidence?: FloatFieldUpdateOperationsInput | number;
    asOf?: DateTimeFieldUpdateOperationsInput | Date | string;
    supersedes?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type VerdictVersionCreateManyInput = {
    id?: string;
    claimId: string;
    verdict: string;
    confidence: number;
    asOf?: Date | string;
    supersedes?: string | null;
  };

  export type VerdictVersionUpdateManyMutationInput = {
    verdict?: StringFieldUpdateOperationsInput | string;
    confidence?: FloatFieldUpdateOperationsInput | number;
    asOf?: DateTimeFieldUpdateOperationsInput | Date | string;
    supersedes?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type VerdictVersionUncheckedUpdateManyInput = {
    claimId?: StringFieldUpdateOperationsInput | string;
    verdict?: StringFieldUpdateOperationsInput | string;
    confidence?: FloatFieldUpdateOperationsInput | number;
    asOf?: DateTimeFieldUpdateOperationsInput | Date | string;
    supersedes?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type FactcheckResultCreateInput = {
    id?: string;
    verdict: string;
    rawOutput: InputJsonValue;
    createdAt?: Date | string;
    job: FactcheckJobCreateNestedOneWithoutResultsInput;
  };

  export type FactcheckResultUncheckedCreateInput = {
    id?: string;
    jobId: string;
    verdict: string;
    rawOutput: InputJsonValue;
    createdAt?: Date | string;
  };

  export type FactcheckResultUpdateInput = {
    verdict?: StringFieldUpdateOperationsInput | string;
    rawOutput?: InputJsonValue | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    job?: FactcheckJobUpdateOneRequiredWithoutResultsNestedInput;
  };

  export type FactcheckResultUncheckedUpdateInput = {
    jobId?: StringFieldUpdateOperationsInput | string;
    verdict?: StringFieldUpdateOperationsInput | string;
    rawOutput?: InputJsonValue | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type FactcheckResultCreateManyInput = {
    id?: string;
    jobId: string;
    verdict: string;
    rawOutput: InputJsonValue;
    createdAt?: Date | string;
  };

  export type FactcheckResultUpdateManyMutationInput = {
    verdict?: StringFieldUpdateOperationsInput | string;
    rawOutput?: InputJsonValue | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type FactcheckResultUncheckedUpdateManyInput = {
    jobId?: StringFieldUpdateOperationsInput | string;
    verdict?: StringFieldUpdateOperationsInput | string;
    rawOutput?: InputJsonValue | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AuditLogCreateInput = {
    id?: string;
    entityType: string;
    entityId: string;
    action: string;
    actor: string;
    at?: Date | string;
    meta: InputJsonValue;
  };

  export type AuditLogUncheckedCreateInput = {
    id?: string;
    entityType: string;
    entityId: string;
    action: string;
    actor: string;
    at?: Date | string;
    meta: InputJsonValue;
  };

  export type AuditLogUpdateInput = {
    entityType?: StringFieldUpdateOperationsInput | string;
    entityId?: StringFieldUpdateOperationsInput | string;
    action?: StringFieldUpdateOperationsInput | string;
    actor?: StringFieldUpdateOperationsInput | string;
    at?: DateTimeFieldUpdateOperationsInput | Date | string;
    meta?: InputJsonValue | InputJsonValue;
  };

  export type AuditLogUncheckedUpdateInput = {
    entityType?: StringFieldUpdateOperationsInput | string;
    entityId?: StringFieldUpdateOperationsInput | string;
    action?: StringFieldUpdateOperationsInput | string;
    actor?: StringFieldUpdateOperationsInput | string;
    at?: DateTimeFieldUpdateOperationsInput | Date | string;
    meta?: InputJsonValue | InputJsonValue;
  };

  export type AuditLogCreateManyInput = {
    id?: string;
    entityType: string;
    entityId: string;
    action: string;
    actor: string;
    at?: Date | string;
    meta: InputJsonValue;
  };

  export type AuditLogUpdateManyMutationInput = {
    entityType?: StringFieldUpdateOperationsInput | string;
    entityId?: StringFieldUpdateOperationsInput | string;
    action?: StringFieldUpdateOperationsInput | string;
    actor?: StringFieldUpdateOperationsInput | string;
    at?: DateTimeFieldUpdateOperationsInput | Date | string;
    meta?: InputJsonValue | InputJsonValue;
  };

  export type AuditLogUncheckedUpdateManyInput = {
    entityType?: StringFieldUpdateOperationsInput | string;
    entityId?: StringFieldUpdateOperationsInput | string;
    action?: StringFieldUpdateOperationsInput | string;
    actor?: StringFieldUpdateOperationsInput | string;
    at?: DateTimeFieldUpdateOperationsInput | Date | string;
    meta?: InputJsonValue | InputJsonValue;
  };

  export type ExtractedUnitCreateInput = {
    id?: string;
    statementId?: string | null;
    kind: $Enums.UnitKind;
    text: string;
    spanStart: number;
    spanEnd: number;
    confidence: number;
    canonicalKey: string;
    scope?: string | null;
    timeframe?: string | null;
    interest?: $Enums.Interest;
    triage?: $Enums.Triage;
    editorNote?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    item?: ContentItemCreateNestedOneWithoutUnitsInput;
    claim?: FactcheckClaimCreateNestedOneWithoutUnitsInput;
  };

  export type ExtractedUnitUncheckedCreateInput = {
    id?: string;
    itemId?: string | null;
    statementId?: string | null;
    kind: $Enums.UnitKind;
    text: string;
    spanStart: number;
    spanEnd: number;
    confidence: number;
    canonicalKey: string;
    scope?: string | null;
    timeframe?: string | null;
    claimId?: string | null;
    interest?: $Enums.Interest;
    triage?: $Enums.Triage;
    editorNote?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type ExtractedUnitUpdateInput = {
    statementId?: NullableStringFieldUpdateOperationsInput | string | null;
    kind?: EnumUnitKindFieldUpdateOperationsInput | $Enums.UnitKind;
    text?: StringFieldUpdateOperationsInput | string;
    spanStart?: IntFieldUpdateOperationsInput | number;
    spanEnd?: IntFieldUpdateOperationsInput | number;
    confidence?: FloatFieldUpdateOperationsInput | number;
    canonicalKey?: StringFieldUpdateOperationsInput | string;
    scope?: NullableStringFieldUpdateOperationsInput | string | null;
    timeframe?: NullableStringFieldUpdateOperationsInput | string | null;
    interest?: EnumInterestFieldUpdateOperationsInput | $Enums.Interest;
    triage?: EnumTriageFieldUpdateOperationsInput | $Enums.Triage;
    editorNote?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    item?: ContentItemUpdateOneWithoutUnitsNestedInput;
    claim?: FactcheckClaimUpdateOneWithoutUnitsNestedInput;
  };

  export type ExtractedUnitUncheckedUpdateInput = {
    itemId?: NullableStringFieldUpdateOperationsInput | string | null;
    statementId?: NullableStringFieldUpdateOperationsInput | string | null;
    kind?: EnumUnitKindFieldUpdateOperationsInput | $Enums.UnitKind;
    text?: StringFieldUpdateOperationsInput | string;
    spanStart?: IntFieldUpdateOperationsInput | number;
    spanEnd?: IntFieldUpdateOperationsInput | number;
    confidence?: FloatFieldUpdateOperationsInput | number;
    canonicalKey?: StringFieldUpdateOperationsInput | string;
    scope?: NullableStringFieldUpdateOperationsInput | string | null;
    timeframe?: NullableStringFieldUpdateOperationsInput | string | null;
    claimId?: NullableStringFieldUpdateOperationsInput | string | null;
    interest?: EnumInterestFieldUpdateOperationsInput | $Enums.Interest;
    triage?: EnumTriageFieldUpdateOperationsInput | $Enums.Triage;
    editorNote?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ExtractedUnitCreateManyInput = {
    id?: string;
    itemId?: string | null;
    statementId?: string | null;
    kind: $Enums.UnitKind;
    text: string;
    spanStart: number;
    spanEnd: number;
    confidence: number;
    canonicalKey: string;
    scope?: string | null;
    timeframe?: string | null;
    claimId?: string | null;
    interest?: $Enums.Interest;
    triage?: $Enums.Triage;
    editorNote?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type ExtractedUnitUpdateManyMutationInput = {
    statementId?: NullableStringFieldUpdateOperationsInput | string | null;
    kind?: EnumUnitKindFieldUpdateOperationsInput | $Enums.UnitKind;
    text?: StringFieldUpdateOperationsInput | string;
    spanStart?: IntFieldUpdateOperationsInput | number;
    spanEnd?: IntFieldUpdateOperationsInput | number;
    confidence?: FloatFieldUpdateOperationsInput | number;
    canonicalKey?: StringFieldUpdateOperationsInput | string;
    scope?: NullableStringFieldUpdateOperationsInput | string | null;
    timeframe?: NullableStringFieldUpdateOperationsInput | string | null;
    interest?: EnumInterestFieldUpdateOperationsInput | $Enums.Interest;
    triage?: EnumTriageFieldUpdateOperationsInput | $Enums.Triage;
    editorNote?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ExtractedUnitUncheckedUpdateManyInput = {
    itemId?: NullableStringFieldUpdateOperationsInput | string | null;
    statementId?: NullableStringFieldUpdateOperationsInput | string | null;
    kind?: EnumUnitKindFieldUpdateOperationsInput | $Enums.UnitKind;
    text?: StringFieldUpdateOperationsInput | string;
    spanStart?: IntFieldUpdateOperationsInput | number;
    spanEnd?: IntFieldUpdateOperationsInput | number;
    confidence?: FloatFieldUpdateOperationsInput | number;
    canonicalKey?: StringFieldUpdateOperationsInput | string;
    scope?: NullableStringFieldUpdateOperationsInput | string | null;
    timeframe?: NullableStringFieldUpdateOperationsInput | string | null;
    claimId?: NullableStringFieldUpdateOperationsInput | string | null;
    interest?: EnumInterestFieldUpdateOperationsInput | $Enums.Interest;
    triage?: EnumTriageFieldUpdateOperationsInput | $Enums.Triage;
    editorNote?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type FindingCreateInput = {
    id?: string;
    summary: string;
    outcome: string;
    rationale: string;
    metrics?: InputJsonValue | null;
    comparedJurisdictions?: InputJsonValue | null;
    lastChecked?: Date | string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    claim: FactcheckClaimCreateNestedOneWithoutFindingInput;
  };

  export type FindingUncheckedCreateInput = {
    id?: string;
    claimId: string;
    summary: string;
    outcome: string;
    rationale: string;
    metrics?: InputJsonValue | null;
    comparedJurisdictions?: InputJsonValue | null;
    lastChecked?: Date | string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type FindingUpdateInput = {
    summary?: StringFieldUpdateOperationsInput | string;
    outcome?: StringFieldUpdateOperationsInput | string;
    rationale?: StringFieldUpdateOperationsInput | string;
    metrics?: InputJsonValue | InputJsonValue | null;
    comparedJurisdictions?: InputJsonValue | InputJsonValue | null;
    lastChecked?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    claim?: FactcheckClaimUpdateOneRequiredWithoutFindingNestedInput;
  };

  export type FindingUncheckedUpdateInput = {
    claimId?: StringFieldUpdateOperationsInput | string;
    summary?: StringFieldUpdateOperationsInput | string;
    outcome?: StringFieldUpdateOperationsInput | string;
    rationale?: StringFieldUpdateOperationsInput | string;
    metrics?: InputJsonValue | InputJsonValue | null;
    comparedJurisdictions?: InputJsonValue | InputJsonValue | null;
    lastChecked?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type FindingCreateManyInput = {
    id?: string;
    claimId: string;
    summary: string;
    outcome: string;
    rationale: string;
    metrics?: InputJsonValue | null;
    comparedJurisdictions?: InputJsonValue | null;
    lastChecked?: Date | string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type FindingUpdateManyMutationInput = {
    summary?: StringFieldUpdateOperationsInput | string;
    outcome?: StringFieldUpdateOperationsInput | string;
    rationale?: StringFieldUpdateOperationsInput | string;
    metrics?: InputJsonValue | InputJsonValue | null;
    comparedJurisdictions?: InputJsonValue | InputJsonValue | null;
    lastChecked?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type FindingUncheckedUpdateManyInput = {
    claimId?: StringFieldUpdateOperationsInput | string;
    summary?: StringFieldUpdateOperationsInput | string;
    outcome?: StringFieldUpdateOperationsInput | string;
    rationale?: StringFieldUpdateOperationsInput | string;
    metrics?: InputJsonValue | InputJsonValue | null;
    comparedJurisdictions?: InputJsonValue | InputJsonValue | null;
    lastChecked?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AdminSettingsCreateInput = {
    id?: string;
    onboarding?: InputJsonValue | null;
    csp?: InputJsonValue | null;
    updatedAt?: Date | string;
  };

  export type AdminSettingsUncheckedCreateInput = {
    id?: string;
    onboarding?: InputJsonValue | null;
    csp?: InputJsonValue | null;
    updatedAt?: Date | string;
  };

  export type AdminSettingsUpdateInput = {
    onboarding?: InputJsonValue | InputJsonValue | null;
    csp?: InputJsonValue | InputJsonValue | null;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AdminSettingsUncheckedUpdateInput = {
    onboarding?: InputJsonValue | InputJsonValue | null;
    csp?: InputJsonValue | InputJsonValue | null;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AdminSettingsCreateManyInput = {
    id?: string;
    onboarding?: InputJsonValue | null;
    csp?: InputJsonValue | null;
    updatedAt?: Date | string;
  };

  export type AdminSettingsUpdateManyMutationInput = {
    onboarding?: InputJsonValue | InputJsonValue | null;
    csp?: InputJsonValue | InputJsonValue | null;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AdminSettingsUncheckedUpdateManyInput = {
    onboarding?: InputJsonValue | InputJsonValue | null;
    csp?: InputJsonValue | InputJsonValue | null;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    mode?: QueryMode;
    not?: NestedStringFilter<$PrismaModel> | string;
  };

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    mode?: QueryMode;
    not?: NestedStringNullableFilter<$PrismaModel> | string | null;
    isSet?: boolean;
  };

  export type EnumLocaleFilter<$PrismaModel = never> = {
    equals?: $Enums.Locale | EnumLocaleFieldRefInput<$PrismaModel>;
    in?: $Enums.Locale[] | ListEnumLocaleFieldRefInput<$PrismaModel>;
    notIn?: $Enums.Locale[] | ListEnumLocaleFieldRefInput<$PrismaModel>;
    not?: NestedEnumLocaleFilter<$PrismaModel> | $Enums.Locale;
  };

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string;
  };

  export type ContentItemListRelationFilter = {
    every?: ContentItemWhereInput;
    some?: ContentItemWhereInput;
    none?: ContentItemWhereInput;
  };

  export type TopicTagListRelationFilter = {
    every?: TopicTagWhereInput;
    some?: TopicTagWhereInput;
    none?: TopicTagWhereInput;
  };

  export type ContentItemOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type TopicTagOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type TopicCountOrderByAggregateInput = {
    id?: SortOrder;
    slug?: SortOrder;
    title?: SortOrder;
    description?: SortOrder;
    locale?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type TopicMaxOrderByAggregateInput = {
    id?: SortOrder;
    slug?: SortOrder;
    title?: SortOrder;
    description?: SortOrder;
    locale?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type TopicMinOrderByAggregateInput = {
    id?: SortOrder;
    slug?: SortOrder;
    title?: SortOrder;
    description?: SortOrder;
    locale?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    mode?: QueryMode;
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedStringFilter<$PrismaModel>;
    _max?: NestedStringFilter<$PrismaModel>;
  };

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    mode?: QueryMode;
    not?:
      | NestedStringNullableWithAggregatesFilter<$PrismaModel>
      | string
      | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedStringNullableFilter<$PrismaModel>;
    _max?: NestedStringNullableFilter<$PrismaModel>;
    isSet?: boolean;
  };

  export type EnumLocaleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Locale | EnumLocaleFieldRefInput<$PrismaModel>;
    in?: $Enums.Locale[] | ListEnumLocaleFieldRefInput<$PrismaModel>;
    notIn?: $Enums.Locale[] | ListEnumLocaleFieldRefInput<$PrismaModel>;
    not?: NestedEnumLocaleWithAggregatesFilter<$PrismaModel> | $Enums.Locale;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumLocaleFilter<$PrismaModel>;
    _max?: NestedEnumLocaleFilter<$PrismaModel>;
  };

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedDateTimeFilter<$PrismaModel>;
    _max?: NestedDateTimeFilter<$PrismaModel>;
  };

  export type ItemTagListRelationFilter = {
    every?: ItemTagWhereInput;
    some?: ItemTagWhereInput;
    none?: ItemTagWhereInput;
  };

  export type ItemTagOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type TagCountOrderByAggregateInput = {
    id?: SortOrder;
    slug?: SortOrder;
    label?: SortOrder;
  };

  export type TagMaxOrderByAggregateInput = {
    id?: SortOrder;
    slug?: SortOrder;
    label?: SortOrder;
  };

  export type TagMinOrderByAggregateInput = {
    id?: SortOrder;
    slug?: SortOrder;
    label?: SortOrder;
  };

  export type TopicScalarRelationFilter = {
    is?: TopicWhereInput;
    isNot?: TopicWhereInput;
  };

  export type TagScalarRelationFilter = {
    is?: TagWhereInput;
    isNot?: TagWhereInput;
  };

  export type TopicTagTopicIdTagIdCompoundUniqueInput = {
    topicId: string;
    tagId: string;
  };

  export type TopicTagCountOrderByAggregateInput = {
    id?: SortOrder;
    topicId?: SortOrder;
    tagId?: SortOrder;
  };

  export type TopicTagMaxOrderByAggregateInput = {
    id?: SortOrder;
    topicId?: SortOrder;
    tagId?: SortOrder;
  };

  export type TopicTagMinOrderByAggregateInput = {
    id?: SortOrder;
    topicId?: SortOrder;
    tagId?: SortOrder;
  };

  export type ContentItemScalarRelationFilter = {
    is?: ContentItemWhereInput;
    isNot?: ContentItemWhereInput;
  };

  export type ItemTagItemIdTagIdCompoundUniqueInput = {
    itemId: string;
    tagId: string;
  };

  export type ItemTagCountOrderByAggregateInput = {
    id?: SortOrder;
    itemId?: SortOrder;
    tagId?: SortOrder;
  };

  export type ItemTagMaxOrderByAggregateInput = {
    id?: SortOrder;
    itemId?: SortOrder;
    tagId?: SortOrder;
  };

  export type ItemTagMinOrderByAggregateInput = {
    id?: SortOrder;
    itemId?: SortOrder;
    tagId?: SortOrder;
  };

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[] | ListIntFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntFilter<$PrismaModel> | number;
  };
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<
          Required<JsonNullableFilterBase<$PrismaModel>>,
          Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, "path">
        >,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<
        Omit<Required<JsonNullableFilterBase<$PrismaModel>>, "path">
      >;

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    isSet?: boolean;
  };

  export type RegionNullableScalarRelationFilter = {
    is?: RegionWhereInput | null;
    isNot?: RegionWhereInput | null;
  };

  export type RegionListRelationFilter = {
    every?: RegionWhereInput;
    some?: RegionWhereInput;
    none?: RegionWhereInput;
  };

  export type RegionClosureListRelationFilter = {
    every?: RegionClosureWhereInput;
    some?: RegionClosureWhereInput;
    none?: RegionClosureWhereInput;
  };

  export type RegionOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type RegionClosureOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type RegionCountOrderByAggregateInput = {
    id?: SortOrder;
    code?: SortOrder;
    name?: SortOrder;
    level?: SortOrder;
    parentId?: SortOrder;
    meta?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type RegionAvgOrderByAggregateInput = {
    level?: SortOrder;
  };

  export type RegionMaxOrderByAggregateInput = {
    id?: SortOrder;
    code?: SortOrder;
    name?: SortOrder;
    level?: SortOrder;
    parentId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type RegionMinOrderByAggregateInput = {
    id?: SortOrder;
    code?: SortOrder;
    name?: SortOrder;
    level?: SortOrder;
    parentId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type RegionSumOrderByAggregateInput = {
    level?: SortOrder;
  };

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[] | ListIntFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedFloatFilter<$PrismaModel>;
    _sum?: NestedIntFilter<$PrismaModel>;
    _min?: NestedIntFilter<$PrismaModel>;
    _max?: NestedIntFilter<$PrismaModel>;
  };
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<
          Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>,
          Exclude<
            keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>,
            "path"
          >
        >,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<
        Omit<
          Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>,
          "path"
        >
      >;

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedJsonNullableFilter<$PrismaModel>;
    _max?: NestedJsonNullableFilter<$PrismaModel>;
    isSet?: boolean;
  };

  export type RegionScalarRelationFilter = {
    is?: RegionWhereInput;
    isNot?: RegionWhereInput;
  };

  export type RegionClosureAncestorIdDescendantIdCompoundUniqueInput = {
    ancestorId: string;
    descendantId: string;
  };

  export type RegionClosureCountOrderByAggregateInput = {
    id?: SortOrder;
    ancestorId?: SortOrder;
    descendantId?: SortOrder;
    depth?: SortOrder;
  };

  export type RegionClosureAvgOrderByAggregateInput = {
    depth?: SortOrder;
  };

  export type RegionClosureMaxOrderByAggregateInput = {
    id?: SortOrder;
    ancestorId?: SortOrder;
    descendantId?: SortOrder;
    depth?: SortOrder;
  };

  export type RegionClosureMinOrderByAggregateInput = {
    id?: SortOrder;
    ancestorId?: SortOrder;
    descendantId?: SortOrder;
    depth?: SortOrder;
  };

  export type RegionClosureSumOrderByAggregateInput = {
    depth?: SortOrder;
  };

  export type EnumContentKindFilter<$PrismaModel = never> = {
    equals?: $Enums.ContentKind | EnumContentKindFieldRefInput<$PrismaModel>;
    in?: $Enums.ContentKind[] | ListEnumContentKindFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.ContentKind[]
      | ListEnumContentKindFieldRefInput<$PrismaModel>;
    not?: NestedEnumContentKindFilter<$PrismaModel> | $Enums.ContentKind;
  };

  export type EnumPublishStatusFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.PublishStatus
      | EnumPublishStatusFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.PublishStatus[]
      | ListEnumPublishStatusFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.PublishStatus[]
      | ListEnumPublishStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumPublishStatusFilter<$PrismaModel> | $Enums.PublishStatus;
  };

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null;
    isSet?: boolean;
  };

  export type EnumRegionModeFilter<$PrismaModel = never> = {
    equals?: $Enums.RegionMode | EnumRegionModeFieldRefInput<$PrismaModel>;
    in?: $Enums.RegionMode[] | ListEnumRegionModeFieldRefInput<$PrismaModel>;
    notIn?: $Enums.RegionMode[] | ListEnumRegionModeFieldRefInput<$PrismaModel>;
    not?: NestedEnumRegionModeFilter<$PrismaModel> | $Enums.RegionMode;
  };

  export type ExtractedUnitListRelationFilter = {
    every?: ExtractedUnitWhereInput;
    some?: ExtractedUnitWhereInput;
    none?: ExtractedUnitWhereInput;
  };

  export type AnswerOptionListRelationFilter = {
    every?: AnswerOptionWhereInput;
    some?: AnswerOptionWhereInput;
    none?: AnswerOptionWhereInput;
  };

  export type ExtractedUnitOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type AnswerOptionOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type ContentItemCountOrderByAggregateInput = {
    id?: SortOrder;
    kind?: SortOrder;
    topicId?: SortOrder;
    locale?: SortOrder;
    title?: SortOrder;
    text?: SortOrder;
    richText?: SortOrder;
    sortOrder?: SortOrder;
    status?: SortOrder;
    authorName?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    publishAt?: SortOrder;
    expireAt?: SortOrder;
    regionMode?: SortOrder;
    regionManualId?: SortOrder;
    regionAuto?: SortOrder;
    regionEffectiveId?: SortOrder;
    validation?: SortOrder;
    meta?: SortOrder;
  };

  export type ContentItemAvgOrderByAggregateInput = {
    sortOrder?: SortOrder;
  };

  export type ContentItemMaxOrderByAggregateInput = {
    id?: SortOrder;
    kind?: SortOrder;
    topicId?: SortOrder;
    locale?: SortOrder;
    title?: SortOrder;
    text?: SortOrder;
    richText?: SortOrder;
    sortOrder?: SortOrder;
    status?: SortOrder;
    authorName?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    publishAt?: SortOrder;
    expireAt?: SortOrder;
    regionMode?: SortOrder;
    regionManualId?: SortOrder;
    regionEffectiveId?: SortOrder;
  };

  export type ContentItemMinOrderByAggregateInput = {
    id?: SortOrder;
    kind?: SortOrder;
    topicId?: SortOrder;
    locale?: SortOrder;
    title?: SortOrder;
    text?: SortOrder;
    richText?: SortOrder;
    sortOrder?: SortOrder;
    status?: SortOrder;
    authorName?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    publishAt?: SortOrder;
    expireAt?: SortOrder;
    regionMode?: SortOrder;
    regionManualId?: SortOrder;
    regionEffectiveId?: SortOrder;
  };

  export type ContentItemSumOrderByAggregateInput = {
    sortOrder?: SortOrder;
  };

  export type EnumContentKindWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContentKind | EnumContentKindFieldRefInput<$PrismaModel>;
    in?: $Enums.ContentKind[] | ListEnumContentKindFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.ContentKind[]
      | ListEnumContentKindFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumContentKindWithAggregatesFilter<$PrismaModel>
      | $Enums.ContentKind;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumContentKindFilter<$PrismaModel>;
    _max?: NestedEnumContentKindFilter<$PrismaModel>;
  };

  export type EnumPublishStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.PublishStatus
      | EnumPublishStatusFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.PublishStatus[]
      | ListEnumPublishStatusFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.PublishStatus[]
      | ListEnumPublishStatusFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumPublishStatusWithAggregatesFilter<$PrismaModel>
      | $Enums.PublishStatus;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumPublishStatusFilter<$PrismaModel>;
    _max?: NestedEnumPublishStatusFilter<$PrismaModel>;
  };

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?:
      | NestedDateTimeNullableWithAggregatesFilter<$PrismaModel>
      | Date
      | string
      | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedDateTimeNullableFilter<$PrismaModel>;
    _max?: NestedDateTimeNullableFilter<$PrismaModel>;
    isSet?: boolean;
  };

  export type EnumRegionModeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RegionMode | EnumRegionModeFieldRefInput<$PrismaModel>;
    in?: $Enums.RegionMode[] | ListEnumRegionModeFieldRefInput<$PrismaModel>;
    notIn?: $Enums.RegionMode[] | ListEnumRegionModeFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumRegionModeWithAggregatesFilter<$PrismaModel>
      | $Enums.RegionMode;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumRegionModeFilter<$PrismaModel>;
    _max?: NestedEnumRegionModeFilter<$PrismaModel>;
  };

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
    not?: NestedBoolFilter<$PrismaModel> | boolean;
  };

  export type AnswerOptionItemIdSortOrderCompoundUniqueInput = {
    itemId: string;
    sortOrder: number;
  };

  export type AnswerOptionItemIdValueCompoundUniqueInput = {
    itemId: string;
    value: string;
  };

  export type AnswerOptionCountOrderByAggregateInput = {
    id?: SortOrder;
    itemId?: SortOrder;
    label?: SortOrder;
    value?: SortOrder;
    sortOrder?: SortOrder;
    exclusive?: SortOrder;
    meta?: SortOrder;
  };

  export type AnswerOptionAvgOrderByAggregateInput = {
    sortOrder?: SortOrder;
  };

  export type AnswerOptionMaxOrderByAggregateInput = {
    id?: SortOrder;
    itemId?: SortOrder;
    label?: SortOrder;
    value?: SortOrder;
    sortOrder?: SortOrder;
    exclusive?: SortOrder;
  };

  export type AnswerOptionMinOrderByAggregateInput = {
    id?: SortOrder;
    itemId?: SortOrder;
    label?: SortOrder;
    value?: SortOrder;
    sortOrder?: SortOrder;
    exclusive?: SortOrder;
  };

  export type AnswerOptionSumOrderByAggregateInput = {
    sortOrder?: SortOrder;
  };

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedBoolFilter<$PrismaModel>;
    _max?: NestedBoolFilter<$PrismaModel>;
  };

  export type FactcheckClaimListRelationFilter = {
    every?: FactcheckClaimWhereInput;
    some?: FactcheckClaimWhereInput;
    none?: FactcheckClaimWhereInput;
  };

  export type FactcheckResultListRelationFilter = {
    every?: FactcheckResultWhereInput;
    some?: FactcheckResultWhereInput;
    none?: FactcheckResultWhereInput;
  };

  export type FactcheckClaimOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type FactcheckResultOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type FactcheckJobCountOrderByAggregateInput = {
    id?: SortOrder;
    jobId?: SortOrder;
    contributionId?: SortOrder;
    status?: SortOrder;
    tokensUsed?: SortOrder;
    durationMs?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type FactcheckJobAvgOrderByAggregateInput = {
    tokensUsed?: SortOrder;
    durationMs?: SortOrder;
  };

  export type FactcheckJobMaxOrderByAggregateInput = {
    id?: SortOrder;
    jobId?: SortOrder;
    contributionId?: SortOrder;
    status?: SortOrder;
    tokensUsed?: SortOrder;
    durationMs?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type FactcheckJobMinOrderByAggregateInput = {
    id?: SortOrder;
    jobId?: SortOrder;
    contributionId?: SortOrder;
    status?: SortOrder;
    tokensUsed?: SortOrder;
    durationMs?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type FactcheckJobSumOrderByAggregateInput = {
    tokensUsed?: SortOrder;
    durationMs?: SortOrder;
  };

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    has?: string | StringFieldRefInput<$PrismaModel> | null;
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>;
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>;
    isEmpty?: boolean;
  };

  export type EnumReviewStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ReviewStatus | EnumReviewStatusFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.ReviewStatus[]
      | ListEnumReviewStatusFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.ReviewStatus[]
      | ListEnumReviewStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumReviewStatusFilter<$PrismaModel> | $Enums.ReviewStatus;
  };

  export type FactcheckJobScalarRelationFilter = {
    is?: FactcheckJobWhereInput;
    isNot?: FactcheckJobWhereInput;
  };

  export type ProviderRunListRelationFilter = {
    every?: ProviderRunWhereInput;
    some?: ProviderRunWhereInput;
    none?: ProviderRunWhereInput;
  };

  export type EvidenceListRelationFilter = {
    every?: EvidenceWhereInput;
    some?: EvidenceWhereInput;
    none?: EvidenceWhereInput;
  };

  export type ConsensusRunNullableScalarRelationFilter = {
    is?: ConsensusRunWhereInput | null;
    isNot?: ConsensusRunWhereInput | null;
  };

  export type VerdictVersionListRelationFilter = {
    every?: VerdictVersionWhereInput;
    some?: VerdictVersionWhereInput;
    none?: VerdictVersionWhereInput;
  };

  export type FindingNullableScalarRelationFilter = {
    is?: FindingWhereInput | null;
    isNot?: FindingWhereInput | null;
  };

  export type ProviderRunOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type EvidenceOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type VerdictVersionOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type FactcheckClaimCountOrderByAggregateInput = {
    id?: SortOrder;
    jobId?: SortOrder;
    text?: SortOrder;
    language?: SortOrder;
    topic?: SortOrder;
    falsifiable?: SortOrder;
    frames?: SortOrder;
    rhetoricalFlags?: SortOrder;
    canonicalKey?: SortOrder;
    scope?: SortOrder;
    timeframe?: SortOrder;
    status?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type FactcheckClaimMaxOrderByAggregateInput = {
    id?: SortOrder;
    jobId?: SortOrder;
    text?: SortOrder;
    language?: SortOrder;
    topic?: SortOrder;
    falsifiable?: SortOrder;
    canonicalKey?: SortOrder;
    scope?: SortOrder;
    timeframe?: SortOrder;
    status?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type FactcheckClaimMinOrderByAggregateInput = {
    id?: SortOrder;
    jobId?: SortOrder;
    text?: SortOrder;
    language?: SortOrder;
    topic?: SortOrder;
    falsifiable?: SortOrder;
    canonicalKey?: SortOrder;
    scope?: SortOrder;
    timeframe?: SortOrder;
    status?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type EnumReviewStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReviewStatus | EnumReviewStatusFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.ReviewStatus[]
      | ListEnumReviewStatusFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.ReviewStatus[]
      | ListEnumReviewStatusFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumReviewStatusWithAggregatesFilter<$PrismaModel>
      | $Enums.ReviewStatus;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumReviewStatusFilter<$PrismaModel>;
    _max?: NestedEnumReviewStatusFilter<$PrismaModel>;
  };

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatFilter<$PrismaModel> | number;
  };
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<
          Required<JsonFilterBase<$PrismaModel>>,
          Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, "path">
        >,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, "path">>;

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
  };

  export type FactcheckClaimScalarRelationFilter = {
    is?: FactcheckClaimWhereInput;
    isNot?: FactcheckClaimWhereInput;
  };

  export type ProviderRunCountOrderByAggregateInput = {
    id?: SortOrder;
    claimId?: SortOrder;
    provider?: SortOrder;
    verdict?: SortOrder;
    confidence?: SortOrder;
    costTokens?: SortOrder;
    latencyMs?: SortOrder;
    raw?: SortOrder;
    createdAt?: SortOrder;
  };

  export type ProviderRunAvgOrderByAggregateInput = {
    confidence?: SortOrder;
    costTokens?: SortOrder;
    latencyMs?: SortOrder;
  };

  export type ProviderRunMaxOrderByAggregateInput = {
    id?: SortOrder;
    claimId?: SortOrder;
    provider?: SortOrder;
    verdict?: SortOrder;
    confidence?: SortOrder;
    costTokens?: SortOrder;
    latencyMs?: SortOrder;
    createdAt?: SortOrder;
  };

  export type ProviderRunMinOrderByAggregateInput = {
    id?: SortOrder;
    claimId?: SortOrder;
    provider?: SortOrder;
    verdict?: SortOrder;
    confidence?: SortOrder;
    costTokens?: SortOrder;
    latencyMs?: SortOrder;
    createdAt?: SortOrder;
  };

  export type ProviderRunSumOrderByAggregateInput = {
    confidence?: SortOrder;
    costTokens?: SortOrder;
    latencyMs?: SortOrder;
  };

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedFloatFilter<$PrismaModel>;
    _sum?: NestedFloatFilter<$PrismaModel>;
    _min?: NestedFloatFilter<$PrismaModel>;
    _max?: NestedFloatFilter<$PrismaModel>;
  };
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<
          Required<JsonWithAggregatesFilterBase<$PrismaModel>>,
          Exclude<
            keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>,
            "path"
          >
        >,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<
        Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, "path">
      >;

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedJsonFilter<$PrismaModel>;
    _max?: NestedJsonFilter<$PrismaModel>;
  };

  export type ConsensusRunCountOrderByAggregateInput = {
    id?: SortOrder;
    claimId?: SortOrder;
    method?: SortOrder;
    verdict?: SortOrder;
    confidence?: SortOrder;
    balanceScore?: SortOrder;
    diversityIndex?: SortOrder;
    providers?: SortOrder;
    createdAt?: SortOrder;
  };

  export type ConsensusRunAvgOrderByAggregateInput = {
    confidence?: SortOrder;
    balanceScore?: SortOrder;
    diversityIndex?: SortOrder;
  };

  export type ConsensusRunMaxOrderByAggregateInput = {
    id?: SortOrder;
    claimId?: SortOrder;
    method?: SortOrder;
    verdict?: SortOrder;
    confidence?: SortOrder;
    balanceScore?: SortOrder;
    diversityIndex?: SortOrder;
    createdAt?: SortOrder;
  };

  export type ConsensusRunMinOrderByAggregateInput = {
    id?: SortOrder;
    claimId?: SortOrder;
    method?: SortOrder;
    verdict?: SortOrder;
    confidence?: SortOrder;
    balanceScore?: SortOrder;
    diversityIndex?: SortOrder;
    createdAt?: SortOrder;
  };

  export type ConsensusRunSumOrderByAggregateInput = {
    confidence?: SortOrder;
    balanceScore?: SortOrder;
    diversityIndex?: SortOrder;
  };

  export type EnumStanceFilter<$PrismaModel = never> = {
    equals?: $Enums.Stance | EnumStanceFieldRefInput<$PrismaModel>;
    in?: $Enums.Stance[] | ListEnumStanceFieldRefInput<$PrismaModel>;
    notIn?: $Enums.Stance[] | ListEnumStanceFieldRefInput<$PrismaModel>;
    not?: NestedEnumStanceFilter<$PrismaModel> | $Enums.Stance;
  };

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableFilter<$PrismaModel> | number | null;
    isSet?: boolean;
  };

  export type EvidenceCountOrderByAggregateInput = {
    id?: SortOrder;
    claimId?: SortOrder;
    url?: SortOrder;
    domain?: SortOrder;
    stance?: SortOrder;
    snapshotHash?: SortOrder;
    firstSeenAt?: SortOrder;
    trustScore?: SortOrder;
  };

  export type EvidenceAvgOrderByAggregateInput = {
    trustScore?: SortOrder;
  };

  export type EvidenceMaxOrderByAggregateInput = {
    id?: SortOrder;
    claimId?: SortOrder;
    url?: SortOrder;
    domain?: SortOrder;
    stance?: SortOrder;
    snapshotHash?: SortOrder;
    firstSeenAt?: SortOrder;
    trustScore?: SortOrder;
  };

  export type EvidenceMinOrderByAggregateInput = {
    id?: SortOrder;
    claimId?: SortOrder;
    url?: SortOrder;
    domain?: SortOrder;
    stance?: SortOrder;
    snapshotHash?: SortOrder;
    firstSeenAt?: SortOrder;
    trustScore?: SortOrder;
  };

  export type EvidenceSumOrderByAggregateInput = {
    trustScore?: SortOrder;
  };

  export type EnumStanceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Stance | EnumStanceFieldRefInput<$PrismaModel>;
    in?: $Enums.Stance[] | ListEnumStanceFieldRefInput<$PrismaModel>;
    notIn?: $Enums.Stance[] | ListEnumStanceFieldRefInput<$PrismaModel>;
    not?: NestedEnumStanceWithAggregatesFilter<$PrismaModel> | $Enums.Stance;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumStanceFilter<$PrismaModel>;
    _max?: NestedEnumStanceFilter<$PrismaModel>;
  };

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _avg?: NestedFloatNullableFilter<$PrismaModel>;
    _sum?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedIntNullableFilter<$PrismaModel>;
    _max?: NestedIntNullableFilter<$PrismaModel>;
    isSet?: boolean;
  };

  export type VerdictVersionCountOrderByAggregateInput = {
    id?: SortOrder;
    claimId?: SortOrder;
    verdict?: SortOrder;
    confidence?: SortOrder;
    asOf?: SortOrder;
    supersedes?: SortOrder;
  };

  export type VerdictVersionAvgOrderByAggregateInput = {
    confidence?: SortOrder;
  };

  export type VerdictVersionMaxOrderByAggregateInput = {
    id?: SortOrder;
    claimId?: SortOrder;
    verdict?: SortOrder;
    confidence?: SortOrder;
    asOf?: SortOrder;
    supersedes?: SortOrder;
  };

  export type VerdictVersionMinOrderByAggregateInput = {
    id?: SortOrder;
    claimId?: SortOrder;
    verdict?: SortOrder;
    confidence?: SortOrder;
    asOf?: SortOrder;
    supersedes?: SortOrder;
  };

  export type VerdictVersionSumOrderByAggregateInput = {
    confidence?: SortOrder;
  };

  export type FactcheckResultCountOrderByAggregateInput = {
    id?: SortOrder;
    jobId?: SortOrder;
    verdict?: SortOrder;
    rawOutput?: SortOrder;
    createdAt?: SortOrder;
  };

  export type FactcheckResultMaxOrderByAggregateInput = {
    id?: SortOrder;
    jobId?: SortOrder;
    verdict?: SortOrder;
    createdAt?: SortOrder;
  };

  export type FactcheckResultMinOrderByAggregateInput = {
    id?: SortOrder;
    jobId?: SortOrder;
    verdict?: SortOrder;
    createdAt?: SortOrder;
  };

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder;
    entityType?: SortOrder;
    entityId?: SortOrder;
    action?: SortOrder;
    actor?: SortOrder;
    at?: SortOrder;
    meta?: SortOrder;
  };

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder;
    entityType?: SortOrder;
    entityId?: SortOrder;
    action?: SortOrder;
    actor?: SortOrder;
    at?: SortOrder;
  };

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder;
    entityType?: SortOrder;
    entityId?: SortOrder;
    action?: SortOrder;
    actor?: SortOrder;
    at?: SortOrder;
  };

  export type EnumUnitKindFilter<$PrismaModel = never> = {
    equals?: $Enums.UnitKind | EnumUnitKindFieldRefInput<$PrismaModel>;
    in?: $Enums.UnitKind[] | ListEnumUnitKindFieldRefInput<$PrismaModel>;
    notIn?: $Enums.UnitKind[] | ListEnumUnitKindFieldRefInput<$PrismaModel>;
    not?: NestedEnumUnitKindFilter<$PrismaModel> | $Enums.UnitKind;
  };

  export type EnumInterestFilter<$PrismaModel = never> = {
    equals?: $Enums.Interest | EnumInterestFieldRefInput<$PrismaModel>;
    in?: $Enums.Interest[] | ListEnumInterestFieldRefInput<$PrismaModel>;
    notIn?: $Enums.Interest[] | ListEnumInterestFieldRefInput<$PrismaModel>;
    not?: NestedEnumInterestFilter<$PrismaModel> | $Enums.Interest;
  };

  export type EnumTriageFilter<$PrismaModel = never> = {
    equals?: $Enums.Triage | EnumTriageFieldRefInput<$PrismaModel>;
    in?: $Enums.Triage[] | ListEnumTriageFieldRefInput<$PrismaModel>;
    notIn?: $Enums.Triage[] | ListEnumTriageFieldRefInput<$PrismaModel>;
    not?: NestedEnumTriageFilter<$PrismaModel> | $Enums.Triage;
  };

  export type ContentItemNullableScalarRelationFilter = {
    is?: ContentItemWhereInput | null;
    isNot?: ContentItemWhereInput | null;
  };

  export type FactcheckClaimNullableScalarRelationFilter = {
    is?: FactcheckClaimWhereInput | null;
    isNot?: FactcheckClaimWhereInput | null;
  };

  export type ExtractedUnitCountOrderByAggregateInput = {
    id?: SortOrder;
    itemId?: SortOrder;
    statementId?: SortOrder;
    kind?: SortOrder;
    text?: SortOrder;
    spanStart?: SortOrder;
    spanEnd?: SortOrder;
    confidence?: SortOrder;
    canonicalKey?: SortOrder;
    scope?: SortOrder;
    timeframe?: SortOrder;
    claimId?: SortOrder;
    interest?: SortOrder;
    triage?: SortOrder;
    editorNote?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type ExtractedUnitAvgOrderByAggregateInput = {
    spanStart?: SortOrder;
    spanEnd?: SortOrder;
    confidence?: SortOrder;
  };

  export type ExtractedUnitMaxOrderByAggregateInput = {
    id?: SortOrder;
    itemId?: SortOrder;
    statementId?: SortOrder;
    kind?: SortOrder;
    text?: SortOrder;
    spanStart?: SortOrder;
    spanEnd?: SortOrder;
    confidence?: SortOrder;
    canonicalKey?: SortOrder;
    scope?: SortOrder;
    timeframe?: SortOrder;
    claimId?: SortOrder;
    interest?: SortOrder;
    triage?: SortOrder;
    editorNote?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type ExtractedUnitMinOrderByAggregateInput = {
    id?: SortOrder;
    itemId?: SortOrder;
    statementId?: SortOrder;
    kind?: SortOrder;
    text?: SortOrder;
    spanStart?: SortOrder;
    spanEnd?: SortOrder;
    confidence?: SortOrder;
    canonicalKey?: SortOrder;
    scope?: SortOrder;
    timeframe?: SortOrder;
    claimId?: SortOrder;
    interest?: SortOrder;
    triage?: SortOrder;
    editorNote?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type ExtractedUnitSumOrderByAggregateInput = {
    spanStart?: SortOrder;
    spanEnd?: SortOrder;
    confidence?: SortOrder;
  };

  export type EnumUnitKindWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UnitKind | EnumUnitKindFieldRefInput<$PrismaModel>;
    in?: $Enums.UnitKind[] | ListEnumUnitKindFieldRefInput<$PrismaModel>;
    notIn?: $Enums.UnitKind[] | ListEnumUnitKindFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumUnitKindWithAggregatesFilter<$PrismaModel>
      | $Enums.UnitKind;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumUnitKindFilter<$PrismaModel>;
    _max?: NestedEnumUnitKindFilter<$PrismaModel>;
  };

  export type EnumInterestWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Interest | EnumInterestFieldRefInput<$PrismaModel>;
    in?: $Enums.Interest[] | ListEnumInterestFieldRefInput<$PrismaModel>;
    notIn?: $Enums.Interest[] | ListEnumInterestFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumInterestWithAggregatesFilter<$PrismaModel>
      | $Enums.Interest;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumInterestFilter<$PrismaModel>;
    _max?: NestedEnumInterestFilter<$PrismaModel>;
  };

  export type EnumTriageWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Triage | EnumTriageFieldRefInput<$PrismaModel>;
    in?: $Enums.Triage[] | ListEnumTriageFieldRefInput<$PrismaModel>;
    notIn?: $Enums.Triage[] | ListEnumTriageFieldRefInput<$PrismaModel>;
    not?: NestedEnumTriageWithAggregatesFilter<$PrismaModel> | $Enums.Triage;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumTriageFilter<$PrismaModel>;
    _max?: NestedEnumTriageFilter<$PrismaModel>;
  };

  export type FindingCountOrderByAggregateInput = {
    id?: SortOrder;
    claimId?: SortOrder;
    summary?: SortOrder;
    outcome?: SortOrder;
    rationale?: SortOrder;
    metrics?: SortOrder;
    comparedJurisdictions?: SortOrder;
    lastChecked?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type FindingMaxOrderByAggregateInput = {
    id?: SortOrder;
    claimId?: SortOrder;
    summary?: SortOrder;
    outcome?: SortOrder;
    rationale?: SortOrder;
    lastChecked?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type FindingMinOrderByAggregateInput = {
    id?: SortOrder;
    claimId?: SortOrder;
    summary?: SortOrder;
    outcome?: SortOrder;
    rationale?: SortOrder;
    lastChecked?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type AdminSettingsCountOrderByAggregateInput = {
    id?: SortOrder;
    onboarding?: SortOrder;
    csp?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type AdminSettingsMaxOrderByAggregateInput = {
    id?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type AdminSettingsMinOrderByAggregateInput = {
    id?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type ContentItemCreateNestedManyWithoutTopicInput = {
    create?:
      | XOR<
          ContentItemCreateWithoutTopicInput,
          ContentItemUncheckedCreateWithoutTopicInput
        >
      | ContentItemCreateWithoutTopicInput[]
      | ContentItemUncheckedCreateWithoutTopicInput[];
    connectOrCreate?:
      | ContentItemCreateOrConnectWithoutTopicInput
      | ContentItemCreateOrConnectWithoutTopicInput[];
    createMany?: ContentItemCreateManyTopicInputEnvelope;
    connect?: ContentItemWhereUniqueInput | ContentItemWhereUniqueInput[];
  };

  export type TopicTagCreateNestedManyWithoutTopicInput = {
    create?:
      | XOR<
          TopicTagCreateWithoutTopicInput,
          TopicTagUncheckedCreateWithoutTopicInput
        >
      | TopicTagCreateWithoutTopicInput[]
      | TopicTagUncheckedCreateWithoutTopicInput[];
    connectOrCreate?:
      | TopicTagCreateOrConnectWithoutTopicInput
      | TopicTagCreateOrConnectWithoutTopicInput[];
    createMany?: TopicTagCreateManyTopicInputEnvelope;
    connect?: TopicTagWhereUniqueInput | TopicTagWhereUniqueInput[];
  };

  export type ContentItemUncheckedCreateNestedManyWithoutTopicInput = {
    create?:
      | XOR<
          ContentItemCreateWithoutTopicInput,
          ContentItemUncheckedCreateWithoutTopicInput
        >
      | ContentItemCreateWithoutTopicInput[]
      | ContentItemUncheckedCreateWithoutTopicInput[];
    connectOrCreate?:
      | ContentItemCreateOrConnectWithoutTopicInput
      | ContentItemCreateOrConnectWithoutTopicInput[];
    createMany?: ContentItemCreateManyTopicInputEnvelope;
    connect?: ContentItemWhereUniqueInput | ContentItemWhereUniqueInput[];
  };

  export type TopicTagUncheckedCreateNestedManyWithoutTopicInput = {
    create?:
      | XOR<
          TopicTagCreateWithoutTopicInput,
          TopicTagUncheckedCreateWithoutTopicInput
        >
      | TopicTagCreateWithoutTopicInput[]
      | TopicTagUncheckedCreateWithoutTopicInput[];
    connectOrCreate?:
      | TopicTagCreateOrConnectWithoutTopicInput
      | TopicTagCreateOrConnectWithoutTopicInput[];
    createMany?: TopicTagCreateManyTopicInputEnvelope;
    connect?: TopicTagWhereUniqueInput | TopicTagWhereUniqueInput[];
  };

  export type StringFieldUpdateOperationsInput = {
    set?: string;
  };

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null;
    unset?: boolean;
  };

  export type EnumLocaleFieldUpdateOperationsInput = {
    set?: $Enums.Locale;
  };

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string;
  };

  export type ContentItemUpdateManyWithoutTopicNestedInput = {
    create?:
      | XOR<
          ContentItemCreateWithoutTopicInput,
          ContentItemUncheckedCreateWithoutTopicInput
        >
      | ContentItemCreateWithoutTopicInput[]
      | ContentItemUncheckedCreateWithoutTopicInput[];
    connectOrCreate?:
      | ContentItemCreateOrConnectWithoutTopicInput
      | ContentItemCreateOrConnectWithoutTopicInput[];
    upsert?:
      | ContentItemUpsertWithWhereUniqueWithoutTopicInput
      | ContentItemUpsertWithWhereUniqueWithoutTopicInput[];
    createMany?: ContentItemCreateManyTopicInputEnvelope;
    set?: ContentItemWhereUniqueInput | ContentItemWhereUniqueInput[];
    disconnect?: ContentItemWhereUniqueInput | ContentItemWhereUniqueInput[];
    delete?: ContentItemWhereUniqueInput | ContentItemWhereUniqueInput[];
    connect?: ContentItemWhereUniqueInput | ContentItemWhereUniqueInput[];
    update?:
      | ContentItemUpdateWithWhereUniqueWithoutTopicInput
      | ContentItemUpdateWithWhereUniqueWithoutTopicInput[];
    updateMany?:
      | ContentItemUpdateManyWithWhereWithoutTopicInput
      | ContentItemUpdateManyWithWhereWithoutTopicInput[];
    deleteMany?: ContentItemScalarWhereInput | ContentItemScalarWhereInput[];
  };

  export type TopicTagUpdateManyWithoutTopicNestedInput = {
    create?:
      | XOR<
          TopicTagCreateWithoutTopicInput,
          TopicTagUncheckedCreateWithoutTopicInput
        >
      | TopicTagCreateWithoutTopicInput[]
      | TopicTagUncheckedCreateWithoutTopicInput[];
    connectOrCreate?:
      | TopicTagCreateOrConnectWithoutTopicInput
      | TopicTagCreateOrConnectWithoutTopicInput[];
    upsert?:
      | TopicTagUpsertWithWhereUniqueWithoutTopicInput
      | TopicTagUpsertWithWhereUniqueWithoutTopicInput[];
    createMany?: TopicTagCreateManyTopicInputEnvelope;
    set?: TopicTagWhereUniqueInput | TopicTagWhereUniqueInput[];
    disconnect?: TopicTagWhereUniqueInput | TopicTagWhereUniqueInput[];
    delete?: TopicTagWhereUniqueInput | TopicTagWhereUniqueInput[];
    connect?: TopicTagWhereUniqueInput | TopicTagWhereUniqueInput[];
    update?:
      | TopicTagUpdateWithWhereUniqueWithoutTopicInput
      | TopicTagUpdateWithWhereUniqueWithoutTopicInput[];
    updateMany?:
      | TopicTagUpdateManyWithWhereWithoutTopicInput
      | TopicTagUpdateManyWithWhereWithoutTopicInput[];
    deleteMany?: TopicTagScalarWhereInput | TopicTagScalarWhereInput[];
  };

  export type ContentItemUncheckedUpdateManyWithoutTopicNestedInput = {
    create?:
      | XOR<
          ContentItemCreateWithoutTopicInput,
          ContentItemUncheckedCreateWithoutTopicInput
        >
      | ContentItemCreateWithoutTopicInput[]
      | ContentItemUncheckedCreateWithoutTopicInput[];
    connectOrCreate?:
      | ContentItemCreateOrConnectWithoutTopicInput
      | ContentItemCreateOrConnectWithoutTopicInput[];
    upsert?:
      | ContentItemUpsertWithWhereUniqueWithoutTopicInput
      | ContentItemUpsertWithWhereUniqueWithoutTopicInput[];
    createMany?: ContentItemCreateManyTopicInputEnvelope;
    set?: ContentItemWhereUniqueInput | ContentItemWhereUniqueInput[];
    disconnect?: ContentItemWhereUniqueInput | ContentItemWhereUniqueInput[];
    delete?: ContentItemWhereUniqueInput | ContentItemWhereUniqueInput[];
    connect?: ContentItemWhereUniqueInput | ContentItemWhereUniqueInput[];
    update?:
      | ContentItemUpdateWithWhereUniqueWithoutTopicInput
      | ContentItemUpdateWithWhereUniqueWithoutTopicInput[];
    updateMany?:
      | ContentItemUpdateManyWithWhereWithoutTopicInput
      | ContentItemUpdateManyWithWhereWithoutTopicInput[];
    deleteMany?: ContentItemScalarWhereInput | ContentItemScalarWhereInput[];
  };

  export type TopicTagUncheckedUpdateManyWithoutTopicNestedInput = {
    create?:
      | XOR<
          TopicTagCreateWithoutTopicInput,
          TopicTagUncheckedCreateWithoutTopicInput
        >
      | TopicTagCreateWithoutTopicInput[]
      | TopicTagUncheckedCreateWithoutTopicInput[];
    connectOrCreate?:
      | TopicTagCreateOrConnectWithoutTopicInput
      | TopicTagCreateOrConnectWithoutTopicInput[];
    upsert?:
      | TopicTagUpsertWithWhereUniqueWithoutTopicInput
      | TopicTagUpsertWithWhereUniqueWithoutTopicInput[];
    createMany?: TopicTagCreateManyTopicInputEnvelope;
    set?: TopicTagWhereUniqueInput | TopicTagWhereUniqueInput[];
    disconnect?: TopicTagWhereUniqueInput | TopicTagWhereUniqueInput[];
    delete?: TopicTagWhereUniqueInput | TopicTagWhereUniqueInput[];
    connect?: TopicTagWhereUniqueInput | TopicTagWhereUniqueInput[];
    update?:
      | TopicTagUpdateWithWhereUniqueWithoutTopicInput
      | TopicTagUpdateWithWhereUniqueWithoutTopicInput[];
    updateMany?:
      | TopicTagUpdateManyWithWhereWithoutTopicInput
      | TopicTagUpdateManyWithWhereWithoutTopicInput[];
    deleteMany?: TopicTagScalarWhereInput | TopicTagScalarWhereInput[];
  };

  export type TopicTagCreateNestedManyWithoutTagInput = {
    create?:
      | XOR<
          TopicTagCreateWithoutTagInput,
          TopicTagUncheckedCreateWithoutTagInput
        >
      | TopicTagCreateWithoutTagInput[]
      | TopicTagUncheckedCreateWithoutTagInput[];
    connectOrCreate?:
      | TopicTagCreateOrConnectWithoutTagInput
      | TopicTagCreateOrConnectWithoutTagInput[];
    createMany?: TopicTagCreateManyTagInputEnvelope;
    connect?: TopicTagWhereUniqueInput | TopicTagWhereUniqueInput[];
  };

  export type ItemTagCreateNestedManyWithoutTagInput = {
    create?:
      | XOR<ItemTagCreateWithoutTagInput, ItemTagUncheckedCreateWithoutTagInput>
      | ItemTagCreateWithoutTagInput[]
      | ItemTagUncheckedCreateWithoutTagInput[];
    connectOrCreate?:
      | ItemTagCreateOrConnectWithoutTagInput
      | ItemTagCreateOrConnectWithoutTagInput[];
    createMany?: ItemTagCreateManyTagInputEnvelope;
    connect?: ItemTagWhereUniqueInput | ItemTagWhereUniqueInput[];
  };

  export type TopicTagUncheckedCreateNestedManyWithoutTagInput = {
    create?:
      | XOR<
          TopicTagCreateWithoutTagInput,
          TopicTagUncheckedCreateWithoutTagInput
        >
      | TopicTagCreateWithoutTagInput[]
      | TopicTagUncheckedCreateWithoutTagInput[];
    connectOrCreate?:
      | TopicTagCreateOrConnectWithoutTagInput
      | TopicTagCreateOrConnectWithoutTagInput[];
    createMany?: TopicTagCreateManyTagInputEnvelope;
    connect?: TopicTagWhereUniqueInput | TopicTagWhereUniqueInput[];
  };

  export type ItemTagUncheckedCreateNestedManyWithoutTagInput = {
    create?:
      | XOR<ItemTagCreateWithoutTagInput, ItemTagUncheckedCreateWithoutTagInput>
      | ItemTagCreateWithoutTagInput[]
      | ItemTagUncheckedCreateWithoutTagInput[];
    connectOrCreate?:
      | ItemTagCreateOrConnectWithoutTagInput
      | ItemTagCreateOrConnectWithoutTagInput[];
    createMany?: ItemTagCreateManyTagInputEnvelope;
    connect?: ItemTagWhereUniqueInput | ItemTagWhereUniqueInput[];
  };

  export type TopicTagUpdateManyWithoutTagNestedInput = {
    create?:
      | XOR<
          TopicTagCreateWithoutTagInput,
          TopicTagUncheckedCreateWithoutTagInput
        >
      | TopicTagCreateWithoutTagInput[]
      | TopicTagUncheckedCreateWithoutTagInput[];
    connectOrCreate?:
      | TopicTagCreateOrConnectWithoutTagInput
      | TopicTagCreateOrConnectWithoutTagInput[];
    upsert?:
      | TopicTagUpsertWithWhereUniqueWithoutTagInput
      | TopicTagUpsertWithWhereUniqueWithoutTagInput[];
    createMany?: TopicTagCreateManyTagInputEnvelope;
    set?: TopicTagWhereUniqueInput | TopicTagWhereUniqueInput[];
    disconnect?: TopicTagWhereUniqueInput | TopicTagWhereUniqueInput[];
    delete?: TopicTagWhereUniqueInput | TopicTagWhereUniqueInput[];
    connect?: TopicTagWhereUniqueInput | TopicTagWhereUniqueInput[];
    update?:
      | TopicTagUpdateWithWhereUniqueWithoutTagInput
      | TopicTagUpdateWithWhereUniqueWithoutTagInput[];
    updateMany?:
      | TopicTagUpdateManyWithWhereWithoutTagInput
      | TopicTagUpdateManyWithWhereWithoutTagInput[];
    deleteMany?: TopicTagScalarWhereInput | TopicTagScalarWhereInput[];
  };

  export type ItemTagUpdateManyWithoutTagNestedInput = {
    create?:
      | XOR<ItemTagCreateWithoutTagInput, ItemTagUncheckedCreateWithoutTagInput>
      | ItemTagCreateWithoutTagInput[]
      | ItemTagUncheckedCreateWithoutTagInput[];
    connectOrCreate?:
      | ItemTagCreateOrConnectWithoutTagInput
      | ItemTagCreateOrConnectWithoutTagInput[];
    upsert?:
      | ItemTagUpsertWithWhereUniqueWithoutTagInput
      | ItemTagUpsertWithWhereUniqueWithoutTagInput[];
    createMany?: ItemTagCreateManyTagInputEnvelope;
    set?: ItemTagWhereUniqueInput | ItemTagWhereUniqueInput[];
    disconnect?: ItemTagWhereUniqueInput | ItemTagWhereUniqueInput[];
    delete?: ItemTagWhereUniqueInput | ItemTagWhereUniqueInput[];
    connect?: ItemTagWhereUniqueInput | ItemTagWhereUniqueInput[];
    update?:
      | ItemTagUpdateWithWhereUniqueWithoutTagInput
      | ItemTagUpdateWithWhereUniqueWithoutTagInput[];
    updateMany?:
      | ItemTagUpdateManyWithWhereWithoutTagInput
      | ItemTagUpdateManyWithWhereWithoutTagInput[];
    deleteMany?: ItemTagScalarWhereInput | ItemTagScalarWhereInput[];
  };

  export type TopicTagUncheckedUpdateManyWithoutTagNestedInput = {
    create?:
      | XOR<
          TopicTagCreateWithoutTagInput,
          TopicTagUncheckedCreateWithoutTagInput
        >
      | TopicTagCreateWithoutTagInput[]
      | TopicTagUncheckedCreateWithoutTagInput[];
    connectOrCreate?:
      | TopicTagCreateOrConnectWithoutTagInput
      | TopicTagCreateOrConnectWithoutTagInput[];
    upsert?:
      | TopicTagUpsertWithWhereUniqueWithoutTagInput
      | TopicTagUpsertWithWhereUniqueWithoutTagInput[];
    createMany?: TopicTagCreateManyTagInputEnvelope;
    set?: TopicTagWhereUniqueInput | TopicTagWhereUniqueInput[];
    disconnect?: TopicTagWhereUniqueInput | TopicTagWhereUniqueInput[];
    delete?: TopicTagWhereUniqueInput | TopicTagWhereUniqueInput[];
    connect?: TopicTagWhereUniqueInput | TopicTagWhereUniqueInput[];
    update?:
      | TopicTagUpdateWithWhereUniqueWithoutTagInput
      | TopicTagUpdateWithWhereUniqueWithoutTagInput[];
    updateMany?:
      | TopicTagUpdateManyWithWhereWithoutTagInput
      | TopicTagUpdateManyWithWhereWithoutTagInput[];
    deleteMany?: TopicTagScalarWhereInput | TopicTagScalarWhereInput[];
  };

  export type ItemTagUncheckedUpdateManyWithoutTagNestedInput = {
    create?:
      | XOR<ItemTagCreateWithoutTagInput, ItemTagUncheckedCreateWithoutTagInput>
      | ItemTagCreateWithoutTagInput[]
      | ItemTagUncheckedCreateWithoutTagInput[];
    connectOrCreate?:
      | ItemTagCreateOrConnectWithoutTagInput
      | ItemTagCreateOrConnectWithoutTagInput[];
    upsert?:
      | ItemTagUpsertWithWhereUniqueWithoutTagInput
      | ItemTagUpsertWithWhereUniqueWithoutTagInput[];
    createMany?: ItemTagCreateManyTagInputEnvelope;
    set?: ItemTagWhereUniqueInput | ItemTagWhereUniqueInput[];
    disconnect?: ItemTagWhereUniqueInput | ItemTagWhereUniqueInput[];
    delete?: ItemTagWhereUniqueInput | ItemTagWhereUniqueInput[];
    connect?: ItemTagWhereUniqueInput | ItemTagWhereUniqueInput[];
    update?:
      | ItemTagUpdateWithWhereUniqueWithoutTagInput
      | ItemTagUpdateWithWhereUniqueWithoutTagInput[];
    updateMany?:
      | ItemTagUpdateManyWithWhereWithoutTagInput
      | ItemTagUpdateManyWithWhereWithoutTagInput[];
    deleteMany?: ItemTagScalarWhereInput | ItemTagScalarWhereInput[];
  };

  export type TopicCreateNestedOneWithoutTagsInput = {
    create?: XOR<
      TopicCreateWithoutTagsInput,
      TopicUncheckedCreateWithoutTagsInput
    >;
    connectOrCreate?: TopicCreateOrConnectWithoutTagsInput;
    connect?: TopicWhereUniqueInput;
  };

  export type TagCreateNestedOneWithoutTopicsInput = {
    create?: XOR<
      TagCreateWithoutTopicsInput,
      TagUncheckedCreateWithoutTopicsInput
    >;
    connectOrCreate?: TagCreateOrConnectWithoutTopicsInput;
    connect?: TagWhereUniqueInput;
  };

  export type TopicUpdateOneRequiredWithoutTagsNestedInput = {
    create?: XOR<
      TopicCreateWithoutTagsInput,
      TopicUncheckedCreateWithoutTagsInput
    >;
    connectOrCreate?: TopicCreateOrConnectWithoutTagsInput;
    upsert?: TopicUpsertWithoutTagsInput;
    connect?: TopicWhereUniqueInput;
    update?: XOR<
      XOR<
        TopicUpdateToOneWithWhereWithoutTagsInput,
        TopicUpdateWithoutTagsInput
      >,
      TopicUncheckedUpdateWithoutTagsInput
    >;
  };

  export type TagUpdateOneRequiredWithoutTopicsNestedInput = {
    create?: XOR<
      TagCreateWithoutTopicsInput,
      TagUncheckedCreateWithoutTopicsInput
    >;
    connectOrCreate?: TagCreateOrConnectWithoutTopicsInput;
    upsert?: TagUpsertWithoutTopicsInput;
    connect?: TagWhereUniqueInput;
    update?: XOR<
      XOR<
        TagUpdateToOneWithWhereWithoutTopicsInput,
        TagUpdateWithoutTopicsInput
      >,
      TagUncheckedUpdateWithoutTopicsInput
    >;
  };

  export type ContentItemCreateNestedOneWithoutTagsInput = {
    create?: XOR<
      ContentItemCreateWithoutTagsInput,
      ContentItemUncheckedCreateWithoutTagsInput
    >;
    connectOrCreate?: ContentItemCreateOrConnectWithoutTagsInput;
    connect?: ContentItemWhereUniqueInput;
  };

  export type TagCreateNestedOneWithoutItemsInput = {
    create?: XOR<
      TagCreateWithoutItemsInput,
      TagUncheckedCreateWithoutItemsInput
    >;
    connectOrCreate?: TagCreateOrConnectWithoutItemsInput;
    connect?: TagWhereUniqueInput;
  };

  export type ContentItemUpdateOneRequiredWithoutTagsNestedInput = {
    create?: XOR<
      ContentItemCreateWithoutTagsInput,
      ContentItemUncheckedCreateWithoutTagsInput
    >;
    connectOrCreate?: ContentItemCreateOrConnectWithoutTagsInput;
    upsert?: ContentItemUpsertWithoutTagsInput;
    connect?: ContentItemWhereUniqueInput;
    update?: XOR<
      XOR<
        ContentItemUpdateToOneWithWhereWithoutTagsInput,
        ContentItemUpdateWithoutTagsInput
      >,
      ContentItemUncheckedUpdateWithoutTagsInput
    >;
  };

  export type TagUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<
      TagCreateWithoutItemsInput,
      TagUncheckedCreateWithoutItemsInput
    >;
    connectOrCreate?: TagCreateOrConnectWithoutItemsInput;
    upsert?: TagUpsertWithoutItemsInput;
    connect?: TagWhereUniqueInput;
    update?: XOR<
      XOR<TagUpdateToOneWithWhereWithoutItemsInput, TagUpdateWithoutItemsInput>,
      TagUncheckedUpdateWithoutItemsInput
    >;
  };

  export type RegionCreateNestedOneWithoutChildrenInput = {
    create?: XOR<
      RegionCreateWithoutChildrenInput,
      RegionUncheckedCreateWithoutChildrenInput
    >;
    connectOrCreate?: RegionCreateOrConnectWithoutChildrenInput;
    connect?: RegionWhereUniqueInput;
  };

  export type RegionCreateNestedManyWithoutParentInput = {
    create?:
      | XOR<
          RegionCreateWithoutParentInput,
          RegionUncheckedCreateWithoutParentInput
        >
      | RegionCreateWithoutParentInput[]
      | RegionUncheckedCreateWithoutParentInput[];
    connectOrCreate?:
      | RegionCreateOrConnectWithoutParentInput
      | RegionCreateOrConnectWithoutParentInput[];
    createMany?: RegionCreateManyParentInputEnvelope;
    connect?: RegionWhereUniqueInput | RegionWhereUniqueInput[];
  };

  export type ContentItemCreateNestedManyWithoutRegionManualInput = {
    create?:
      | XOR<
          ContentItemCreateWithoutRegionManualInput,
          ContentItemUncheckedCreateWithoutRegionManualInput
        >
      | ContentItemCreateWithoutRegionManualInput[]
      | ContentItemUncheckedCreateWithoutRegionManualInput[];
    connectOrCreate?:
      | ContentItemCreateOrConnectWithoutRegionManualInput
      | ContentItemCreateOrConnectWithoutRegionManualInput[];
    createMany?: ContentItemCreateManyRegionManualInputEnvelope;
    connect?: ContentItemWhereUniqueInput | ContentItemWhereUniqueInput[];
  };

  export type ContentItemCreateNestedManyWithoutRegionEffectiveInput = {
    create?:
      | XOR<
          ContentItemCreateWithoutRegionEffectiveInput,
          ContentItemUncheckedCreateWithoutRegionEffectiveInput
        >
      | ContentItemCreateWithoutRegionEffectiveInput[]
      | ContentItemUncheckedCreateWithoutRegionEffectiveInput[];
    connectOrCreate?:
      | ContentItemCreateOrConnectWithoutRegionEffectiveInput
      | ContentItemCreateOrConnectWithoutRegionEffectiveInput[];
    createMany?: ContentItemCreateManyRegionEffectiveInputEnvelope;
    connect?: ContentItemWhereUniqueInput | ContentItemWhereUniqueInput[];
  };

  export type RegionClosureCreateNestedManyWithoutAncestorInput = {
    create?:
      | XOR<
          RegionClosureCreateWithoutAncestorInput,
          RegionClosureUncheckedCreateWithoutAncestorInput
        >
      | RegionClosureCreateWithoutAncestorInput[]
      | RegionClosureUncheckedCreateWithoutAncestorInput[];
    connectOrCreate?:
      | RegionClosureCreateOrConnectWithoutAncestorInput
      | RegionClosureCreateOrConnectWithoutAncestorInput[];
    createMany?: RegionClosureCreateManyAncestorInputEnvelope;
    connect?: RegionClosureWhereUniqueInput | RegionClosureWhereUniqueInput[];
  };

  export type RegionClosureCreateNestedManyWithoutDescendantInput = {
    create?:
      | XOR<
          RegionClosureCreateWithoutDescendantInput,
          RegionClosureUncheckedCreateWithoutDescendantInput
        >
      | RegionClosureCreateWithoutDescendantInput[]
      | RegionClosureUncheckedCreateWithoutDescendantInput[];
    connectOrCreate?:
      | RegionClosureCreateOrConnectWithoutDescendantInput
      | RegionClosureCreateOrConnectWithoutDescendantInput[];
    createMany?: RegionClosureCreateManyDescendantInputEnvelope;
    connect?: RegionClosureWhereUniqueInput | RegionClosureWhereUniqueInput[];
  };

  export type RegionUncheckedCreateNestedManyWithoutParentInput = {
    create?:
      | XOR<
          RegionCreateWithoutParentInput,
          RegionUncheckedCreateWithoutParentInput
        >
      | RegionCreateWithoutParentInput[]
      | RegionUncheckedCreateWithoutParentInput[];
    connectOrCreate?:
      | RegionCreateOrConnectWithoutParentInput
      | RegionCreateOrConnectWithoutParentInput[];
    createMany?: RegionCreateManyParentInputEnvelope;
    connect?: RegionWhereUniqueInput | RegionWhereUniqueInput[];
  };

  export type ContentItemUncheckedCreateNestedManyWithoutRegionManualInput = {
    create?:
      | XOR<
          ContentItemCreateWithoutRegionManualInput,
          ContentItemUncheckedCreateWithoutRegionManualInput
        >
      | ContentItemCreateWithoutRegionManualInput[]
      | ContentItemUncheckedCreateWithoutRegionManualInput[];
    connectOrCreate?:
      | ContentItemCreateOrConnectWithoutRegionManualInput
      | ContentItemCreateOrConnectWithoutRegionManualInput[];
    createMany?: ContentItemCreateManyRegionManualInputEnvelope;
    connect?: ContentItemWhereUniqueInput | ContentItemWhereUniqueInput[];
  };

  export type ContentItemUncheckedCreateNestedManyWithoutRegionEffectiveInput =
    {
      create?:
        | XOR<
            ContentItemCreateWithoutRegionEffectiveInput,
            ContentItemUncheckedCreateWithoutRegionEffectiveInput
          >
        | ContentItemCreateWithoutRegionEffectiveInput[]
        | ContentItemUncheckedCreateWithoutRegionEffectiveInput[];
      connectOrCreate?:
        | ContentItemCreateOrConnectWithoutRegionEffectiveInput
        | ContentItemCreateOrConnectWithoutRegionEffectiveInput[];
      createMany?: ContentItemCreateManyRegionEffectiveInputEnvelope;
      connect?: ContentItemWhereUniqueInput | ContentItemWhereUniqueInput[];
    };

  export type RegionClosureUncheckedCreateNestedManyWithoutAncestorInput = {
    create?:
      | XOR<
          RegionClosureCreateWithoutAncestorInput,
          RegionClosureUncheckedCreateWithoutAncestorInput
        >
      | RegionClosureCreateWithoutAncestorInput[]
      | RegionClosureUncheckedCreateWithoutAncestorInput[];
    connectOrCreate?:
      | RegionClosureCreateOrConnectWithoutAncestorInput
      | RegionClosureCreateOrConnectWithoutAncestorInput[];
    createMany?: RegionClosureCreateManyAncestorInputEnvelope;
    connect?: RegionClosureWhereUniqueInput | RegionClosureWhereUniqueInput[];
  };

  export type RegionClosureUncheckedCreateNestedManyWithoutDescendantInput = {
    create?:
      | XOR<
          RegionClosureCreateWithoutDescendantInput,
          RegionClosureUncheckedCreateWithoutDescendantInput
        >
      | RegionClosureCreateWithoutDescendantInput[]
      | RegionClosureUncheckedCreateWithoutDescendantInput[];
    connectOrCreate?:
      | RegionClosureCreateOrConnectWithoutDescendantInput
      | RegionClosureCreateOrConnectWithoutDescendantInput[];
    createMany?: RegionClosureCreateManyDescendantInputEnvelope;
    connect?: RegionClosureWhereUniqueInput | RegionClosureWhereUniqueInput[];
  };

  export type IntFieldUpdateOperationsInput = {
    set?: number;
    increment?: number;
    decrement?: number;
    multiply?: number;
    divide?: number;
  };

  export type RegionUpdateOneWithoutChildrenNestedInput = {
    create?: XOR<
      RegionCreateWithoutChildrenInput,
      RegionUncheckedCreateWithoutChildrenInput
    >;
    connectOrCreate?: RegionCreateOrConnectWithoutChildrenInput;
    upsert?: RegionUpsertWithoutChildrenInput;
    disconnect?: boolean;
    delete?: RegionWhereInput | boolean;
    connect?: RegionWhereUniqueInput;
    update?: XOR<
      XOR<
        RegionUpdateToOneWithWhereWithoutChildrenInput,
        RegionUpdateWithoutChildrenInput
      >,
      RegionUncheckedUpdateWithoutChildrenInput
    >;
  };

  export type RegionUpdateManyWithoutParentNestedInput = {
    create?:
      | XOR<
          RegionCreateWithoutParentInput,
          RegionUncheckedCreateWithoutParentInput
        >
      | RegionCreateWithoutParentInput[]
      | RegionUncheckedCreateWithoutParentInput[];
    connectOrCreate?:
      | RegionCreateOrConnectWithoutParentInput
      | RegionCreateOrConnectWithoutParentInput[];
    upsert?:
      | RegionUpsertWithWhereUniqueWithoutParentInput
      | RegionUpsertWithWhereUniqueWithoutParentInput[];
    createMany?: RegionCreateManyParentInputEnvelope;
    set?: RegionWhereUniqueInput | RegionWhereUniqueInput[];
    disconnect?: RegionWhereUniqueInput | RegionWhereUniqueInput[];
    delete?: RegionWhereUniqueInput | RegionWhereUniqueInput[];
    connect?: RegionWhereUniqueInput | RegionWhereUniqueInput[];
    update?:
      | RegionUpdateWithWhereUniqueWithoutParentInput
      | RegionUpdateWithWhereUniqueWithoutParentInput[];
    updateMany?:
      | RegionUpdateManyWithWhereWithoutParentInput
      | RegionUpdateManyWithWhereWithoutParentInput[];
    deleteMany?: RegionScalarWhereInput | RegionScalarWhereInput[];
  };

  export type ContentItemUpdateManyWithoutRegionManualNestedInput = {
    create?:
      | XOR<
          ContentItemCreateWithoutRegionManualInput,
          ContentItemUncheckedCreateWithoutRegionManualInput
        >
      | ContentItemCreateWithoutRegionManualInput[]
      | ContentItemUncheckedCreateWithoutRegionManualInput[];
    connectOrCreate?:
      | ContentItemCreateOrConnectWithoutRegionManualInput
      | ContentItemCreateOrConnectWithoutRegionManualInput[];
    upsert?:
      | ContentItemUpsertWithWhereUniqueWithoutRegionManualInput
      | ContentItemUpsertWithWhereUniqueWithoutRegionManualInput[];
    createMany?: ContentItemCreateManyRegionManualInputEnvelope;
    set?: ContentItemWhereUniqueInput | ContentItemWhereUniqueInput[];
    disconnect?: ContentItemWhereUniqueInput | ContentItemWhereUniqueInput[];
    delete?: ContentItemWhereUniqueInput | ContentItemWhereUniqueInput[];
    connect?: ContentItemWhereUniqueInput | ContentItemWhereUniqueInput[];
    update?:
      | ContentItemUpdateWithWhereUniqueWithoutRegionManualInput
      | ContentItemUpdateWithWhereUniqueWithoutRegionManualInput[];
    updateMany?:
      | ContentItemUpdateManyWithWhereWithoutRegionManualInput
      | ContentItemUpdateManyWithWhereWithoutRegionManualInput[];
    deleteMany?: ContentItemScalarWhereInput | ContentItemScalarWhereInput[];
  };

  export type ContentItemUpdateManyWithoutRegionEffectiveNestedInput = {
    create?:
      | XOR<
          ContentItemCreateWithoutRegionEffectiveInput,
          ContentItemUncheckedCreateWithoutRegionEffectiveInput
        >
      | ContentItemCreateWithoutRegionEffectiveInput[]
      | ContentItemUncheckedCreateWithoutRegionEffectiveInput[];
    connectOrCreate?:
      | ContentItemCreateOrConnectWithoutRegionEffectiveInput
      | ContentItemCreateOrConnectWithoutRegionEffectiveInput[];
    upsert?:
      | ContentItemUpsertWithWhereUniqueWithoutRegionEffectiveInput
      | ContentItemUpsertWithWhereUniqueWithoutRegionEffectiveInput[];
    createMany?: ContentItemCreateManyRegionEffectiveInputEnvelope;
    set?: ContentItemWhereUniqueInput | ContentItemWhereUniqueInput[];
    disconnect?: ContentItemWhereUniqueInput | ContentItemWhereUniqueInput[];
    delete?: ContentItemWhereUniqueInput | ContentItemWhereUniqueInput[];
    connect?: ContentItemWhereUniqueInput | ContentItemWhereUniqueInput[];
    update?:
      | ContentItemUpdateWithWhereUniqueWithoutRegionEffectiveInput
      | ContentItemUpdateWithWhereUniqueWithoutRegionEffectiveInput[];
    updateMany?:
      | ContentItemUpdateManyWithWhereWithoutRegionEffectiveInput
      | ContentItemUpdateManyWithWhereWithoutRegionEffectiveInput[];
    deleteMany?: ContentItemScalarWhereInput | ContentItemScalarWhereInput[];
  };

  export type RegionClosureUpdateManyWithoutAncestorNestedInput = {
    create?:
      | XOR<
          RegionClosureCreateWithoutAncestorInput,
          RegionClosureUncheckedCreateWithoutAncestorInput
        >
      | RegionClosureCreateWithoutAncestorInput[]
      | RegionClosureUncheckedCreateWithoutAncestorInput[];
    connectOrCreate?:
      | RegionClosureCreateOrConnectWithoutAncestorInput
      | RegionClosureCreateOrConnectWithoutAncestorInput[];
    upsert?:
      | RegionClosureUpsertWithWhereUniqueWithoutAncestorInput
      | RegionClosureUpsertWithWhereUniqueWithoutAncestorInput[];
    createMany?: RegionClosureCreateManyAncestorInputEnvelope;
    set?: RegionClosureWhereUniqueInput | RegionClosureWhereUniqueInput[];
    disconnect?:
      | RegionClosureWhereUniqueInput
      | RegionClosureWhereUniqueInput[];
    delete?: RegionClosureWhereUniqueInput | RegionClosureWhereUniqueInput[];
    connect?: RegionClosureWhereUniqueInput | RegionClosureWhereUniqueInput[];
    update?:
      | RegionClosureUpdateWithWhereUniqueWithoutAncestorInput
      | RegionClosureUpdateWithWhereUniqueWithoutAncestorInput[];
    updateMany?:
      | RegionClosureUpdateManyWithWhereWithoutAncestorInput
      | RegionClosureUpdateManyWithWhereWithoutAncestorInput[];
    deleteMany?:
      | RegionClosureScalarWhereInput
      | RegionClosureScalarWhereInput[];
  };

  export type RegionClosureUpdateManyWithoutDescendantNestedInput = {
    create?:
      | XOR<
          RegionClosureCreateWithoutDescendantInput,
          RegionClosureUncheckedCreateWithoutDescendantInput
        >
      | RegionClosureCreateWithoutDescendantInput[]
      | RegionClosureUncheckedCreateWithoutDescendantInput[];
    connectOrCreate?:
      | RegionClosureCreateOrConnectWithoutDescendantInput
      | RegionClosureCreateOrConnectWithoutDescendantInput[];
    upsert?:
      | RegionClosureUpsertWithWhereUniqueWithoutDescendantInput
      | RegionClosureUpsertWithWhereUniqueWithoutDescendantInput[];
    createMany?: RegionClosureCreateManyDescendantInputEnvelope;
    set?: RegionClosureWhereUniqueInput | RegionClosureWhereUniqueInput[];
    disconnect?:
      | RegionClosureWhereUniqueInput
      | RegionClosureWhereUniqueInput[];
    delete?: RegionClosureWhereUniqueInput | RegionClosureWhereUniqueInput[];
    connect?: RegionClosureWhereUniqueInput | RegionClosureWhereUniqueInput[];
    update?:
      | RegionClosureUpdateWithWhereUniqueWithoutDescendantInput
      | RegionClosureUpdateWithWhereUniqueWithoutDescendantInput[];
    updateMany?:
      | RegionClosureUpdateManyWithWhereWithoutDescendantInput
      | RegionClosureUpdateManyWithWhereWithoutDescendantInput[];
    deleteMany?:
      | RegionClosureScalarWhereInput
      | RegionClosureScalarWhereInput[];
  };

  export type RegionUncheckedUpdateManyWithoutParentNestedInput = {
    create?:
      | XOR<
          RegionCreateWithoutParentInput,
          RegionUncheckedCreateWithoutParentInput
        >
      | RegionCreateWithoutParentInput[]
      | RegionUncheckedCreateWithoutParentInput[];
    connectOrCreate?:
      | RegionCreateOrConnectWithoutParentInput
      | RegionCreateOrConnectWithoutParentInput[];
    upsert?:
      | RegionUpsertWithWhereUniqueWithoutParentInput
      | RegionUpsertWithWhereUniqueWithoutParentInput[];
    createMany?: RegionCreateManyParentInputEnvelope;
    set?: RegionWhereUniqueInput | RegionWhereUniqueInput[];
    disconnect?: RegionWhereUniqueInput | RegionWhereUniqueInput[];
    delete?: RegionWhereUniqueInput | RegionWhereUniqueInput[];
    connect?: RegionWhereUniqueInput | RegionWhereUniqueInput[];
    update?:
      | RegionUpdateWithWhereUniqueWithoutParentInput
      | RegionUpdateWithWhereUniqueWithoutParentInput[];
    updateMany?:
      | RegionUpdateManyWithWhereWithoutParentInput
      | RegionUpdateManyWithWhereWithoutParentInput[];
    deleteMany?: RegionScalarWhereInput | RegionScalarWhereInput[];
  };

  export type ContentItemUncheckedUpdateManyWithoutRegionManualNestedInput = {
    create?:
      | XOR<
          ContentItemCreateWithoutRegionManualInput,
          ContentItemUncheckedCreateWithoutRegionManualInput
        >
      | ContentItemCreateWithoutRegionManualInput[]
      | ContentItemUncheckedCreateWithoutRegionManualInput[];
    connectOrCreate?:
      | ContentItemCreateOrConnectWithoutRegionManualInput
      | ContentItemCreateOrConnectWithoutRegionManualInput[];
    upsert?:
      | ContentItemUpsertWithWhereUniqueWithoutRegionManualInput
      | ContentItemUpsertWithWhereUniqueWithoutRegionManualInput[];
    createMany?: ContentItemCreateManyRegionManualInputEnvelope;
    set?: ContentItemWhereUniqueInput | ContentItemWhereUniqueInput[];
    disconnect?: ContentItemWhereUniqueInput | ContentItemWhereUniqueInput[];
    delete?: ContentItemWhereUniqueInput | ContentItemWhereUniqueInput[];
    connect?: ContentItemWhereUniqueInput | ContentItemWhereUniqueInput[];
    update?:
      | ContentItemUpdateWithWhereUniqueWithoutRegionManualInput
      | ContentItemUpdateWithWhereUniqueWithoutRegionManualInput[];
    updateMany?:
      | ContentItemUpdateManyWithWhereWithoutRegionManualInput
      | ContentItemUpdateManyWithWhereWithoutRegionManualInput[];
    deleteMany?: ContentItemScalarWhereInput | ContentItemScalarWhereInput[];
  };

  export type ContentItemUncheckedUpdateManyWithoutRegionEffectiveNestedInput =
    {
      create?:
        | XOR<
            ContentItemCreateWithoutRegionEffectiveInput,
            ContentItemUncheckedCreateWithoutRegionEffectiveInput
          >
        | ContentItemCreateWithoutRegionEffectiveInput[]
        | ContentItemUncheckedCreateWithoutRegionEffectiveInput[];
      connectOrCreate?:
        | ContentItemCreateOrConnectWithoutRegionEffectiveInput
        | ContentItemCreateOrConnectWithoutRegionEffectiveInput[];
      upsert?:
        | ContentItemUpsertWithWhereUniqueWithoutRegionEffectiveInput
        | ContentItemUpsertWithWhereUniqueWithoutRegionEffectiveInput[];
      createMany?: ContentItemCreateManyRegionEffectiveInputEnvelope;
      set?: ContentItemWhereUniqueInput | ContentItemWhereUniqueInput[];
      disconnect?: ContentItemWhereUniqueInput | ContentItemWhereUniqueInput[];
      delete?: ContentItemWhereUniqueInput | ContentItemWhereUniqueInput[];
      connect?: ContentItemWhereUniqueInput | ContentItemWhereUniqueInput[];
      update?:
        | ContentItemUpdateWithWhereUniqueWithoutRegionEffectiveInput
        | ContentItemUpdateWithWhereUniqueWithoutRegionEffectiveInput[];
      updateMany?:
        | ContentItemUpdateManyWithWhereWithoutRegionEffectiveInput
        | ContentItemUpdateManyWithWhereWithoutRegionEffectiveInput[];
      deleteMany?: ContentItemScalarWhereInput | ContentItemScalarWhereInput[];
    };

  export type RegionClosureUncheckedUpdateManyWithoutAncestorNestedInput = {
    create?:
      | XOR<
          RegionClosureCreateWithoutAncestorInput,
          RegionClosureUncheckedCreateWithoutAncestorInput
        >
      | RegionClosureCreateWithoutAncestorInput[]
      | RegionClosureUncheckedCreateWithoutAncestorInput[];
    connectOrCreate?:
      | RegionClosureCreateOrConnectWithoutAncestorInput
      | RegionClosureCreateOrConnectWithoutAncestorInput[];
    upsert?:
      | RegionClosureUpsertWithWhereUniqueWithoutAncestorInput
      | RegionClosureUpsertWithWhereUniqueWithoutAncestorInput[];
    createMany?: RegionClosureCreateManyAncestorInputEnvelope;
    set?: RegionClosureWhereUniqueInput | RegionClosureWhereUniqueInput[];
    disconnect?:
      | RegionClosureWhereUniqueInput
      | RegionClosureWhereUniqueInput[];
    delete?: RegionClosureWhereUniqueInput | RegionClosureWhereUniqueInput[];
    connect?: RegionClosureWhereUniqueInput | RegionClosureWhereUniqueInput[];
    update?:
      | RegionClosureUpdateWithWhereUniqueWithoutAncestorInput
      | RegionClosureUpdateWithWhereUniqueWithoutAncestorInput[];
    updateMany?:
      | RegionClosureUpdateManyWithWhereWithoutAncestorInput
      | RegionClosureUpdateManyWithWhereWithoutAncestorInput[];
    deleteMany?:
      | RegionClosureScalarWhereInput
      | RegionClosureScalarWhereInput[];
  };

  export type RegionClosureUncheckedUpdateManyWithoutDescendantNestedInput = {
    create?:
      | XOR<
          RegionClosureCreateWithoutDescendantInput,
          RegionClosureUncheckedCreateWithoutDescendantInput
        >
      | RegionClosureCreateWithoutDescendantInput[]
      | RegionClosureUncheckedCreateWithoutDescendantInput[];
    connectOrCreate?:
      | RegionClosureCreateOrConnectWithoutDescendantInput
      | RegionClosureCreateOrConnectWithoutDescendantInput[];
    upsert?:
      | RegionClosureUpsertWithWhereUniqueWithoutDescendantInput
      | RegionClosureUpsertWithWhereUniqueWithoutDescendantInput[];
    createMany?: RegionClosureCreateManyDescendantInputEnvelope;
    set?: RegionClosureWhereUniqueInput | RegionClosureWhereUniqueInput[];
    disconnect?:
      | RegionClosureWhereUniqueInput
      | RegionClosureWhereUniqueInput[];
    delete?: RegionClosureWhereUniqueInput | RegionClosureWhereUniqueInput[];
    connect?: RegionClosureWhereUniqueInput | RegionClosureWhereUniqueInput[];
    update?:
      | RegionClosureUpdateWithWhereUniqueWithoutDescendantInput
      | RegionClosureUpdateWithWhereUniqueWithoutDescendantInput[];
    updateMany?:
      | RegionClosureUpdateManyWithWhereWithoutDescendantInput
      | RegionClosureUpdateManyWithWhereWithoutDescendantInput[];
    deleteMany?:
      | RegionClosureScalarWhereInput
      | RegionClosureScalarWhereInput[];
  };

  export type RegionCreateNestedOneWithoutAncestorsInput = {
    create?: XOR<
      RegionCreateWithoutAncestorsInput,
      RegionUncheckedCreateWithoutAncestorsInput
    >;
    connectOrCreate?: RegionCreateOrConnectWithoutAncestorsInput;
    connect?: RegionWhereUniqueInput;
  };

  export type RegionCreateNestedOneWithoutDescendantsInput = {
    create?: XOR<
      RegionCreateWithoutDescendantsInput,
      RegionUncheckedCreateWithoutDescendantsInput
    >;
    connectOrCreate?: RegionCreateOrConnectWithoutDescendantsInput;
    connect?: RegionWhereUniqueInput;
  };

  export type RegionUpdateOneRequiredWithoutAncestorsNestedInput = {
    create?: XOR<
      RegionCreateWithoutAncestorsInput,
      RegionUncheckedCreateWithoutAncestorsInput
    >;
    connectOrCreate?: RegionCreateOrConnectWithoutAncestorsInput;
    upsert?: RegionUpsertWithoutAncestorsInput;
    connect?: RegionWhereUniqueInput;
    update?: XOR<
      XOR<
        RegionUpdateToOneWithWhereWithoutAncestorsInput,
        RegionUpdateWithoutAncestorsInput
      >,
      RegionUncheckedUpdateWithoutAncestorsInput
    >;
  };

  export type RegionUpdateOneRequiredWithoutDescendantsNestedInput = {
    create?: XOR<
      RegionCreateWithoutDescendantsInput,
      RegionUncheckedCreateWithoutDescendantsInput
    >;
    connectOrCreate?: RegionCreateOrConnectWithoutDescendantsInput;
    upsert?: RegionUpsertWithoutDescendantsInput;
    connect?: RegionWhereUniqueInput;
    update?: XOR<
      XOR<
        RegionUpdateToOneWithWhereWithoutDescendantsInput,
        RegionUpdateWithoutDescendantsInput
      >,
      RegionUncheckedUpdateWithoutDescendantsInput
    >;
  };

  export type TopicCreateNestedOneWithoutItemsInput = {
    create?: XOR<
      TopicCreateWithoutItemsInput,
      TopicUncheckedCreateWithoutItemsInput
    >;
    connectOrCreate?: TopicCreateOrConnectWithoutItemsInput;
    connect?: TopicWhereUniqueInput;
  };

  export type ExtractedUnitCreateNestedManyWithoutItemInput = {
    create?:
      | XOR<
          ExtractedUnitCreateWithoutItemInput,
          ExtractedUnitUncheckedCreateWithoutItemInput
        >
      | ExtractedUnitCreateWithoutItemInput[]
      | ExtractedUnitUncheckedCreateWithoutItemInput[];
    connectOrCreate?:
      | ExtractedUnitCreateOrConnectWithoutItemInput
      | ExtractedUnitCreateOrConnectWithoutItemInput[];
    createMany?: ExtractedUnitCreateManyItemInputEnvelope;
    connect?: ExtractedUnitWhereUniqueInput | ExtractedUnitWhereUniqueInput[];
  };

  export type RegionCreateNestedOneWithoutItemsManualInput = {
    create?: XOR<
      RegionCreateWithoutItemsManualInput,
      RegionUncheckedCreateWithoutItemsManualInput
    >;
    connectOrCreate?: RegionCreateOrConnectWithoutItemsManualInput;
    connect?: RegionWhereUniqueInput;
  };

  export type RegionCreateNestedOneWithoutItemsEffectiveInput = {
    create?: XOR<
      RegionCreateWithoutItemsEffectiveInput,
      RegionUncheckedCreateWithoutItemsEffectiveInput
    >;
    connectOrCreate?: RegionCreateOrConnectWithoutItemsEffectiveInput;
    connect?: RegionWhereUniqueInput;
  };

  export type AnswerOptionCreateNestedManyWithoutItemInput = {
    create?:
      | XOR<
          AnswerOptionCreateWithoutItemInput,
          AnswerOptionUncheckedCreateWithoutItemInput
        >
      | AnswerOptionCreateWithoutItemInput[]
      | AnswerOptionUncheckedCreateWithoutItemInput[];
    connectOrCreate?:
      | AnswerOptionCreateOrConnectWithoutItemInput
      | AnswerOptionCreateOrConnectWithoutItemInput[];
    createMany?: AnswerOptionCreateManyItemInputEnvelope;
    connect?: AnswerOptionWhereUniqueInput | AnswerOptionWhereUniqueInput[];
  };

  export type ItemTagCreateNestedManyWithoutItemInput = {
    create?:
      | XOR<
          ItemTagCreateWithoutItemInput,
          ItemTagUncheckedCreateWithoutItemInput
        >
      | ItemTagCreateWithoutItemInput[]
      | ItemTagUncheckedCreateWithoutItemInput[];
    connectOrCreate?:
      | ItemTagCreateOrConnectWithoutItemInput
      | ItemTagCreateOrConnectWithoutItemInput[];
    createMany?: ItemTagCreateManyItemInputEnvelope;
    connect?: ItemTagWhereUniqueInput | ItemTagWhereUniqueInput[];
  };

  export type ExtractedUnitUncheckedCreateNestedManyWithoutItemInput = {
    create?:
      | XOR<
          ExtractedUnitCreateWithoutItemInput,
          ExtractedUnitUncheckedCreateWithoutItemInput
        >
      | ExtractedUnitCreateWithoutItemInput[]
      | ExtractedUnitUncheckedCreateWithoutItemInput[];
    connectOrCreate?:
      | ExtractedUnitCreateOrConnectWithoutItemInput
      | ExtractedUnitCreateOrConnectWithoutItemInput[];
    createMany?: ExtractedUnitCreateManyItemInputEnvelope;
    connect?: ExtractedUnitWhereUniqueInput | ExtractedUnitWhereUniqueInput[];
  };

  export type AnswerOptionUncheckedCreateNestedManyWithoutItemInput = {
    create?:
      | XOR<
          AnswerOptionCreateWithoutItemInput,
          AnswerOptionUncheckedCreateWithoutItemInput
        >
      | AnswerOptionCreateWithoutItemInput[]
      | AnswerOptionUncheckedCreateWithoutItemInput[];
    connectOrCreate?:
      | AnswerOptionCreateOrConnectWithoutItemInput
      | AnswerOptionCreateOrConnectWithoutItemInput[];
    createMany?: AnswerOptionCreateManyItemInputEnvelope;
    connect?: AnswerOptionWhereUniqueInput | AnswerOptionWhereUniqueInput[];
  };

  export type ItemTagUncheckedCreateNestedManyWithoutItemInput = {
    create?:
      | XOR<
          ItemTagCreateWithoutItemInput,
          ItemTagUncheckedCreateWithoutItemInput
        >
      | ItemTagCreateWithoutItemInput[]
      | ItemTagUncheckedCreateWithoutItemInput[];
    connectOrCreate?:
      | ItemTagCreateOrConnectWithoutItemInput
      | ItemTagCreateOrConnectWithoutItemInput[];
    createMany?: ItemTagCreateManyItemInputEnvelope;
    connect?: ItemTagWhereUniqueInput | ItemTagWhereUniqueInput[];
  };

  export type EnumContentKindFieldUpdateOperationsInput = {
    set?: $Enums.ContentKind;
  };

  export type EnumPublishStatusFieldUpdateOperationsInput = {
    set?: $Enums.PublishStatus;
  };

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null;
    unset?: boolean;
  };

  export type EnumRegionModeFieldUpdateOperationsInput = {
    set?: $Enums.RegionMode;
  };

  export type TopicUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<
      TopicCreateWithoutItemsInput,
      TopicUncheckedCreateWithoutItemsInput
    >;
    connectOrCreate?: TopicCreateOrConnectWithoutItemsInput;
    upsert?: TopicUpsertWithoutItemsInput;
    connect?: TopicWhereUniqueInput;
    update?: XOR<
      XOR<
        TopicUpdateToOneWithWhereWithoutItemsInput,
        TopicUpdateWithoutItemsInput
      >,
      TopicUncheckedUpdateWithoutItemsInput
    >;
  };

  export type ExtractedUnitUpdateManyWithoutItemNestedInput = {
    create?:
      | XOR<
          ExtractedUnitCreateWithoutItemInput,
          ExtractedUnitUncheckedCreateWithoutItemInput
        >
      | ExtractedUnitCreateWithoutItemInput[]
      | ExtractedUnitUncheckedCreateWithoutItemInput[];
    connectOrCreate?:
      | ExtractedUnitCreateOrConnectWithoutItemInput
      | ExtractedUnitCreateOrConnectWithoutItemInput[];
    upsert?:
      | ExtractedUnitUpsertWithWhereUniqueWithoutItemInput
      | ExtractedUnitUpsertWithWhereUniqueWithoutItemInput[];
    createMany?: ExtractedUnitCreateManyItemInputEnvelope;
    set?: ExtractedUnitWhereUniqueInput | ExtractedUnitWhereUniqueInput[];
    disconnect?:
      | ExtractedUnitWhereUniqueInput
      | ExtractedUnitWhereUniqueInput[];
    delete?: ExtractedUnitWhereUniqueInput | ExtractedUnitWhereUniqueInput[];
    connect?: ExtractedUnitWhereUniqueInput | ExtractedUnitWhereUniqueInput[];
    update?:
      | ExtractedUnitUpdateWithWhereUniqueWithoutItemInput
      | ExtractedUnitUpdateWithWhereUniqueWithoutItemInput[];
    updateMany?:
      | ExtractedUnitUpdateManyWithWhereWithoutItemInput
      | ExtractedUnitUpdateManyWithWhereWithoutItemInput[];
    deleteMany?:
      | ExtractedUnitScalarWhereInput
      | ExtractedUnitScalarWhereInput[];
  };

  export type RegionUpdateOneWithoutItemsManualNestedInput = {
    create?: XOR<
      RegionCreateWithoutItemsManualInput,
      RegionUncheckedCreateWithoutItemsManualInput
    >;
    connectOrCreate?: RegionCreateOrConnectWithoutItemsManualInput;
    upsert?: RegionUpsertWithoutItemsManualInput;
    disconnect?: boolean;
    delete?: RegionWhereInput | boolean;
    connect?: RegionWhereUniqueInput;
    update?: XOR<
      XOR<
        RegionUpdateToOneWithWhereWithoutItemsManualInput,
        RegionUpdateWithoutItemsManualInput
      >,
      RegionUncheckedUpdateWithoutItemsManualInput
    >;
  };

  export type RegionUpdateOneWithoutItemsEffectiveNestedInput = {
    create?: XOR<
      RegionCreateWithoutItemsEffectiveInput,
      RegionUncheckedCreateWithoutItemsEffectiveInput
    >;
    connectOrCreate?: RegionCreateOrConnectWithoutItemsEffectiveInput;
    upsert?: RegionUpsertWithoutItemsEffectiveInput;
    disconnect?: boolean;
    delete?: RegionWhereInput | boolean;
    connect?: RegionWhereUniqueInput;
    update?: XOR<
      XOR<
        RegionUpdateToOneWithWhereWithoutItemsEffectiveInput,
        RegionUpdateWithoutItemsEffectiveInput
      >,
      RegionUncheckedUpdateWithoutItemsEffectiveInput
    >;
  };

  export type AnswerOptionUpdateManyWithoutItemNestedInput = {
    create?:
      | XOR<
          AnswerOptionCreateWithoutItemInput,
          AnswerOptionUncheckedCreateWithoutItemInput
        >
      | AnswerOptionCreateWithoutItemInput[]
      | AnswerOptionUncheckedCreateWithoutItemInput[];
    connectOrCreate?:
      | AnswerOptionCreateOrConnectWithoutItemInput
      | AnswerOptionCreateOrConnectWithoutItemInput[];
    upsert?:
      | AnswerOptionUpsertWithWhereUniqueWithoutItemInput
      | AnswerOptionUpsertWithWhereUniqueWithoutItemInput[];
    createMany?: AnswerOptionCreateManyItemInputEnvelope;
    set?: AnswerOptionWhereUniqueInput | AnswerOptionWhereUniqueInput[];
    disconnect?: AnswerOptionWhereUniqueInput | AnswerOptionWhereUniqueInput[];
    delete?: AnswerOptionWhereUniqueInput | AnswerOptionWhereUniqueInput[];
    connect?: AnswerOptionWhereUniqueInput | AnswerOptionWhereUniqueInput[];
    update?:
      | AnswerOptionUpdateWithWhereUniqueWithoutItemInput
      | AnswerOptionUpdateWithWhereUniqueWithoutItemInput[];
    updateMany?:
      | AnswerOptionUpdateManyWithWhereWithoutItemInput
      | AnswerOptionUpdateManyWithWhereWithoutItemInput[];
    deleteMany?: AnswerOptionScalarWhereInput | AnswerOptionScalarWhereInput[];
  };

  export type ItemTagUpdateManyWithoutItemNestedInput = {
    create?:
      | XOR<
          ItemTagCreateWithoutItemInput,
          ItemTagUncheckedCreateWithoutItemInput
        >
      | ItemTagCreateWithoutItemInput[]
      | ItemTagUncheckedCreateWithoutItemInput[];
    connectOrCreate?:
      | ItemTagCreateOrConnectWithoutItemInput
      | ItemTagCreateOrConnectWithoutItemInput[];
    upsert?:
      | ItemTagUpsertWithWhereUniqueWithoutItemInput
      | ItemTagUpsertWithWhereUniqueWithoutItemInput[];
    createMany?: ItemTagCreateManyItemInputEnvelope;
    set?: ItemTagWhereUniqueInput | ItemTagWhereUniqueInput[];
    disconnect?: ItemTagWhereUniqueInput | ItemTagWhereUniqueInput[];
    delete?: ItemTagWhereUniqueInput | ItemTagWhereUniqueInput[];
    connect?: ItemTagWhereUniqueInput | ItemTagWhereUniqueInput[];
    update?:
      | ItemTagUpdateWithWhereUniqueWithoutItemInput
      | ItemTagUpdateWithWhereUniqueWithoutItemInput[];
    updateMany?:
      | ItemTagUpdateManyWithWhereWithoutItemInput
      | ItemTagUpdateManyWithWhereWithoutItemInput[];
    deleteMany?: ItemTagScalarWhereInput | ItemTagScalarWhereInput[];
  };

  export type ExtractedUnitUncheckedUpdateManyWithoutItemNestedInput = {
    create?:
      | XOR<
          ExtractedUnitCreateWithoutItemInput,
          ExtractedUnitUncheckedCreateWithoutItemInput
        >
      | ExtractedUnitCreateWithoutItemInput[]
      | ExtractedUnitUncheckedCreateWithoutItemInput[];
    connectOrCreate?:
      | ExtractedUnitCreateOrConnectWithoutItemInput
      | ExtractedUnitCreateOrConnectWithoutItemInput[];
    upsert?:
      | ExtractedUnitUpsertWithWhereUniqueWithoutItemInput
      | ExtractedUnitUpsertWithWhereUniqueWithoutItemInput[];
    createMany?: ExtractedUnitCreateManyItemInputEnvelope;
    set?: ExtractedUnitWhereUniqueInput | ExtractedUnitWhereUniqueInput[];
    disconnect?:
      | ExtractedUnitWhereUniqueInput
      | ExtractedUnitWhereUniqueInput[];
    delete?: ExtractedUnitWhereUniqueInput | ExtractedUnitWhereUniqueInput[];
    connect?: ExtractedUnitWhereUniqueInput | ExtractedUnitWhereUniqueInput[];
    update?:
      | ExtractedUnitUpdateWithWhereUniqueWithoutItemInput
      | ExtractedUnitUpdateWithWhereUniqueWithoutItemInput[];
    updateMany?:
      | ExtractedUnitUpdateManyWithWhereWithoutItemInput
      | ExtractedUnitUpdateManyWithWhereWithoutItemInput[];
    deleteMany?:
      | ExtractedUnitScalarWhereInput
      | ExtractedUnitScalarWhereInput[];
  };

  export type AnswerOptionUncheckedUpdateManyWithoutItemNestedInput = {
    create?:
      | XOR<
          AnswerOptionCreateWithoutItemInput,
          AnswerOptionUncheckedCreateWithoutItemInput
        >
      | AnswerOptionCreateWithoutItemInput[]
      | AnswerOptionUncheckedCreateWithoutItemInput[];
    connectOrCreate?:
      | AnswerOptionCreateOrConnectWithoutItemInput
      | AnswerOptionCreateOrConnectWithoutItemInput[];
    upsert?:
      | AnswerOptionUpsertWithWhereUniqueWithoutItemInput
      | AnswerOptionUpsertWithWhereUniqueWithoutItemInput[];
    createMany?: AnswerOptionCreateManyItemInputEnvelope;
    set?: AnswerOptionWhereUniqueInput | AnswerOptionWhereUniqueInput[];
    disconnect?: AnswerOptionWhereUniqueInput | AnswerOptionWhereUniqueInput[];
    delete?: AnswerOptionWhereUniqueInput | AnswerOptionWhereUniqueInput[];
    connect?: AnswerOptionWhereUniqueInput | AnswerOptionWhereUniqueInput[];
    update?:
      | AnswerOptionUpdateWithWhereUniqueWithoutItemInput
      | AnswerOptionUpdateWithWhereUniqueWithoutItemInput[];
    updateMany?:
      | AnswerOptionUpdateManyWithWhereWithoutItemInput
      | AnswerOptionUpdateManyWithWhereWithoutItemInput[];
    deleteMany?: AnswerOptionScalarWhereInput | AnswerOptionScalarWhereInput[];
  };

  export type ItemTagUncheckedUpdateManyWithoutItemNestedInput = {
    create?:
      | XOR<
          ItemTagCreateWithoutItemInput,
          ItemTagUncheckedCreateWithoutItemInput
        >
      | ItemTagCreateWithoutItemInput[]
      | ItemTagUncheckedCreateWithoutItemInput[];
    connectOrCreate?:
      | ItemTagCreateOrConnectWithoutItemInput
      | ItemTagCreateOrConnectWithoutItemInput[];
    upsert?:
      | ItemTagUpsertWithWhereUniqueWithoutItemInput
      | ItemTagUpsertWithWhereUniqueWithoutItemInput[];
    createMany?: ItemTagCreateManyItemInputEnvelope;
    set?: ItemTagWhereUniqueInput | ItemTagWhereUniqueInput[];
    disconnect?: ItemTagWhereUniqueInput | ItemTagWhereUniqueInput[];
    delete?: ItemTagWhereUniqueInput | ItemTagWhereUniqueInput[];
    connect?: ItemTagWhereUniqueInput | ItemTagWhereUniqueInput[];
    update?:
      | ItemTagUpdateWithWhereUniqueWithoutItemInput
      | ItemTagUpdateWithWhereUniqueWithoutItemInput[];
    updateMany?:
      | ItemTagUpdateManyWithWhereWithoutItemInput
      | ItemTagUpdateManyWithWhereWithoutItemInput[];
    deleteMany?: ItemTagScalarWhereInput | ItemTagScalarWhereInput[];
  };

  export type ContentItemCreateNestedOneWithoutAnswerOptionsInput = {
    create?: XOR<
      ContentItemCreateWithoutAnswerOptionsInput,
      ContentItemUncheckedCreateWithoutAnswerOptionsInput
    >;
    connectOrCreate?: ContentItemCreateOrConnectWithoutAnswerOptionsInput;
    connect?: ContentItemWhereUniqueInput;
  };

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean;
  };

  export type ContentItemUpdateOneRequiredWithoutAnswerOptionsNestedInput = {
    create?: XOR<
      ContentItemCreateWithoutAnswerOptionsInput,
      ContentItemUncheckedCreateWithoutAnswerOptionsInput
    >;
    connectOrCreate?: ContentItemCreateOrConnectWithoutAnswerOptionsInput;
    upsert?: ContentItemUpsertWithoutAnswerOptionsInput;
    connect?: ContentItemWhereUniqueInput;
    update?: XOR<
      XOR<
        ContentItemUpdateToOneWithWhereWithoutAnswerOptionsInput,
        ContentItemUpdateWithoutAnswerOptionsInput
      >,
      ContentItemUncheckedUpdateWithoutAnswerOptionsInput
    >;
  };

  export type FactcheckClaimCreateNestedManyWithoutJobInput = {
    create?:
      | XOR<
          FactcheckClaimCreateWithoutJobInput,
          FactcheckClaimUncheckedCreateWithoutJobInput
        >
      | FactcheckClaimCreateWithoutJobInput[]
      | FactcheckClaimUncheckedCreateWithoutJobInput[];
    connectOrCreate?:
      | FactcheckClaimCreateOrConnectWithoutJobInput
      | FactcheckClaimCreateOrConnectWithoutJobInput[];
    createMany?: FactcheckClaimCreateManyJobInputEnvelope;
    connect?: FactcheckClaimWhereUniqueInput | FactcheckClaimWhereUniqueInput[];
  };

  export type FactcheckResultCreateNestedManyWithoutJobInput = {
    create?:
      | XOR<
          FactcheckResultCreateWithoutJobInput,
          FactcheckResultUncheckedCreateWithoutJobInput
        >
      | FactcheckResultCreateWithoutJobInput[]
      | FactcheckResultUncheckedCreateWithoutJobInput[];
    connectOrCreate?:
      | FactcheckResultCreateOrConnectWithoutJobInput
      | FactcheckResultCreateOrConnectWithoutJobInput[];
    createMany?: FactcheckResultCreateManyJobInputEnvelope;
    connect?:
      | FactcheckResultWhereUniqueInput
      | FactcheckResultWhereUniqueInput[];
  };

  export type FactcheckClaimUncheckedCreateNestedManyWithoutJobInput = {
    create?:
      | XOR<
          FactcheckClaimCreateWithoutJobInput,
          FactcheckClaimUncheckedCreateWithoutJobInput
        >
      | FactcheckClaimCreateWithoutJobInput[]
      | FactcheckClaimUncheckedCreateWithoutJobInput[];
    connectOrCreate?:
      | FactcheckClaimCreateOrConnectWithoutJobInput
      | FactcheckClaimCreateOrConnectWithoutJobInput[];
    createMany?: FactcheckClaimCreateManyJobInputEnvelope;
    connect?: FactcheckClaimWhereUniqueInput | FactcheckClaimWhereUniqueInput[];
  };

  export type FactcheckResultUncheckedCreateNestedManyWithoutJobInput = {
    create?:
      | XOR<
          FactcheckResultCreateWithoutJobInput,
          FactcheckResultUncheckedCreateWithoutJobInput
        >
      | FactcheckResultCreateWithoutJobInput[]
      | FactcheckResultUncheckedCreateWithoutJobInput[];
    connectOrCreate?:
      | FactcheckResultCreateOrConnectWithoutJobInput
      | FactcheckResultCreateOrConnectWithoutJobInput[];
    createMany?: FactcheckResultCreateManyJobInputEnvelope;
    connect?:
      | FactcheckResultWhereUniqueInput
      | FactcheckResultWhereUniqueInput[];
  };

  export type FactcheckClaimUpdateManyWithoutJobNestedInput = {
    create?:
      | XOR<
          FactcheckClaimCreateWithoutJobInput,
          FactcheckClaimUncheckedCreateWithoutJobInput
        >
      | FactcheckClaimCreateWithoutJobInput[]
      | FactcheckClaimUncheckedCreateWithoutJobInput[];
    connectOrCreate?:
      | FactcheckClaimCreateOrConnectWithoutJobInput
      | FactcheckClaimCreateOrConnectWithoutJobInput[];
    upsert?:
      | FactcheckClaimUpsertWithWhereUniqueWithoutJobInput
      | FactcheckClaimUpsertWithWhereUniqueWithoutJobInput[];
    createMany?: FactcheckClaimCreateManyJobInputEnvelope;
    set?: FactcheckClaimWhereUniqueInput | FactcheckClaimWhereUniqueInput[];
    disconnect?:
      | FactcheckClaimWhereUniqueInput
      | FactcheckClaimWhereUniqueInput[];
    delete?: FactcheckClaimWhereUniqueInput | FactcheckClaimWhereUniqueInput[];
    connect?: FactcheckClaimWhereUniqueInput | FactcheckClaimWhereUniqueInput[];
    update?:
      | FactcheckClaimUpdateWithWhereUniqueWithoutJobInput
      | FactcheckClaimUpdateWithWhereUniqueWithoutJobInput[];
    updateMany?:
      | FactcheckClaimUpdateManyWithWhereWithoutJobInput
      | FactcheckClaimUpdateManyWithWhereWithoutJobInput[];
    deleteMany?:
      | FactcheckClaimScalarWhereInput
      | FactcheckClaimScalarWhereInput[];
  };

  export type FactcheckResultUpdateManyWithoutJobNestedInput = {
    create?:
      | XOR<
          FactcheckResultCreateWithoutJobInput,
          FactcheckResultUncheckedCreateWithoutJobInput
        >
      | FactcheckResultCreateWithoutJobInput[]
      | FactcheckResultUncheckedCreateWithoutJobInput[];
    connectOrCreate?:
      | FactcheckResultCreateOrConnectWithoutJobInput
      | FactcheckResultCreateOrConnectWithoutJobInput[];
    upsert?:
      | FactcheckResultUpsertWithWhereUniqueWithoutJobInput
      | FactcheckResultUpsertWithWhereUniqueWithoutJobInput[];
    createMany?: FactcheckResultCreateManyJobInputEnvelope;
    set?: FactcheckResultWhereUniqueInput | FactcheckResultWhereUniqueInput[];
    disconnect?:
      | FactcheckResultWhereUniqueInput
      | FactcheckResultWhereUniqueInput[];
    delete?:
      | FactcheckResultWhereUniqueInput
      | FactcheckResultWhereUniqueInput[];
    connect?:
      | FactcheckResultWhereUniqueInput
      | FactcheckResultWhereUniqueInput[];
    update?:
      | FactcheckResultUpdateWithWhereUniqueWithoutJobInput
      | FactcheckResultUpdateWithWhereUniqueWithoutJobInput[];
    updateMany?:
      | FactcheckResultUpdateManyWithWhereWithoutJobInput
      | FactcheckResultUpdateManyWithWhereWithoutJobInput[];
    deleteMany?:
      | FactcheckResultScalarWhereInput
      | FactcheckResultScalarWhereInput[];
  };

  export type FactcheckClaimUncheckedUpdateManyWithoutJobNestedInput = {
    create?:
      | XOR<
          FactcheckClaimCreateWithoutJobInput,
          FactcheckClaimUncheckedCreateWithoutJobInput
        >
      | FactcheckClaimCreateWithoutJobInput[]
      | FactcheckClaimUncheckedCreateWithoutJobInput[];
    connectOrCreate?:
      | FactcheckClaimCreateOrConnectWithoutJobInput
      | FactcheckClaimCreateOrConnectWithoutJobInput[];
    upsert?:
      | FactcheckClaimUpsertWithWhereUniqueWithoutJobInput
      | FactcheckClaimUpsertWithWhereUniqueWithoutJobInput[];
    createMany?: FactcheckClaimCreateManyJobInputEnvelope;
    set?: FactcheckClaimWhereUniqueInput | FactcheckClaimWhereUniqueInput[];
    disconnect?:
      | FactcheckClaimWhereUniqueInput
      | FactcheckClaimWhereUniqueInput[];
    delete?: FactcheckClaimWhereUniqueInput | FactcheckClaimWhereUniqueInput[];
    connect?: FactcheckClaimWhereUniqueInput | FactcheckClaimWhereUniqueInput[];
    update?:
      | FactcheckClaimUpdateWithWhereUniqueWithoutJobInput
      | FactcheckClaimUpdateWithWhereUniqueWithoutJobInput[];
    updateMany?:
      | FactcheckClaimUpdateManyWithWhereWithoutJobInput
      | FactcheckClaimUpdateManyWithWhereWithoutJobInput[];
    deleteMany?:
      | FactcheckClaimScalarWhereInput
      | FactcheckClaimScalarWhereInput[];
  };

  export type FactcheckResultUncheckedUpdateManyWithoutJobNestedInput = {
    create?:
      | XOR<
          FactcheckResultCreateWithoutJobInput,
          FactcheckResultUncheckedCreateWithoutJobInput
        >
      | FactcheckResultCreateWithoutJobInput[]
      | FactcheckResultUncheckedCreateWithoutJobInput[];
    connectOrCreate?:
      | FactcheckResultCreateOrConnectWithoutJobInput
      | FactcheckResultCreateOrConnectWithoutJobInput[];
    upsert?:
      | FactcheckResultUpsertWithWhereUniqueWithoutJobInput
      | FactcheckResultUpsertWithWhereUniqueWithoutJobInput[];
    createMany?: FactcheckResultCreateManyJobInputEnvelope;
    set?: FactcheckResultWhereUniqueInput | FactcheckResultWhereUniqueInput[];
    disconnect?:
      | FactcheckResultWhereUniqueInput
      | FactcheckResultWhereUniqueInput[];
    delete?:
      | FactcheckResultWhereUniqueInput
      | FactcheckResultWhereUniqueInput[];
    connect?:
      | FactcheckResultWhereUniqueInput
      | FactcheckResultWhereUniqueInput[];
    update?:
      | FactcheckResultUpdateWithWhereUniqueWithoutJobInput
      | FactcheckResultUpdateWithWhereUniqueWithoutJobInput[];
    updateMany?:
      | FactcheckResultUpdateManyWithWhereWithoutJobInput
      | FactcheckResultUpdateManyWithWhereWithoutJobInput[];
    deleteMany?:
      | FactcheckResultScalarWhereInput
      | FactcheckResultScalarWhereInput[];
  };

  export type FactcheckClaimCreateframesInput = {
    set: string[];
  };

  export type FactcheckClaimCreaterhetoricalFlagsInput = {
    set: string[];
  };

  export type FactcheckJobCreateNestedOneWithoutClaimsInput = {
    create?: XOR<
      FactcheckJobCreateWithoutClaimsInput,
      FactcheckJobUncheckedCreateWithoutClaimsInput
    >;
    connectOrCreate?: FactcheckJobCreateOrConnectWithoutClaimsInput;
    connect?: FactcheckJobWhereUniqueInput;
  };

  export type ProviderRunCreateNestedManyWithoutClaimInput = {
    create?:
      | XOR<
          ProviderRunCreateWithoutClaimInput,
          ProviderRunUncheckedCreateWithoutClaimInput
        >
      | ProviderRunCreateWithoutClaimInput[]
      | ProviderRunUncheckedCreateWithoutClaimInput[];
    connectOrCreate?:
      | ProviderRunCreateOrConnectWithoutClaimInput
      | ProviderRunCreateOrConnectWithoutClaimInput[];
    createMany?: ProviderRunCreateManyClaimInputEnvelope;
    connect?: ProviderRunWhereUniqueInput | ProviderRunWhereUniqueInput[];
  };

  export type EvidenceCreateNestedManyWithoutClaimInput = {
    create?:
      | XOR<
          EvidenceCreateWithoutClaimInput,
          EvidenceUncheckedCreateWithoutClaimInput
        >
      | EvidenceCreateWithoutClaimInput[]
      | EvidenceUncheckedCreateWithoutClaimInput[];
    connectOrCreate?:
      | EvidenceCreateOrConnectWithoutClaimInput
      | EvidenceCreateOrConnectWithoutClaimInput[];
    createMany?: EvidenceCreateManyClaimInputEnvelope;
    connect?: EvidenceWhereUniqueInput | EvidenceWhereUniqueInput[];
  };

  export type ConsensusRunCreateNestedOneWithoutClaimInput = {
    create?: XOR<
      ConsensusRunCreateWithoutClaimInput,
      ConsensusRunUncheckedCreateWithoutClaimInput
    >;
    connectOrCreate?: ConsensusRunCreateOrConnectWithoutClaimInput;
    connect?: ConsensusRunWhereUniqueInput;
  };

  export type VerdictVersionCreateNestedManyWithoutClaimInput = {
    create?:
      | XOR<
          VerdictVersionCreateWithoutClaimInput,
          VerdictVersionUncheckedCreateWithoutClaimInput
        >
      | VerdictVersionCreateWithoutClaimInput[]
      | VerdictVersionUncheckedCreateWithoutClaimInput[];
    connectOrCreate?:
      | VerdictVersionCreateOrConnectWithoutClaimInput
      | VerdictVersionCreateOrConnectWithoutClaimInput[];
    createMany?: VerdictVersionCreateManyClaimInputEnvelope;
    connect?: VerdictVersionWhereUniqueInput | VerdictVersionWhereUniqueInput[];
  };

  export type ExtractedUnitCreateNestedManyWithoutClaimInput = {
    create?:
      | XOR<
          ExtractedUnitCreateWithoutClaimInput,
          ExtractedUnitUncheckedCreateWithoutClaimInput
        >
      | ExtractedUnitCreateWithoutClaimInput[]
      | ExtractedUnitUncheckedCreateWithoutClaimInput[];
    connectOrCreate?:
      | ExtractedUnitCreateOrConnectWithoutClaimInput
      | ExtractedUnitCreateOrConnectWithoutClaimInput[];
    createMany?: ExtractedUnitCreateManyClaimInputEnvelope;
    connect?: ExtractedUnitWhereUniqueInput | ExtractedUnitWhereUniqueInput[];
  };

  export type FindingCreateNestedOneWithoutClaimInput = {
    create?: XOR<
      FindingCreateWithoutClaimInput,
      FindingUncheckedCreateWithoutClaimInput
    >;
    connectOrCreate?: FindingCreateOrConnectWithoutClaimInput;
    connect?: FindingWhereUniqueInput;
  };

  export type ProviderRunUncheckedCreateNestedManyWithoutClaimInput = {
    create?:
      | XOR<
          ProviderRunCreateWithoutClaimInput,
          ProviderRunUncheckedCreateWithoutClaimInput
        >
      | ProviderRunCreateWithoutClaimInput[]
      | ProviderRunUncheckedCreateWithoutClaimInput[];
    connectOrCreate?:
      | ProviderRunCreateOrConnectWithoutClaimInput
      | ProviderRunCreateOrConnectWithoutClaimInput[];
    createMany?: ProviderRunCreateManyClaimInputEnvelope;
    connect?: ProviderRunWhereUniqueInput | ProviderRunWhereUniqueInput[];
  };

  export type EvidenceUncheckedCreateNestedManyWithoutClaimInput = {
    create?:
      | XOR<
          EvidenceCreateWithoutClaimInput,
          EvidenceUncheckedCreateWithoutClaimInput
        >
      | EvidenceCreateWithoutClaimInput[]
      | EvidenceUncheckedCreateWithoutClaimInput[];
    connectOrCreate?:
      | EvidenceCreateOrConnectWithoutClaimInput
      | EvidenceCreateOrConnectWithoutClaimInput[];
    createMany?: EvidenceCreateManyClaimInputEnvelope;
    connect?: EvidenceWhereUniqueInput | EvidenceWhereUniqueInput[];
  };

  export type ConsensusRunUncheckedCreateNestedOneWithoutClaimInput = {
    create?: XOR<
      ConsensusRunCreateWithoutClaimInput,
      ConsensusRunUncheckedCreateWithoutClaimInput
    >;
    connectOrCreate?: ConsensusRunCreateOrConnectWithoutClaimInput;
    connect?: ConsensusRunWhereUniqueInput;
  };

  export type VerdictVersionUncheckedCreateNestedManyWithoutClaimInput = {
    create?:
      | XOR<
          VerdictVersionCreateWithoutClaimInput,
          VerdictVersionUncheckedCreateWithoutClaimInput
        >
      | VerdictVersionCreateWithoutClaimInput[]
      | VerdictVersionUncheckedCreateWithoutClaimInput[];
    connectOrCreate?:
      | VerdictVersionCreateOrConnectWithoutClaimInput
      | VerdictVersionCreateOrConnectWithoutClaimInput[];
    createMany?: VerdictVersionCreateManyClaimInputEnvelope;
    connect?: VerdictVersionWhereUniqueInput | VerdictVersionWhereUniqueInput[];
  };

  export type ExtractedUnitUncheckedCreateNestedManyWithoutClaimInput = {
    create?:
      | XOR<
          ExtractedUnitCreateWithoutClaimInput,
          ExtractedUnitUncheckedCreateWithoutClaimInput
        >
      | ExtractedUnitCreateWithoutClaimInput[]
      | ExtractedUnitUncheckedCreateWithoutClaimInput[];
    connectOrCreate?:
      | ExtractedUnitCreateOrConnectWithoutClaimInput
      | ExtractedUnitCreateOrConnectWithoutClaimInput[];
    createMany?: ExtractedUnitCreateManyClaimInputEnvelope;
    connect?: ExtractedUnitWhereUniqueInput | ExtractedUnitWhereUniqueInput[];
  };

  export type FindingUncheckedCreateNestedOneWithoutClaimInput = {
    create?: XOR<
      FindingCreateWithoutClaimInput,
      FindingUncheckedCreateWithoutClaimInput
    >;
    connectOrCreate?: FindingCreateOrConnectWithoutClaimInput;
    connect?: FindingWhereUniqueInput;
  };

  export type FactcheckClaimUpdateframesInput = {
    set?: string[];
    push?: string | string[];
  };

  export type FactcheckClaimUpdaterhetoricalFlagsInput = {
    set?: string[];
    push?: string | string[];
  };

  export type EnumReviewStatusFieldUpdateOperationsInput = {
    set?: $Enums.ReviewStatus;
  };

  export type FactcheckJobUpdateOneRequiredWithoutClaimsNestedInput = {
    create?: XOR<
      FactcheckJobCreateWithoutClaimsInput,
      FactcheckJobUncheckedCreateWithoutClaimsInput
    >;
    connectOrCreate?: FactcheckJobCreateOrConnectWithoutClaimsInput;
    upsert?: FactcheckJobUpsertWithoutClaimsInput;
    connect?: FactcheckJobWhereUniqueInput;
    update?: XOR<
      XOR<
        FactcheckJobUpdateToOneWithWhereWithoutClaimsInput,
        FactcheckJobUpdateWithoutClaimsInput
      >,
      FactcheckJobUncheckedUpdateWithoutClaimsInput
    >;
  };

  export type ProviderRunUpdateManyWithoutClaimNestedInput = {
    create?:
      | XOR<
          ProviderRunCreateWithoutClaimInput,
          ProviderRunUncheckedCreateWithoutClaimInput
        >
      | ProviderRunCreateWithoutClaimInput[]
      | ProviderRunUncheckedCreateWithoutClaimInput[];
    connectOrCreate?:
      | ProviderRunCreateOrConnectWithoutClaimInput
      | ProviderRunCreateOrConnectWithoutClaimInput[];
    upsert?:
      | ProviderRunUpsertWithWhereUniqueWithoutClaimInput
      | ProviderRunUpsertWithWhereUniqueWithoutClaimInput[];
    createMany?: ProviderRunCreateManyClaimInputEnvelope;
    set?: ProviderRunWhereUniqueInput | ProviderRunWhereUniqueInput[];
    disconnect?: ProviderRunWhereUniqueInput | ProviderRunWhereUniqueInput[];
    delete?: ProviderRunWhereUniqueInput | ProviderRunWhereUniqueInput[];
    connect?: ProviderRunWhereUniqueInput | ProviderRunWhereUniqueInput[];
    update?:
      | ProviderRunUpdateWithWhereUniqueWithoutClaimInput
      | ProviderRunUpdateWithWhereUniqueWithoutClaimInput[];
    updateMany?:
      | ProviderRunUpdateManyWithWhereWithoutClaimInput
      | ProviderRunUpdateManyWithWhereWithoutClaimInput[];
    deleteMany?: ProviderRunScalarWhereInput | ProviderRunScalarWhereInput[];
  };

  export type EvidenceUpdateManyWithoutClaimNestedInput = {
    create?:
      | XOR<
          EvidenceCreateWithoutClaimInput,
          EvidenceUncheckedCreateWithoutClaimInput
        >
      | EvidenceCreateWithoutClaimInput[]
      | EvidenceUncheckedCreateWithoutClaimInput[];
    connectOrCreate?:
      | EvidenceCreateOrConnectWithoutClaimInput
      | EvidenceCreateOrConnectWithoutClaimInput[];
    upsert?:
      | EvidenceUpsertWithWhereUniqueWithoutClaimInput
      | EvidenceUpsertWithWhereUniqueWithoutClaimInput[];
    createMany?: EvidenceCreateManyClaimInputEnvelope;
    set?: EvidenceWhereUniqueInput | EvidenceWhereUniqueInput[];
    disconnect?: EvidenceWhereUniqueInput | EvidenceWhereUniqueInput[];
    delete?: EvidenceWhereUniqueInput | EvidenceWhereUniqueInput[];
    connect?: EvidenceWhereUniqueInput | EvidenceWhereUniqueInput[];
    update?:
      | EvidenceUpdateWithWhereUniqueWithoutClaimInput
      | EvidenceUpdateWithWhereUniqueWithoutClaimInput[];
    updateMany?:
      | EvidenceUpdateManyWithWhereWithoutClaimInput
      | EvidenceUpdateManyWithWhereWithoutClaimInput[];
    deleteMany?: EvidenceScalarWhereInput | EvidenceScalarWhereInput[];
  };

  export type ConsensusRunUpdateOneWithoutClaimNestedInput = {
    create?: XOR<
      ConsensusRunCreateWithoutClaimInput,
      ConsensusRunUncheckedCreateWithoutClaimInput
    >;
    connectOrCreate?: ConsensusRunCreateOrConnectWithoutClaimInput;
    upsert?: ConsensusRunUpsertWithoutClaimInput;
    disconnect?: ConsensusRunWhereInput | boolean;
    delete?: ConsensusRunWhereInput | boolean;
    connect?: ConsensusRunWhereUniqueInput;
    update?: XOR<
      XOR<
        ConsensusRunUpdateToOneWithWhereWithoutClaimInput,
        ConsensusRunUpdateWithoutClaimInput
      >,
      ConsensusRunUncheckedUpdateWithoutClaimInput
    >;
  };

  export type VerdictVersionUpdateManyWithoutClaimNestedInput = {
    create?:
      | XOR<
          VerdictVersionCreateWithoutClaimInput,
          VerdictVersionUncheckedCreateWithoutClaimInput
        >
      | VerdictVersionCreateWithoutClaimInput[]
      | VerdictVersionUncheckedCreateWithoutClaimInput[];
    connectOrCreate?:
      | VerdictVersionCreateOrConnectWithoutClaimInput
      | VerdictVersionCreateOrConnectWithoutClaimInput[];
    upsert?:
      | VerdictVersionUpsertWithWhereUniqueWithoutClaimInput
      | VerdictVersionUpsertWithWhereUniqueWithoutClaimInput[];
    createMany?: VerdictVersionCreateManyClaimInputEnvelope;
    set?: VerdictVersionWhereUniqueInput | VerdictVersionWhereUniqueInput[];
    disconnect?:
      | VerdictVersionWhereUniqueInput
      | VerdictVersionWhereUniqueInput[];
    delete?: VerdictVersionWhereUniqueInput | VerdictVersionWhereUniqueInput[];
    connect?: VerdictVersionWhereUniqueInput | VerdictVersionWhereUniqueInput[];
    update?:
      | VerdictVersionUpdateWithWhereUniqueWithoutClaimInput
      | VerdictVersionUpdateWithWhereUniqueWithoutClaimInput[];
    updateMany?:
      | VerdictVersionUpdateManyWithWhereWithoutClaimInput
      | VerdictVersionUpdateManyWithWhereWithoutClaimInput[];
    deleteMany?:
      | VerdictVersionScalarWhereInput
      | VerdictVersionScalarWhereInput[];
  };

  export type ExtractedUnitUpdateManyWithoutClaimNestedInput = {
    create?:
      | XOR<
          ExtractedUnitCreateWithoutClaimInput,
          ExtractedUnitUncheckedCreateWithoutClaimInput
        >
      | ExtractedUnitCreateWithoutClaimInput[]
      | ExtractedUnitUncheckedCreateWithoutClaimInput[];
    connectOrCreate?:
      | ExtractedUnitCreateOrConnectWithoutClaimInput
      | ExtractedUnitCreateOrConnectWithoutClaimInput[];
    upsert?:
      | ExtractedUnitUpsertWithWhereUniqueWithoutClaimInput
      | ExtractedUnitUpsertWithWhereUniqueWithoutClaimInput[];
    createMany?: ExtractedUnitCreateManyClaimInputEnvelope;
    set?: ExtractedUnitWhereUniqueInput | ExtractedUnitWhereUniqueInput[];
    disconnect?:
      | ExtractedUnitWhereUniqueInput
      | ExtractedUnitWhereUniqueInput[];
    delete?: ExtractedUnitWhereUniqueInput | ExtractedUnitWhereUniqueInput[];
    connect?: ExtractedUnitWhereUniqueInput | ExtractedUnitWhereUniqueInput[];
    update?:
      | ExtractedUnitUpdateWithWhereUniqueWithoutClaimInput
      | ExtractedUnitUpdateWithWhereUniqueWithoutClaimInput[];
    updateMany?:
      | ExtractedUnitUpdateManyWithWhereWithoutClaimInput
      | ExtractedUnitUpdateManyWithWhereWithoutClaimInput[];
    deleteMany?:
      | ExtractedUnitScalarWhereInput
      | ExtractedUnitScalarWhereInput[];
  };

  export type FindingUpdateOneWithoutClaimNestedInput = {
    create?: XOR<
      FindingCreateWithoutClaimInput,
      FindingUncheckedCreateWithoutClaimInput
    >;
    connectOrCreate?: FindingCreateOrConnectWithoutClaimInput;
    upsert?: FindingUpsertWithoutClaimInput;
    disconnect?: FindingWhereInput | boolean;
    delete?: FindingWhereInput | boolean;
    connect?: FindingWhereUniqueInput;
    update?: XOR<
      XOR<
        FindingUpdateToOneWithWhereWithoutClaimInput,
        FindingUpdateWithoutClaimInput
      >,
      FindingUncheckedUpdateWithoutClaimInput
    >;
  };

  export type ProviderRunUncheckedUpdateManyWithoutClaimNestedInput = {
    create?:
      | XOR<
          ProviderRunCreateWithoutClaimInput,
          ProviderRunUncheckedCreateWithoutClaimInput
        >
      | ProviderRunCreateWithoutClaimInput[]
      | ProviderRunUncheckedCreateWithoutClaimInput[];
    connectOrCreate?:
      | ProviderRunCreateOrConnectWithoutClaimInput
      | ProviderRunCreateOrConnectWithoutClaimInput[];
    upsert?:
      | ProviderRunUpsertWithWhereUniqueWithoutClaimInput
      | ProviderRunUpsertWithWhereUniqueWithoutClaimInput[];
    createMany?: ProviderRunCreateManyClaimInputEnvelope;
    set?: ProviderRunWhereUniqueInput | ProviderRunWhereUniqueInput[];
    disconnect?: ProviderRunWhereUniqueInput | ProviderRunWhereUniqueInput[];
    delete?: ProviderRunWhereUniqueInput | ProviderRunWhereUniqueInput[];
    connect?: ProviderRunWhereUniqueInput | ProviderRunWhereUniqueInput[];
    update?:
      | ProviderRunUpdateWithWhereUniqueWithoutClaimInput
      | ProviderRunUpdateWithWhereUniqueWithoutClaimInput[];
    updateMany?:
      | ProviderRunUpdateManyWithWhereWithoutClaimInput
      | ProviderRunUpdateManyWithWhereWithoutClaimInput[];
    deleteMany?: ProviderRunScalarWhereInput | ProviderRunScalarWhereInput[];
  };

  export type EvidenceUncheckedUpdateManyWithoutClaimNestedInput = {
    create?:
      | XOR<
          EvidenceCreateWithoutClaimInput,
          EvidenceUncheckedCreateWithoutClaimInput
        >
      | EvidenceCreateWithoutClaimInput[]
      | EvidenceUncheckedCreateWithoutClaimInput[];
    connectOrCreate?:
      | EvidenceCreateOrConnectWithoutClaimInput
      | EvidenceCreateOrConnectWithoutClaimInput[];
    upsert?:
      | EvidenceUpsertWithWhereUniqueWithoutClaimInput
      | EvidenceUpsertWithWhereUniqueWithoutClaimInput[];
    createMany?: EvidenceCreateManyClaimInputEnvelope;
    set?: EvidenceWhereUniqueInput | EvidenceWhereUniqueInput[];
    disconnect?: EvidenceWhereUniqueInput | EvidenceWhereUniqueInput[];
    delete?: EvidenceWhereUniqueInput | EvidenceWhereUniqueInput[];
    connect?: EvidenceWhereUniqueInput | EvidenceWhereUniqueInput[];
    update?:
      | EvidenceUpdateWithWhereUniqueWithoutClaimInput
      | EvidenceUpdateWithWhereUniqueWithoutClaimInput[];
    updateMany?:
      | EvidenceUpdateManyWithWhereWithoutClaimInput
      | EvidenceUpdateManyWithWhereWithoutClaimInput[];
    deleteMany?: EvidenceScalarWhereInput | EvidenceScalarWhereInput[];
  };

  export type ConsensusRunUncheckedUpdateOneWithoutClaimNestedInput = {
    create?: XOR<
      ConsensusRunCreateWithoutClaimInput,
      ConsensusRunUncheckedCreateWithoutClaimInput
    >;
    connectOrCreate?: ConsensusRunCreateOrConnectWithoutClaimInput;
    upsert?: ConsensusRunUpsertWithoutClaimInput;
    disconnect?: ConsensusRunWhereInput | boolean;
    delete?: ConsensusRunWhereInput | boolean;
    connect?: ConsensusRunWhereUniqueInput;
    update?: XOR<
      XOR<
        ConsensusRunUpdateToOneWithWhereWithoutClaimInput,
        ConsensusRunUpdateWithoutClaimInput
      >,
      ConsensusRunUncheckedUpdateWithoutClaimInput
    >;
  };

  export type VerdictVersionUncheckedUpdateManyWithoutClaimNestedInput = {
    create?:
      | XOR<
          VerdictVersionCreateWithoutClaimInput,
          VerdictVersionUncheckedCreateWithoutClaimInput
        >
      | VerdictVersionCreateWithoutClaimInput[]
      | VerdictVersionUncheckedCreateWithoutClaimInput[];
    connectOrCreate?:
      | VerdictVersionCreateOrConnectWithoutClaimInput
      | VerdictVersionCreateOrConnectWithoutClaimInput[];
    upsert?:
      | VerdictVersionUpsertWithWhereUniqueWithoutClaimInput
      | VerdictVersionUpsertWithWhereUniqueWithoutClaimInput[];
    createMany?: VerdictVersionCreateManyClaimInputEnvelope;
    set?: VerdictVersionWhereUniqueInput | VerdictVersionWhereUniqueInput[];
    disconnect?:
      | VerdictVersionWhereUniqueInput
      | VerdictVersionWhereUniqueInput[];
    delete?: VerdictVersionWhereUniqueInput | VerdictVersionWhereUniqueInput[];
    connect?: VerdictVersionWhereUniqueInput | VerdictVersionWhereUniqueInput[];
    update?:
      | VerdictVersionUpdateWithWhereUniqueWithoutClaimInput
      | VerdictVersionUpdateWithWhereUniqueWithoutClaimInput[];
    updateMany?:
      | VerdictVersionUpdateManyWithWhereWithoutClaimInput
      | VerdictVersionUpdateManyWithWhereWithoutClaimInput[];
    deleteMany?:
      | VerdictVersionScalarWhereInput
      | VerdictVersionScalarWhereInput[];
  };

  export type ExtractedUnitUncheckedUpdateManyWithoutClaimNestedInput = {
    create?:
      | XOR<
          ExtractedUnitCreateWithoutClaimInput,
          ExtractedUnitUncheckedCreateWithoutClaimInput
        >
      | ExtractedUnitCreateWithoutClaimInput[]
      | ExtractedUnitUncheckedCreateWithoutClaimInput[];
    connectOrCreate?:
      | ExtractedUnitCreateOrConnectWithoutClaimInput
      | ExtractedUnitCreateOrConnectWithoutClaimInput[];
    upsert?:
      | ExtractedUnitUpsertWithWhereUniqueWithoutClaimInput
      | ExtractedUnitUpsertWithWhereUniqueWithoutClaimInput[];
    createMany?: ExtractedUnitCreateManyClaimInputEnvelope;
    set?: ExtractedUnitWhereUniqueInput | ExtractedUnitWhereUniqueInput[];
    disconnect?:
      | ExtractedUnitWhereUniqueInput
      | ExtractedUnitWhereUniqueInput[];
    delete?: ExtractedUnitWhereUniqueInput | ExtractedUnitWhereUniqueInput[];
    connect?: ExtractedUnitWhereUniqueInput | ExtractedUnitWhereUniqueInput[];
    update?:
      | ExtractedUnitUpdateWithWhereUniqueWithoutClaimInput
      | ExtractedUnitUpdateWithWhereUniqueWithoutClaimInput[];
    updateMany?:
      | ExtractedUnitUpdateManyWithWhereWithoutClaimInput
      | ExtractedUnitUpdateManyWithWhereWithoutClaimInput[];
    deleteMany?:
      | ExtractedUnitScalarWhereInput
      | ExtractedUnitScalarWhereInput[];
  };

  export type FindingUncheckedUpdateOneWithoutClaimNestedInput = {
    create?: XOR<
      FindingCreateWithoutClaimInput,
      FindingUncheckedCreateWithoutClaimInput
    >;
    connectOrCreate?: FindingCreateOrConnectWithoutClaimInput;
    upsert?: FindingUpsertWithoutClaimInput;
    disconnect?: FindingWhereInput | boolean;
    delete?: FindingWhereInput | boolean;
    connect?: FindingWhereUniqueInput;
    update?: XOR<
      XOR<
        FindingUpdateToOneWithWhereWithoutClaimInput,
        FindingUpdateWithoutClaimInput
      >,
      FindingUncheckedUpdateWithoutClaimInput
    >;
  };

  export type FactcheckClaimCreateNestedOneWithoutProviderRunsInput = {
    create?: XOR<
      FactcheckClaimCreateWithoutProviderRunsInput,
      FactcheckClaimUncheckedCreateWithoutProviderRunsInput
    >;
    connectOrCreate?: FactcheckClaimCreateOrConnectWithoutProviderRunsInput;
    connect?: FactcheckClaimWhereUniqueInput;
  };

  export type FloatFieldUpdateOperationsInput = {
    set?: number;
    increment?: number;
    decrement?: number;
    multiply?: number;
    divide?: number;
  };

  export type FactcheckClaimUpdateOneRequiredWithoutProviderRunsNestedInput = {
    create?: XOR<
      FactcheckClaimCreateWithoutProviderRunsInput,
      FactcheckClaimUncheckedCreateWithoutProviderRunsInput
    >;
    connectOrCreate?: FactcheckClaimCreateOrConnectWithoutProviderRunsInput;
    upsert?: FactcheckClaimUpsertWithoutProviderRunsInput;
    connect?: FactcheckClaimWhereUniqueInput;
    update?: XOR<
      XOR<
        FactcheckClaimUpdateToOneWithWhereWithoutProviderRunsInput,
        FactcheckClaimUpdateWithoutProviderRunsInput
      >,
      FactcheckClaimUncheckedUpdateWithoutProviderRunsInput
    >;
  };

  export type FactcheckClaimCreateNestedOneWithoutConsensusInput = {
    create?: XOR<
      FactcheckClaimCreateWithoutConsensusInput,
      FactcheckClaimUncheckedCreateWithoutConsensusInput
    >;
    connectOrCreate?: FactcheckClaimCreateOrConnectWithoutConsensusInput;
    connect?: FactcheckClaimWhereUniqueInput;
  };

  export type FactcheckClaimUpdateOneRequiredWithoutConsensusNestedInput = {
    create?: XOR<
      FactcheckClaimCreateWithoutConsensusInput,
      FactcheckClaimUncheckedCreateWithoutConsensusInput
    >;
    connectOrCreate?: FactcheckClaimCreateOrConnectWithoutConsensusInput;
    upsert?: FactcheckClaimUpsertWithoutConsensusInput;
    connect?: FactcheckClaimWhereUniqueInput;
    update?: XOR<
      XOR<
        FactcheckClaimUpdateToOneWithWhereWithoutConsensusInput,
        FactcheckClaimUpdateWithoutConsensusInput
      >,
      FactcheckClaimUncheckedUpdateWithoutConsensusInput
    >;
  };

  export type FactcheckClaimCreateNestedOneWithoutEvidencesInput = {
    create?: XOR<
      FactcheckClaimCreateWithoutEvidencesInput,
      FactcheckClaimUncheckedCreateWithoutEvidencesInput
    >;
    connectOrCreate?: FactcheckClaimCreateOrConnectWithoutEvidencesInput;
    connect?: FactcheckClaimWhereUniqueInput;
  };

  export type EnumStanceFieldUpdateOperationsInput = {
    set?: $Enums.Stance;
  };

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null;
    increment?: number;
    decrement?: number;
    multiply?: number;
    divide?: number;
    unset?: boolean;
  };

  export type FactcheckClaimUpdateOneRequiredWithoutEvidencesNestedInput = {
    create?: XOR<
      FactcheckClaimCreateWithoutEvidencesInput,
      FactcheckClaimUncheckedCreateWithoutEvidencesInput
    >;
    connectOrCreate?: FactcheckClaimCreateOrConnectWithoutEvidencesInput;
    upsert?: FactcheckClaimUpsertWithoutEvidencesInput;
    connect?: FactcheckClaimWhereUniqueInput;
    update?: XOR<
      XOR<
        FactcheckClaimUpdateToOneWithWhereWithoutEvidencesInput,
        FactcheckClaimUpdateWithoutEvidencesInput
      >,
      FactcheckClaimUncheckedUpdateWithoutEvidencesInput
    >;
  };

  export type FactcheckClaimCreateNestedOneWithoutVerdictVersionsInput = {
    create?: XOR<
      FactcheckClaimCreateWithoutVerdictVersionsInput,
      FactcheckClaimUncheckedCreateWithoutVerdictVersionsInput
    >;
    connectOrCreate?: FactcheckClaimCreateOrConnectWithoutVerdictVersionsInput;
    connect?: FactcheckClaimWhereUniqueInput;
  };

  export type FactcheckClaimUpdateOneRequiredWithoutVerdictVersionsNestedInput =
    {
      create?: XOR<
        FactcheckClaimCreateWithoutVerdictVersionsInput,
        FactcheckClaimUncheckedCreateWithoutVerdictVersionsInput
      >;
      connectOrCreate?: FactcheckClaimCreateOrConnectWithoutVerdictVersionsInput;
      upsert?: FactcheckClaimUpsertWithoutVerdictVersionsInput;
      connect?: FactcheckClaimWhereUniqueInput;
      update?: XOR<
        XOR<
          FactcheckClaimUpdateToOneWithWhereWithoutVerdictVersionsInput,
          FactcheckClaimUpdateWithoutVerdictVersionsInput
        >,
        FactcheckClaimUncheckedUpdateWithoutVerdictVersionsInput
      >;
    };

  export type FactcheckJobCreateNestedOneWithoutResultsInput = {
    create?: XOR<
      FactcheckJobCreateWithoutResultsInput,
      FactcheckJobUncheckedCreateWithoutResultsInput
    >;
    connectOrCreate?: FactcheckJobCreateOrConnectWithoutResultsInput;
    connect?: FactcheckJobWhereUniqueInput;
  };

  export type FactcheckJobUpdateOneRequiredWithoutResultsNestedInput = {
    create?: XOR<
      FactcheckJobCreateWithoutResultsInput,
      FactcheckJobUncheckedCreateWithoutResultsInput
    >;
    connectOrCreate?: FactcheckJobCreateOrConnectWithoutResultsInput;
    upsert?: FactcheckJobUpsertWithoutResultsInput;
    connect?: FactcheckJobWhereUniqueInput;
    update?: XOR<
      XOR<
        FactcheckJobUpdateToOneWithWhereWithoutResultsInput,
        FactcheckJobUpdateWithoutResultsInput
      >,
      FactcheckJobUncheckedUpdateWithoutResultsInput
    >;
  };

  export type ContentItemCreateNestedOneWithoutUnitsInput = {
    create?: XOR<
      ContentItemCreateWithoutUnitsInput,
      ContentItemUncheckedCreateWithoutUnitsInput
    >;
    connectOrCreate?: ContentItemCreateOrConnectWithoutUnitsInput;
    connect?: ContentItemWhereUniqueInput;
  };

  export type FactcheckClaimCreateNestedOneWithoutUnitsInput = {
    create?: XOR<
      FactcheckClaimCreateWithoutUnitsInput,
      FactcheckClaimUncheckedCreateWithoutUnitsInput
    >;
    connectOrCreate?: FactcheckClaimCreateOrConnectWithoutUnitsInput;
    connect?: FactcheckClaimWhereUniqueInput;
  };

  export type EnumUnitKindFieldUpdateOperationsInput = {
    set?: $Enums.UnitKind;
  };

  export type EnumInterestFieldUpdateOperationsInput = {
    set?: $Enums.Interest;
  };

  export type EnumTriageFieldUpdateOperationsInput = {
    set?: $Enums.Triage;
  };

  export type ContentItemUpdateOneWithoutUnitsNestedInput = {
    create?: XOR<
      ContentItemCreateWithoutUnitsInput,
      ContentItemUncheckedCreateWithoutUnitsInput
    >;
    connectOrCreate?: ContentItemCreateOrConnectWithoutUnitsInput;
    upsert?: ContentItemUpsertWithoutUnitsInput;
    disconnect?: boolean;
    delete?: ContentItemWhereInput | boolean;
    connect?: ContentItemWhereUniqueInput;
    update?: XOR<
      XOR<
        ContentItemUpdateToOneWithWhereWithoutUnitsInput,
        ContentItemUpdateWithoutUnitsInput
      >,
      ContentItemUncheckedUpdateWithoutUnitsInput
    >;
  };

  export type FactcheckClaimUpdateOneWithoutUnitsNestedInput = {
    create?: XOR<
      FactcheckClaimCreateWithoutUnitsInput,
      FactcheckClaimUncheckedCreateWithoutUnitsInput
    >;
    connectOrCreate?: FactcheckClaimCreateOrConnectWithoutUnitsInput;
    upsert?: FactcheckClaimUpsertWithoutUnitsInput;
    disconnect?: boolean;
    delete?: FactcheckClaimWhereInput | boolean;
    connect?: FactcheckClaimWhereUniqueInput;
    update?: XOR<
      XOR<
        FactcheckClaimUpdateToOneWithWhereWithoutUnitsInput,
        FactcheckClaimUpdateWithoutUnitsInput
      >,
      FactcheckClaimUncheckedUpdateWithoutUnitsInput
    >;
  };

  export type FactcheckClaimCreateNestedOneWithoutFindingInput = {
    create?: XOR<
      FactcheckClaimCreateWithoutFindingInput,
      FactcheckClaimUncheckedCreateWithoutFindingInput
    >;
    connectOrCreate?: FactcheckClaimCreateOrConnectWithoutFindingInput;
    connect?: FactcheckClaimWhereUniqueInput;
  };

  export type FactcheckClaimUpdateOneRequiredWithoutFindingNestedInput = {
    create?: XOR<
      FactcheckClaimCreateWithoutFindingInput,
      FactcheckClaimUncheckedCreateWithoutFindingInput
    >;
    connectOrCreate?: FactcheckClaimCreateOrConnectWithoutFindingInput;
    upsert?: FactcheckClaimUpsertWithoutFindingInput;
    connect?: FactcheckClaimWhereUniqueInput;
    update?: XOR<
      XOR<
        FactcheckClaimUpdateToOneWithWhereWithoutFindingInput,
        FactcheckClaimUpdateWithoutFindingInput
      >,
      FactcheckClaimUncheckedUpdateWithoutFindingInput
    >;
  };

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    not?: NestedStringFilter<$PrismaModel> | string;
  };

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    not?: NestedStringNullableFilter<$PrismaModel> | string | null;
    isSet?: boolean;
  };

  export type NestedEnumLocaleFilter<$PrismaModel = never> = {
    equals?: $Enums.Locale | EnumLocaleFieldRefInput<$PrismaModel>;
    in?: $Enums.Locale[] | ListEnumLocaleFieldRefInput<$PrismaModel>;
    notIn?: $Enums.Locale[] | ListEnumLocaleFieldRefInput<$PrismaModel>;
    not?: NestedEnumLocaleFilter<$PrismaModel> | $Enums.Locale;
  };

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string;
  };

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedStringFilter<$PrismaModel>;
    _max?: NestedStringFilter<$PrismaModel>;
  };

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[] | ListIntFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntFilter<$PrismaModel> | number;
  };

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    not?:
      | NestedStringNullableWithAggregatesFilter<$PrismaModel>
      | string
      | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedStringNullableFilter<$PrismaModel>;
    _max?: NestedStringNullableFilter<$PrismaModel>;
    isSet?: boolean;
  };

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableFilter<$PrismaModel> | number | null;
    isSet?: boolean;
  };

  export type NestedEnumLocaleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Locale | EnumLocaleFieldRefInput<$PrismaModel>;
    in?: $Enums.Locale[] | ListEnumLocaleFieldRefInput<$PrismaModel>;
    notIn?: $Enums.Locale[] | ListEnumLocaleFieldRefInput<$PrismaModel>;
    not?: NestedEnumLocaleWithAggregatesFilter<$PrismaModel> | $Enums.Locale;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumLocaleFilter<$PrismaModel>;
    _max?: NestedEnumLocaleFilter<$PrismaModel>;
  };

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedDateTimeFilter<$PrismaModel>;
    _max?: NestedDateTimeFilter<$PrismaModel>;
  };

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[] | ListIntFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedFloatFilter<$PrismaModel>;
    _sum?: NestedIntFilter<$PrismaModel>;
    _min?: NestedIntFilter<$PrismaModel>;
    _max?: NestedIntFilter<$PrismaModel>;
  };

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatFilter<$PrismaModel> | number;
  };
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<
          Required<NestedJsonNullableFilterBase<$PrismaModel>>,
          Exclude<
            keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>,
            "path"
          >
        >,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<
        Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, "path">
      >;

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    isSet?: boolean;
  };

  export type NestedEnumContentKindFilter<$PrismaModel = never> = {
    equals?: $Enums.ContentKind | EnumContentKindFieldRefInput<$PrismaModel>;
    in?: $Enums.ContentKind[] | ListEnumContentKindFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.ContentKind[]
      | ListEnumContentKindFieldRefInput<$PrismaModel>;
    not?: NestedEnumContentKindFilter<$PrismaModel> | $Enums.ContentKind;
  };

  export type NestedEnumPublishStatusFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.PublishStatus
      | EnumPublishStatusFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.PublishStatus[]
      | ListEnumPublishStatusFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.PublishStatus[]
      | ListEnumPublishStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumPublishStatusFilter<$PrismaModel> | $Enums.PublishStatus;
  };

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null;
    isSet?: boolean;
  };

  export type NestedEnumRegionModeFilter<$PrismaModel = never> = {
    equals?: $Enums.RegionMode | EnumRegionModeFieldRefInput<$PrismaModel>;
    in?: $Enums.RegionMode[] | ListEnumRegionModeFieldRefInput<$PrismaModel>;
    notIn?: $Enums.RegionMode[] | ListEnumRegionModeFieldRefInput<$PrismaModel>;
    not?: NestedEnumRegionModeFilter<$PrismaModel> | $Enums.RegionMode;
  };

  export type NestedEnumContentKindWithAggregatesFilter<$PrismaModel = never> =
    {
      equals?: $Enums.ContentKind | EnumContentKindFieldRefInput<$PrismaModel>;
      in?:
        | $Enums.ContentKind[]
        | ListEnumContentKindFieldRefInput<$PrismaModel>;
      notIn?:
        | $Enums.ContentKind[]
        | ListEnumContentKindFieldRefInput<$PrismaModel>;
      not?:
        | NestedEnumContentKindWithAggregatesFilter<$PrismaModel>
        | $Enums.ContentKind;
      _count?: NestedIntFilter<$PrismaModel>;
      _min?: NestedEnumContentKindFilter<$PrismaModel>;
      _max?: NestedEnumContentKindFilter<$PrismaModel>;
    };

  export type NestedEnumPublishStatusWithAggregatesFilter<
    $PrismaModel = never,
  > = {
    equals?:
      | $Enums.PublishStatus
      | EnumPublishStatusFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.PublishStatus[]
      | ListEnumPublishStatusFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.PublishStatus[]
      | ListEnumPublishStatusFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumPublishStatusWithAggregatesFilter<$PrismaModel>
      | $Enums.PublishStatus;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumPublishStatusFilter<$PrismaModel>;
    _max?: NestedEnumPublishStatusFilter<$PrismaModel>;
  };

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> =
    {
      equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
      in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
      notIn?:
        | Date[]
        | string[]
        | ListDateTimeFieldRefInput<$PrismaModel>
        | null;
      lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
      lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
      gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
      gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
      not?:
        | NestedDateTimeNullableWithAggregatesFilter<$PrismaModel>
        | Date
        | string
        | null;
      _count?: NestedIntNullableFilter<$PrismaModel>;
      _min?: NestedDateTimeNullableFilter<$PrismaModel>;
      _max?: NestedDateTimeNullableFilter<$PrismaModel>;
      isSet?: boolean;
    };

  export type NestedEnumRegionModeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RegionMode | EnumRegionModeFieldRefInput<$PrismaModel>;
    in?: $Enums.RegionMode[] | ListEnumRegionModeFieldRefInput<$PrismaModel>;
    notIn?: $Enums.RegionMode[] | ListEnumRegionModeFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumRegionModeWithAggregatesFilter<$PrismaModel>
      | $Enums.RegionMode;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumRegionModeFilter<$PrismaModel>;
    _max?: NestedEnumRegionModeFilter<$PrismaModel>;
  };

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
    not?: NestedBoolFilter<$PrismaModel> | boolean;
  };

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedBoolFilter<$PrismaModel>;
    _max?: NestedBoolFilter<$PrismaModel>;
  };

  export type NestedEnumReviewStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ReviewStatus | EnumReviewStatusFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.ReviewStatus[]
      | ListEnumReviewStatusFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.ReviewStatus[]
      | ListEnumReviewStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumReviewStatusFilter<$PrismaModel> | $Enums.ReviewStatus;
  };

  export type NestedEnumReviewStatusWithAggregatesFilter<$PrismaModel = never> =
    {
      equals?:
        | $Enums.ReviewStatus
        | EnumReviewStatusFieldRefInput<$PrismaModel>;
      in?:
        | $Enums.ReviewStatus[]
        | ListEnumReviewStatusFieldRefInput<$PrismaModel>;
      notIn?:
        | $Enums.ReviewStatus[]
        | ListEnumReviewStatusFieldRefInput<$PrismaModel>;
      not?:
        | NestedEnumReviewStatusWithAggregatesFilter<$PrismaModel>
        | $Enums.ReviewStatus;
      _count?: NestedIntFilter<$PrismaModel>;
      _min?: NestedEnumReviewStatusFilter<$PrismaModel>;
      _max?: NestedEnumReviewStatusFilter<$PrismaModel>;
    };

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedFloatFilter<$PrismaModel>;
    _sum?: NestedFloatFilter<$PrismaModel>;
    _min?: NestedFloatFilter<$PrismaModel>;
    _max?: NestedFloatFilter<$PrismaModel>;
  };
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<
          Required<NestedJsonFilterBase<$PrismaModel>>,
          Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, "path">
        >,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, "path">>;

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
  };

  export type NestedEnumStanceFilter<$PrismaModel = never> = {
    equals?: $Enums.Stance | EnumStanceFieldRefInput<$PrismaModel>;
    in?: $Enums.Stance[] | ListEnumStanceFieldRefInput<$PrismaModel>;
    notIn?: $Enums.Stance[] | ListEnumStanceFieldRefInput<$PrismaModel>;
    not?: NestedEnumStanceFilter<$PrismaModel> | $Enums.Stance;
  };

  export type NestedEnumStanceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Stance | EnumStanceFieldRefInput<$PrismaModel>;
    in?: $Enums.Stance[] | ListEnumStanceFieldRefInput<$PrismaModel>;
    notIn?: $Enums.Stance[] | ListEnumStanceFieldRefInput<$PrismaModel>;
    not?: NestedEnumStanceWithAggregatesFilter<$PrismaModel> | $Enums.Stance;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumStanceFilter<$PrismaModel>;
    _max?: NestedEnumStanceFilter<$PrismaModel>;
  };

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _avg?: NestedFloatNullableFilter<$PrismaModel>;
    _sum?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedIntNullableFilter<$PrismaModel>;
    _max?: NestedIntNullableFilter<$PrismaModel>;
    isSet?: boolean;
  };

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null;
    isSet?: boolean;
  };

  export type NestedEnumUnitKindFilter<$PrismaModel = never> = {
    equals?: $Enums.UnitKind | EnumUnitKindFieldRefInput<$PrismaModel>;
    in?: $Enums.UnitKind[] | ListEnumUnitKindFieldRefInput<$PrismaModel>;
    notIn?: $Enums.UnitKind[] | ListEnumUnitKindFieldRefInput<$PrismaModel>;
    not?: NestedEnumUnitKindFilter<$PrismaModel> | $Enums.UnitKind;
  };

  export type NestedEnumInterestFilter<$PrismaModel = never> = {
    equals?: $Enums.Interest | EnumInterestFieldRefInput<$PrismaModel>;
    in?: $Enums.Interest[] | ListEnumInterestFieldRefInput<$PrismaModel>;
    notIn?: $Enums.Interest[] | ListEnumInterestFieldRefInput<$PrismaModel>;
    not?: NestedEnumInterestFilter<$PrismaModel> | $Enums.Interest;
  };

  export type NestedEnumTriageFilter<$PrismaModel = never> = {
    equals?: $Enums.Triage | EnumTriageFieldRefInput<$PrismaModel>;
    in?: $Enums.Triage[] | ListEnumTriageFieldRefInput<$PrismaModel>;
    notIn?: $Enums.Triage[] | ListEnumTriageFieldRefInput<$PrismaModel>;
    not?: NestedEnumTriageFilter<$PrismaModel> | $Enums.Triage;
  };

  export type NestedEnumUnitKindWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UnitKind | EnumUnitKindFieldRefInput<$PrismaModel>;
    in?: $Enums.UnitKind[] | ListEnumUnitKindFieldRefInput<$PrismaModel>;
    notIn?: $Enums.UnitKind[] | ListEnumUnitKindFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumUnitKindWithAggregatesFilter<$PrismaModel>
      | $Enums.UnitKind;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumUnitKindFilter<$PrismaModel>;
    _max?: NestedEnumUnitKindFilter<$PrismaModel>;
  };

  export type NestedEnumInterestWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Interest | EnumInterestFieldRefInput<$PrismaModel>;
    in?: $Enums.Interest[] | ListEnumInterestFieldRefInput<$PrismaModel>;
    notIn?: $Enums.Interest[] | ListEnumInterestFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumInterestWithAggregatesFilter<$PrismaModel>
      | $Enums.Interest;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumInterestFilter<$PrismaModel>;
    _max?: NestedEnumInterestFilter<$PrismaModel>;
  };

  export type NestedEnumTriageWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Triage | EnumTriageFieldRefInput<$PrismaModel>;
    in?: $Enums.Triage[] | ListEnumTriageFieldRefInput<$PrismaModel>;
    notIn?: $Enums.Triage[] | ListEnumTriageFieldRefInput<$PrismaModel>;
    not?: NestedEnumTriageWithAggregatesFilter<$PrismaModel> | $Enums.Triage;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumTriageFilter<$PrismaModel>;
    _max?: NestedEnumTriageFilter<$PrismaModel>;
  };

  export type ContentItemCreateWithoutTopicInput = {
    id?: string;
    kind: $Enums.ContentKind;
    locale?: $Enums.Locale;
    title?: string | null;
    text: string;
    richText?: string | null;
    sortOrder?: number;
    status?: $Enums.PublishStatus;
    authorName?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    publishAt?: Date | string | null;
    expireAt?: Date | string | null;
    regionMode?: $Enums.RegionMode;
    regionAuto?: InputJsonValue | null;
    validation?: InputJsonValue | null;
    meta?: InputJsonValue | null;
    units?: ExtractedUnitCreateNestedManyWithoutItemInput;
    regionManual?: RegionCreateNestedOneWithoutItemsManualInput;
    regionEffective?: RegionCreateNestedOneWithoutItemsEffectiveInput;
    answerOptions?: AnswerOptionCreateNestedManyWithoutItemInput;
    tags?: ItemTagCreateNestedManyWithoutItemInput;
  };

  export type ContentItemUncheckedCreateWithoutTopicInput = {
    id?: string;
    kind: $Enums.ContentKind;
    locale?: $Enums.Locale;
    title?: string | null;
    text: string;
    richText?: string | null;
    sortOrder?: number;
    status?: $Enums.PublishStatus;
    authorName?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    publishAt?: Date | string | null;
    expireAt?: Date | string | null;
    regionMode?: $Enums.RegionMode;
    regionManualId?: string | null;
    regionAuto?: InputJsonValue | null;
    regionEffectiveId?: string | null;
    validation?: InputJsonValue | null;
    meta?: InputJsonValue | null;
    units?: ExtractedUnitUncheckedCreateNestedManyWithoutItemInput;
    answerOptions?: AnswerOptionUncheckedCreateNestedManyWithoutItemInput;
    tags?: ItemTagUncheckedCreateNestedManyWithoutItemInput;
  };

  export type ContentItemCreateOrConnectWithoutTopicInput = {
    where: ContentItemWhereUniqueInput;
    create: XOR<
      ContentItemCreateWithoutTopicInput,
      ContentItemUncheckedCreateWithoutTopicInput
    >;
  };

  export type ContentItemCreateManyTopicInputEnvelope = {
    data: ContentItemCreateManyTopicInput | ContentItemCreateManyTopicInput[];
  };

  export type TopicTagCreateWithoutTopicInput = {
    id?: string;
    tag: TagCreateNestedOneWithoutTopicsInput;
  };

  export type TopicTagUncheckedCreateWithoutTopicInput = {
    id?: string;
    tagId: string;
  };

  export type TopicTagCreateOrConnectWithoutTopicInput = {
    where: TopicTagWhereUniqueInput;
    create: XOR<
      TopicTagCreateWithoutTopicInput,
      TopicTagUncheckedCreateWithoutTopicInput
    >;
  };

  export type TopicTagCreateManyTopicInputEnvelope = {
    data: TopicTagCreateManyTopicInput | TopicTagCreateManyTopicInput[];
  };

  export type ContentItemUpsertWithWhereUniqueWithoutTopicInput = {
    where: ContentItemWhereUniqueInput;
    update: XOR<
      ContentItemUpdateWithoutTopicInput,
      ContentItemUncheckedUpdateWithoutTopicInput
    >;
    create: XOR<
      ContentItemCreateWithoutTopicInput,
      ContentItemUncheckedCreateWithoutTopicInput
    >;
  };

  export type ContentItemUpdateWithWhereUniqueWithoutTopicInput = {
    where: ContentItemWhereUniqueInput;
    data: XOR<
      ContentItemUpdateWithoutTopicInput,
      ContentItemUncheckedUpdateWithoutTopicInput
    >;
  };

  export type ContentItemUpdateManyWithWhereWithoutTopicInput = {
    where: ContentItemScalarWhereInput;
    data: XOR<
      ContentItemUpdateManyMutationInput,
      ContentItemUncheckedUpdateManyWithoutTopicInput
    >;
  };

  export type ContentItemScalarWhereInput = {
    AND?: ContentItemScalarWhereInput | ContentItemScalarWhereInput[];
    OR?: ContentItemScalarWhereInput[];
    NOT?: ContentItemScalarWhereInput | ContentItemScalarWhereInput[];
    id?: StringFilter<"ContentItem"> | string;
    kind?: EnumContentKindFilter<"ContentItem"> | $Enums.ContentKind;
    topicId?: StringFilter<"ContentItem"> | string;
    locale?: EnumLocaleFilter<"ContentItem"> | $Enums.Locale;
    title?: StringNullableFilter<"ContentItem"> | string | null;
    text?: StringFilter<"ContentItem"> | string;
    richText?: StringNullableFilter<"ContentItem"> | string | null;
    sortOrder?: IntFilter<"ContentItem"> | number;
    status?: EnumPublishStatusFilter<"ContentItem"> | $Enums.PublishStatus;
    authorName?: StringNullableFilter<"ContentItem"> | string | null;
    createdAt?: DateTimeFilter<"ContentItem"> | Date | string;
    updatedAt?: DateTimeFilter<"ContentItem"> | Date | string;
    publishAt?: DateTimeNullableFilter<"ContentItem"> | Date | string | null;
    expireAt?: DateTimeNullableFilter<"ContentItem"> | Date | string | null;
    regionMode?: EnumRegionModeFilter<"ContentItem"> | $Enums.RegionMode;
    regionManualId?: StringNullableFilter<"ContentItem"> | string | null;
    regionAuto?: JsonNullableFilter<"ContentItem">;
    regionEffectiveId?: StringNullableFilter<"ContentItem"> | string | null;
    validation?: JsonNullableFilter<"ContentItem">;
    meta?: JsonNullableFilter<"ContentItem">;
  };

  export type TopicTagUpsertWithWhereUniqueWithoutTopicInput = {
    where: TopicTagWhereUniqueInput;
    update: XOR<
      TopicTagUpdateWithoutTopicInput,
      TopicTagUncheckedUpdateWithoutTopicInput
    >;
    create: XOR<
      TopicTagCreateWithoutTopicInput,
      TopicTagUncheckedCreateWithoutTopicInput
    >;
  };

  export type TopicTagUpdateWithWhereUniqueWithoutTopicInput = {
    where: TopicTagWhereUniqueInput;
    data: XOR<
      TopicTagUpdateWithoutTopicInput,
      TopicTagUncheckedUpdateWithoutTopicInput
    >;
  };

  export type TopicTagUpdateManyWithWhereWithoutTopicInput = {
    where: TopicTagScalarWhereInput;
    data: XOR<
      TopicTagUpdateManyMutationInput,
      TopicTagUncheckedUpdateManyWithoutTopicInput
    >;
  };

  export type TopicTagScalarWhereInput = {
    AND?: TopicTagScalarWhereInput | TopicTagScalarWhereInput[];
    OR?: TopicTagScalarWhereInput[];
    NOT?: TopicTagScalarWhereInput | TopicTagScalarWhereInput[];
    id?: StringFilter<"TopicTag"> | string;
    topicId?: StringFilter<"TopicTag"> | string;
    tagId?: StringFilter<"TopicTag"> | string;
  };

  export type TopicTagCreateWithoutTagInput = {
    id?: string;
    topic: TopicCreateNestedOneWithoutTagsInput;
  };

  export type TopicTagUncheckedCreateWithoutTagInput = {
    id?: string;
    topicId: string;
  };

  export type TopicTagCreateOrConnectWithoutTagInput = {
    where: TopicTagWhereUniqueInput;
    create: XOR<
      TopicTagCreateWithoutTagInput,
      TopicTagUncheckedCreateWithoutTagInput
    >;
  };

  export type TopicTagCreateManyTagInputEnvelope = {
    data: TopicTagCreateManyTagInput | TopicTagCreateManyTagInput[];
  };

  export type ItemTagCreateWithoutTagInput = {
    id?: string;
    item: ContentItemCreateNestedOneWithoutTagsInput;
  };

  export type ItemTagUncheckedCreateWithoutTagInput = {
    id?: string;
    itemId: string;
  };

  export type ItemTagCreateOrConnectWithoutTagInput = {
    where: ItemTagWhereUniqueInput;
    create: XOR<
      ItemTagCreateWithoutTagInput,
      ItemTagUncheckedCreateWithoutTagInput
    >;
  };

  export type ItemTagCreateManyTagInputEnvelope = {
    data: ItemTagCreateManyTagInput | ItemTagCreateManyTagInput[];
  };

  export type TopicTagUpsertWithWhereUniqueWithoutTagInput = {
    where: TopicTagWhereUniqueInput;
    update: XOR<
      TopicTagUpdateWithoutTagInput,
      TopicTagUncheckedUpdateWithoutTagInput
    >;
    create: XOR<
      TopicTagCreateWithoutTagInput,
      TopicTagUncheckedCreateWithoutTagInput
    >;
  };

  export type TopicTagUpdateWithWhereUniqueWithoutTagInput = {
    where: TopicTagWhereUniqueInput;
    data: XOR<
      TopicTagUpdateWithoutTagInput,
      TopicTagUncheckedUpdateWithoutTagInput
    >;
  };

  export type TopicTagUpdateManyWithWhereWithoutTagInput = {
    where: TopicTagScalarWhereInput;
    data: XOR<
      TopicTagUpdateManyMutationInput,
      TopicTagUncheckedUpdateManyWithoutTagInput
    >;
  };

  export type ItemTagUpsertWithWhereUniqueWithoutTagInput = {
    where: ItemTagWhereUniqueInput;
    update: XOR<
      ItemTagUpdateWithoutTagInput,
      ItemTagUncheckedUpdateWithoutTagInput
    >;
    create: XOR<
      ItemTagCreateWithoutTagInput,
      ItemTagUncheckedCreateWithoutTagInput
    >;
  };

  export type ItemTagUpdateWithWhereUniqueWithoutTagInput = {
    where: ItemTagWhereUniqueInput;
    data: XOR<
      ItemTagUpdateWithoutTagInput,
      ItemTagUncheckedUpdateWithoutTagInput
    >;
  };

  export type ItemTagUpdateManyWithWhereWithoutTagInput = {
    where: ItemTagScalarWhereInput;
    data: XOR<
      ItemTagUpdateManyMutationInput,
      ItemTagUncheckedUpdateManyWithoutTagInput
    >;
  };

  export type ItemTagScalarWhereInput = {
    AND?: ItemTagScalarWhereInput | ItemTagScalarWhereInput[];
    OR?: ItemTagScalarWhereInput[];
    NOT?: ItemTagScalarWhereInput | ItemTagScalarWhereInput[];
    id?: StringFilter<"ItemTag"> | string;
    itemId?: StringFilter<"ItemTag"> | string;
    tagId?: StringFilter<"ItemTag"> | string;
  };

  export type TopicCreateWithoutTagsInput = {
    id?: string;
    slug: string;
    title: string;
    description?: string | null;
    locale?: $Enums.Locale;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    items?: ContentItemCreateNestedManyWithoutTopicInput;
  };

  export type TopicUncheckedCreateWithoutTagsInput = {
    id?: string;
    slug: string;
    title: string;
    description?: string | null;
    locale?: $Enums.Locale;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    items?: ContentItemUncheckedCreateNestedManyWithoutTopicInput;
  };

  export type TopicCreateOrConnectWithoutTagsInput = {
    where: TopicWhereUniqueInput;
    create: XOR<
      TopicCreateWithoutTagsInput,
      TopicUncheckedCreateWithoutTagsInput
    >;
  };

  export type TagCreateWithoutTopicsInput = {
    id?: string;
    slug: string;
    label: string;
    items?: ItemTagCreateNestedManyWithoutTagInput;
  };

  export type TagUncheckedCreateWithoutTopicsInput = {
    id?: string;
    slug: string;
    label: string;
    items?: ItemTagUncheckedCreateNestedManyWithoutTagInput;
  };

  export type TagCreateOrConnectWithoutTopicsInput = {
    where: TagWhereUniqueInput;
    create: XOR<
      TagCreateWithoutTopicsInput,
      TagUncheckedCreateWithoutTopicsInput
    >;
  };

  export type TopicUpsertWithoutTagsInput = {
    update: XOR<
      TopicUpdateWithoutTagsInput,
      TopicUncheckedUpdateWithoutTagsInput
    >;
    create: XOR<
      TopicCreateWithoutTagsInput,
      TopicUncheckedCreateWithoutTagsInput
    >;
    where?: TopicWhereInput;
  };

  export type TopicUpdateToOneWithWhereWithoutTagsInput = {
    where?: TopicWhereInput;
    data: XOR<
      TopicUpdateWithoutTagsInput,
      TopicUncheckedUpdateWithoutTagsInput
    >;
  };

  export type TopicUpdateWithoutTagsInput = {
    slug?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    locale?: EnumLocaleFieldUpdateOperationsInput | $Enums.Locale;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    items?: ContentItemUpdateManyWithoutTopicNestedInput;
  };

  export type TopicUncheckedUpdateWithoutTagsInput = {
    slug?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    locale?: EnumLocaleFieldUpdateOperationsInput | $Enums.Locale;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    items?: ContentItemUncheckedUpdateManyWithoutTopicNestedInput;
  };

  export type TagUpsertWithoutTopicsInput = {
    update: XOR<
      TagUpdateWithoutTopicsInput,
      TagUncheckedUpdateWithoutTopicsInput
    >;
    create: XOR<
      TagCreateWithoutTopicsInput,
      TagUncheckedCreateWithoutTopicsInput
    >;
    where?: TagWhereInput;
  };

  export type TagUpdateToOneWithWhereWithoutTopicsInput = {
    where?: TagWhereInput;
    data: XOR<
      TagUpdateWithoutTopicsInput,
      TagUncheckedUpdateWithoutTopicsInput
    >;
  };

  export type TagUpdateWithoutTopicsInput = {
    slug?: StringFieldUpdateOperationsInput | string;
    label?: StringFieldUpdateOperationsInput | string;
    items?: ItemTagUpdateManyWithoutTagNestedInput;
  };

  export type TagUncheckedUpdateWithoutTopicsInput = {
    slug?: StringFieldUpdateOperationsInput | string;
    label?: StringFieldUpdateOperationsInput | string;
    items?: ItemTagUncheckedUpdateManyWithoutTagNestedInput;
  };

  export type ContentItemCreateWithoutTagsInput = {
    id?: string;
    kind: $Enums.ContentKind;
    locale?: $Enums.Locale;
    title?: string | null;
    text: string;
    richText?: string | null;
    sortOrder?: number;
    status?: $Enums.PublishStatus;
    authorName?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    publishAt?: Date | string | null;
    expireAt?: Date | string | null;
    regionMode?: $Enums.RegionMode;
    regionAuto?: InputJsonValue | null;
    validation?: InputJsonValue | null;
    meta?: InputJsonValue | null;
    topic: TopicCreateNestedOneWithoutItemsInput;
    units?: ExtractedUnitCreateNestedManyWithoutItemInput;
    regionManual?: RegionCreateNestedOneWithoutItemsManualInput;
    regionEffective?: RegionCreateNestedOneWithoutItemsEffectiveInput;
    answerOptions?: AnswerOptionCreateNestedManyWithoutItemInput;
  };

  export type ContentItemUncheckedCreateWithoutTagsInput = {
    id?: string;
    kind: $Enums.ContentKind;
    topicId: string;
    locale?: $Enums.Locale;
    title?: string | null;
    text: string;
    richText?: string | null;
    sortOrder?: number;
    status?: $Enums.PublishStatus;
    authorName?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    publishAt?: Date | string | null;
    expireAt?: Date | string | null;
    regionMode?: $Enums.RegionMode;
    regionManualId?: string | null;
    regionAuto?: InputJsonValue | null;
    regionEffectiveId?: string | null;
    validation?: InputJsonValue | null;
    meta?: InputJsonValue | null;
    units?: ExtractedUnitUncheckedCreateNestedManyWithoutItemInput;
    answerOptions?: AnswerOptionUncheckedCreateNestedManyWithoutItemInput;
  };

  export type ContentItemCreateOrConnectWithoutTagsInput = {
    where: ContentItemWhereUniqueInput;
    create: XOR<
      ContentItemCreateWithoutTagsInput,
      ContentItemUncheckedCreateWithoutTagsInput
    >;
  };

  export type TagCreateWithoutItemsInput = {
    id?: string;
    slug: string;
    label: string;
    topics?: TopicTagCreateNestedManyWithoutTagInput;
  };

  export type TagUncheckedCreateWithoutItemsInput = {
    id?: string;
    slug: string;
    label: string;
    topics?: TopicTagUncheckedCreateNestedManyWithoutTagInput;
  };

  export type TagCreateOrConnectWithoutItemsInput = {
    where: TagWhereUniqueInput;
    create: XOR<
      TagCreateWithoutItemsInput,
      TagUncheckedCreateWithoutItemsInput
    >;
  };

  export type ContentItemUpsertWithoutTagsInput = {
    update: XOR<
      ContentItemUpdateWithoutTagsInput,
      ContentItemUncheckedUpdateWithoutTagsInput
    >;
    create: XOR<
      ContentItemCreateWithoutTagsInput,
      ContentItemUncheckedCreateWithoutTagsInput
    >;
    where?: ContentItemWhereInput;
  };

  export type ContentItemUpdateToOneWithWhereWithoutTagsInput = {
    where?: ContentItemWhereInput;
    data: XOR<
      ContentItemUpdateWithoutTagsInput,
      ContentItemUncheckedUpdateWithoutTagsInput
    >;
  };

  export type ContentItemUpdateWithoutTagsInput = {
    kind?: EnumContentKindFieldUpdateOperationsInput | $Enums.ContentKind;
    locale?: EnumLocaleFieldUpdateOperationsInput | $Enums.Locale;
    title?: NullableStringFieldUpdateOperationsInput | string | null;
    text?: StringFieldUpdateOperationsInput | string;
    richText?: NullableStringFieldUpdateOperationsInput | string | null;
    sortOrder?: IntFieldUpdateOperationsInput | number;
    status?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus;
    authorName?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    publishAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    expireAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    regionMode?: EnumRegionModeFieldUpdateOperationsInput | $Enums.RegionMode;
    regionAuto?: InputJsonValue | InputJsonValue | null;
    validation?: InputJsonValue | InputJsonValue | null;
    meta?: InputJsonValue | InputJsonValue | null;
    topic?: TopicUpdateOneRequiredWithoutItemsNestedInput;
    units?: ExtractedUnitUpdateManyWithoutItemNestedInput;
    regionManual?: RegionUpdateOneWithoutItemsManualNestedInput;
    regionEffective?: RegionUpdateOneWithoutItemsEffectiveNestedInput;
    answerOptions?: AnswerOptionUpdateManyWithoutItemNestedInput;
  };

  export type ContentItemUncheckedUpdateWithoutTagsInput = {
    kind?: EnumContentKindFieldUpdateOperationsInput | $Enums.ContentKind;
    topicId?: StringFieldUpdateOperationsInput | string;
    locale?: EnumLocaleFieldUpdateOperationsInput | $Enums.Locale;
    title?: NullableStringFieldUpdateOperationsInput | string | null;
    text?: StringFieldUpdateOperationsInput | string;
    richText?: NullableStringFieldUpdateOperationsInput | string | null;
    sortOrder?: IntFieldUpdateOperationsInput | number;
    status?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus;
    authorName?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    publishAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    expireAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    regionMode?: EnumRegionModeFieldUpdateOperationsInput | $Enums.RegionMode;
    regionManualId?: NullableStringFieldUpdateOperationsInput | string | null;
    regionAuto?: InputJsonValue | InputJsonValue | null;
    regionEffectiveId?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    validation?: InputJsonValue | InputJsonValue | null;
    meta?: InputJsonValue | InputJsonValue | null;
    units?: ExtractedUnitUncheckedUpdateManyWithoutItemNestedInput;
    answerOptions?: AnswerOptionUncheckedUpdateManyWithoutItemNestedInput;
  };

  export type TagUpsertWithoutItemsInput = {
    update: XOR<
      TagUpdateWithoutItemsInput,
      TagUncheckedUpdateWithoutItemsInput
    >;
    create: XOR<
      TagCreateWithoutItemsInput,
      TagUncheckedCreateWithoutItemsInput
    >;
    where?: TagWhereInput;
  };

  export type TagUpdateToOneWithWhereWithoutItemsInput = {
    where?: TagWhereInput;
    data: XOR<TagUpdateWithoutItemsInput, TagUncheckedUpdateWithoutItemsInput>;
  };

  export type TagUpdateWithoutItemsInput = {
    slug?: StringFieldUpdateOperationsInput | string;
    label?: StringFieldUpdateOperationsInput | string;
    topics?: TopicTagUpdateManyWithoutTagNestedInput;
  };

  export type TagUncheckedUpdateWithoutItemsInput = {
    slug?: StringFieldUpdateOperationsInput | string;
    label?: StringFieldUpdateOperationsInput | string;
    topics?: TopicTagUncheckedUpdateManyWithoutTagNestedInput;
  };

  export type RegionCreateWithoutChildrenInput = {
    id?: string;
    code: string;
    name: string;
    level: number;
    meta?: InputJsonValue | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    parent?: RegionCreateNestedOneWithoutChildrenInput;
    itemsManual?: ContentItemCreateNestedManyWithoutRegionManualInput;
    itemsEffective?: ContentItemCreateNestedManyWithoutRegionEffectiveInput;
    ancestors?: RegionClosureCreateNestedManyWithoutAncestorInput;
    descendants?: RegionClosureCreateNestedManyWithoutDescendantInput;
  };

  export type RegionUncheckedCreateWithoutChildrenInput = {
    id?: string;
    code: string;
    name: string;
    level: number;
    parentId?: string | null;
    meta?: InputJsonValue | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    itemsManual?: ContentItemUncheckedCreateNestedManyWithoutRegionManualInput;
    itemsEffective?: ContentItemUncheckedCreateNestedManyWithoutRegionEffectiveInput;
    ancestors?: RegionClosureUncheckedCreateNestedManyWithoutAncestorInput;
    descendants?: RegionClosureUncheckedCreateNestedManyWithoutDescendantInput;
  };

  export type RegionCreateOrConnectWithoutChildrenInput = {
    where: RegionWhereUniqueInput;
    create: XOR<
      RegionCreateWithoutChildrenInput,
      RegionUncheckedCreateWithoutChildrenInput
    >;
  };

  export type RegionCreateWithoutParentInput = {
    id?: string;
    code: string;
    name: string;
    level: number;
    meta?: InputJsonValue | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    children?: RegionCreateNestedManyWithoutParentInput;
    itemsManual?: ContentItemCreateNestedManyWithoutRegionManualInput;
    itemsEffective?: ContentItemCreateNestedManyWithoutRegionEffectiveInput;
    ancestors?: RegionClosureCreateNestedManyWithoutAncestorInput;
    descendants?: RegionClosureCreateNestedManyWithoutDescendantInput;
  };

  export type RegionUncheckedCreateWithoutParentInput = {
    id?: string;
    code: string;
    name: string;
    level: number;
    meta?: InputJsonValue | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    children?: RegionUncheckedCreateNestedManyWithoutParentInput;
    itemsManual?: ContentItemUncheckedCreateNestedManyWithoutRegionManualInput;
    itemsEffective?: ContentItemUncheckedCreateNestedManyWithoutRegionEffectiveInput;
    ancestors?: RegionClosureUncheckedCreateNestedManyWithoutAncestorInput;
    descendants?: RegionClosureUncheckedCreateNestedManyWithoutDescendantInput;
  };

  export type RegionCreateOrConnectWithoutParentInput = {
    where: RegionWhereUniqueInput;
    create: XOR<
      RegionCreateWithoutParentInput,
      RegionUncheckedCreateWithoutParentInput
    >;
  };

  export type RegionCreateManyParentInputEnvelope = {
    data: RegionCreateManyParentInput | RegionCreateManyParentInput[];
  };

  export type ContentItemCreateWithoutRegionManualInput = {
    id?: string;
    kind: $Enums.ContentKind;
    locale?: $Enums.Locale;
    title?: string | null;
    text: string;
    richText?: string | null;
    sortOrder?: number;
    status?: $Enums.PublishStatus;
    authorName?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    publishAt?: Date | string | null;
    expireAt?: Date | string | null;
    regionMode?: $Enums.RegionMode;
    regionAuto?: InputJsonValue | null;
    validation?: InputJsonValue | null;
    meta?: InputJsonValue | null;
    topic: TopicCreateNestedOneWithoutItemsInput;
    units?: ExtractedUnitCreateNestedManyWithoutItemInput;
    regionEffective?: RegionCreateNestedOneWithoutItemsEffectiveInput;
    answerOptions?: AnswerOptionCreateNestedManyWithoutItemInput;
    tags?: ItemTagCreateNestedManyWithoutItemInput;
  };

  export type ContentItemUncheckedCreateWithoutRegionManualInput = {
    id?: string;
    kind: $Enums.ContentKind;
    topicId: string;
    locale?: $Enums.Locale;
    title?: string | null;
    text: string;
    richText?: string | null;
    sortOrder?: number;
    status?: $Enums.PublishStatus;
    authorName?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    publishAt?: Date | string | null;
    expireAt?: Date | string | null;
    regionMode?: $Enums.RegionMode;
    regionAuto?: InputJsonValue | null;
    regionEffectiveId?: string | null;
    validation?: InputJsonValue | null;
    meta?: InputJsonValue | null;
    units?: ExtractedUnitUncheckedCreateNestedManyWithoutItemInput;
    answerOptions?: AnswerOptionUncheckedCreateNestedManyWithoutItemInput;
    tags?: ItemTagUncheckedCreateNestedManyWithoutItemInput;
  };

  export type ContentItemCreateOrConnectWithoutRegionManualInput = {
    where: ContentItemWhereUniqueInput;
    create: XOR<
      ContentItemCreateWithoutRegionManualInput,
      ContentItemUncheckedCreateWithoutRegionManualInput
    >;
  };

  export type ContentItemCreateManyRegionManualInputEnvelope = {
    data:
      | ContentItemCreateManyRegionManualInput
      | ContentItemCreateManyRegionManualInput[];
  };

  export type ContentItemCreateWithoutRegionEffectiveInput = {
    id?: string;
    kind: $Enums.ContentKind;
    locale?: $Enums.Locale;
    title?: string | null;
    text: string;
    richText?: string | null;
    sortOrder?: number;
    status?: $Enums.PublishStatus;
    authorName?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    publishAt?: Date | string | null;
    expireAt?: Date | string | null;
    regionMode?: $Enums.RegionMode;
    regionAuto?: InputJsonValue | null;
    validation?: InputJsonValue | null;
    meta?: InputJsonValue | null;
    topic: TopicCreateNestedOneWithoutItemsInput;
    units?: ExtractedUnitCreateNestedManyWithoutItemInput;
    regionManual?: RegionCreateNestedOneWithoutItemsManualInput;
    answerOptions?: AnswerOptionCreateNestedManyWithoutItemInput;
    tags?: ItemTagCreateNestedManyWithoutItemInput;
  };

  export type ContentItemUncheckedCreateWithoutRegionEffectiveInput = {
    id?: string;
    kind: $Enums.ContentKind;
    topicId: string;
    locale?: $Enums.Locale;
    title?: string | null;
    text: string;
    richText?: string | null;
    sortOrder?: number;
    status?: $Enums.PublishStatus;
    authorName?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    publishAt?: Date | string | null;
    expireAt?: Date | string | null;
    regionMode?: $Enums.RegionMode;
    regionManualId?: string | null;
    regionAuto?: InputJsonValue | null;
    validation?: InputJsonValue | null;
    meta?: InputJsonValue | null;
    units?: ExtractedUnitUncheckedCreateNestedManyWithoutItemInput;
    answerOptions?: AnswerOptionUncheckedCreateNestedManyWithoutItemInput;
    tags?: ItemTagUncheckedCreateNestedManyWithoutItemInput;
  };

  export type ContentItemCreateOrConnectWithoutRegionEffectiveInput = {
    where: ContentItemWhereUniqueInput;
    create: XOR<
      ContentItemCreateWithoutRegionEffectiveInput,
      ContentItemUncheckedCreateWithoutRegionEffectiveInput
    >;
  };

  export type ContentItemCreateManyRegionEffectiveInputEnvelope = {
    data:
      | ContentItemCreateManyRegionEffectiveInput
      | ContentItemCreateManyRegionEffectiveInput[];
  };

  export type RegionClosureCreateWithoutAncestorInput = {
    id?: string;
    depth: number;
    descendant: RegionCreateNestedOneWithoutDescendantsInput;
  };

  export type RegionClosureUncheckedCreateWithoutAncestorInput = {
    id?: string;
    descendantId: string;
    depth: number;
  };

  export type RegionClosureCreateOrConnectWithoutAncestorInput = {
    where: RegionClosureWhereUniqueInput;
    create: XOR<
      RegionClosureCreateWithoutAncestorInput,
      RegionClosureUncheckedCreateWithoutAncestorInput
    >;
  };

  export type RegionClosureCreateManyAncestorInputEnvelope = {
    data:
      | RegionClosureCreateManyAncestorInput
      | RegionClosureCreateManyAncestorInput[];
  };

  export type RegionClosureCreateWithoutDescendantInput = {
    id?: string;
    depth: number;
    ancestor: RegionCreateNestedOneWithoutAncestorsInput;
  };

  export type RegionClosureUncheckedCreateWithoutDescendantInput = {
    id?: string;
    ancestorId: string;
    depth: number;
  };

  export type RegionClosureCreateOrConnectWithoutDescendantInput = {
    where: RegionClosureWhereUniqueInput;
    create: XOR<
      RegionClosureCreateWithoutDescendantInput,
      RegionClosureUncheckedCreateWithoutDescendantInput
    >;
  };

  export type RegionClosureCreateManyDescendantInputEnvelope = {
    data:
      | RegionClosureCreateManyDescendantInput
      | RegionClosureCreateManyDescendantInput[];
  };

  export type RegionUpsertWithoutChildrenInput = {
    update: XOR<
      RegionUpdateWithoutChildrenInput,
      RegionUncheckedUpdateWithoutChildrenInput
    >;
    create: XOR<
      RegionCreateWithoutChildrenInput,
      RegionUncheckedCreateWithoutChildrenInput
    >;
    where?: RegionWhereInput;
  };

  export type RegionUpdateToOneWithWhereWithoutChildrenInput = {
    where?: RegionWhereInput;
    data: XOR<
      RegionUpdateWithoutChildrenInput,
      RegionUncheckedUpdateWithoutChildrenInput
    >;
  };

  export type RegionUpdateWithoutChildrenInput = {
    code?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    level?: IntFieldUpdateOperationsInput | number;
    meta?: InputJsonValue | InputJsonValue | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    parent?: RegionUpdateOneWithoutChildrenNestedInput;
    itemsManual?: ContentItemUpdateManyWithoutRegionManualNestedInput;
    itemsEffective?: ContentItemUpdateManyWithoutRegionEffectiveNestedInput;
    ancestors?: RegionClosureUpdateManyWithoutAncestorNestedInput;
    descendants?: RegionClosureUpdateManyWithoutDescendantNestedInput;
  };

  export type RegionUncheckedUpdateWithoutChildrenInput = {
    code?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    level?: IntFieldUpdateOperationsInput | number;
    parentId?: NullableStringFieldUpdateOperationsInput | string | null;
    meta?: InputJsonValue | InputJsonValue | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    itemsManual?: ContentItemUncheckedUpdateManyWithoutRegionManualNestedInput;
    itemsEffective?: ContentItemUncheckedUpdateManyWithoutRegionEffectiveNestedInput;
    ancestors?: RegionClosureUncheckedUpdateManyWithoutAncestorNestedInput;
    descendants?: RegionClosureUncheckedUpdateManyWithoutDescendantNestedInput;
  };

  export type RegionUpsertWithWhereUniqueWithoutParentInput = {
    where: RegionWhereUniqueInput;
    update: XOR<
      RegionUpdateWithoutParentInput,
      RegionUncheckedUpdateWithoutParentInput
    >;
    create: XOR<
      RegionCreateWithoutParentInput,
      RegionUncheckedCreateWithoutParentInput
    >;
  };

  export type RegionUpdateWithWhereUniqueWithoutParentInput = {
    where: RegionWhereUniqueInput;
    data: XOR<
      RegionUpdateWithoutParentInput,
      RegionUncheckedUpdateWithoutParentInput
    >;
  };

  export type RegionUpdateManyWithWhereWithoutParentInput = {
    where: RegionScalarWhereInput;
    data: XOR<
      RegionUpdateManyMutationInput,
      RegionUncheckedUpdateManyWithoutParentInput
    >;
  };

  export type RegionScalarWhereInput = {
    AND?: RegionScalarWhereInput | RegionScalarWhereInput[];
    OR?: RegionScalarWhereInput[];
    NOT?: RegionScalarWhereInput | RegionScalarWhereInput[];
    id?: StringFilter<"Region"> | string;
    code?: StringFilter<"Region"> | string;
    name?: StringFilter<"Region"> | string;
    level?: IntFilter<"Region"> | number;
    parentId?: StringNullableFilter<"Region"> | string | null;
    meta?: JsonNullableFilter<"Region">;
    createdAt?: DateTimeFilter<"Region"> | Date | string;
    updatedAt?: DateTimeFilter<"Region"> | Date | string;
  };

  export type ContentItemUpsertWithWhereUniqueWithoutRegionManualInput = {
    where: ContentItemWhereUniqueInput;
    update: XOR<
      ContentItemUpdateWithoutRegionManualInput,
      ContentItemUncheckedUpdateWithoutRegionManualInput
    >;
    create: XOR<
      ContentItemCreateWithoutRegionManualInput,
      ContentItemUncheckedCreateWithoutRegionManualInput
    >;
  };

  export type ContentItemUpdateWithWhereUniqueWithoutRegionManualInput = {
    where: ContentItemWhereUniqueInput;
    data: XOR<
      ContentItemUpdateWithoutRegionManualInput,
      ContentItemUncheckedUpdateWithoutRegionManualInput
    >;
  };

  export type ContentItemUpdateManyWithWhereWithoutRegionManualInput = {
    where: ContentItemScalarWhereInput;
    data: XOR<
      ContentItemUpdateManyMutationInput,
      ContentItemUncheckedUpdateManyWithoutRegionManualInput
    >;
  };

  export type ContentItemUpsertWithWhereUniqueWithoutRegionEffectiveInput = {
    where: ContentItemWhereUniqueInput;
    update: XOR<
      ContentItemUpdateWithoutRegionEffectiveInput,
      ContentItemUncheckedUpdateWithoutRegionEffectiveInput
    >;
    create: XOR<
      ContentItemCreateWithoutRegionEffectiveInput,
      ContentItemUncheckedCreateWithoutRegionEffectiveInput
    >;
  };

  export type ContentItemUpdateWithWhereUniqueWithoutRegionEffectiveInput = {
    where: ContentItemWhereUniqueInput;
    data: XOR<
      ContentItemUpdateWithoutRegionEffectiveInput,
      ContentItemUncheckedUpdateWithoutRegionEffectiveInput
    >;
  };

  export type ContentItemUpdateManyWithWhereWithoutRegionEffectiveInput = {
    where: ContentItemScalarWhereInput;
    data: XOR<
      ContentItemUpdateManyMutationInput,
      ContentItemUncheckedUpdateManyWithoutRegionEffectiveInput
    >;
  };

  export type RegionClosureUpsertWithWhereUniqueWithoutAncestorInput = {
    where: RegionClosureWhereUniqueInput;
    update: XOR<
      RegionClosureUpdateWithoutAncestorInput,
      RegionClosureUncheckedUpdateWithoutAncestorInput
    >;
    create: XOR<
      RegionClosureCreateWithoutAncestorInput,
      RegionClosureUncheckedCreateWithoutAncestorInput
    >;
  };

  export type RegionClosureUpdateWithWhereUniqueWithoutAncestorInput = {
    where: RegionClosureWhereUniqueInput;
    data: XOR<
      RegionClosureUpdateWithoutAncestorInput,
      RegionClosureUncheckedUpdateWithoutAncestorInput
    >;
  };

  export type RegionClosureUpdateManyWithWhereWithoutAncestorInput = {
    where: RegionClosureScalarWhereInput;
    data: XOR<
      RegionClosureUpdateManyMutationInput,
      RegionClosureUncheckedUpdateManyWithoutAncestorInput
    >;
  };

  export type RegionClosureScalarWhereInput = {
    AND?: RegionClosureScalarWhereInput | RegionClosureScalarWhereInput[];
    OR?: RegionClosureScalarWhereInput[];
    NOT?: RegionClosureScalarWhereInput | RegionClosureScalarWhereInput[];
    id?: StringFilter<"RegionClosure"> | string;
    ancestorId?: StringFilter<"RegionClosure"> | string;
    descendantId?: StringFilter<"RegionClosure"> | string;
    depth?: IntFilter<"RegionClosure"> | number;
  };

  export type RegionClosureUpsertWithWhereUniqueWithoutDescendantInput = {
    where: RegionClosureWhereUniqueInput;
    update: XOR<
      RegionClosureUpdateWithoutDescendantInput,
      RegionClosureUncheckedUpdateWithoutDescendantInput
    >;
    create: XOR<
      RegionClosureCreateWithoutDescendantInput,
      RegionClosureUncheckedCreateWithoutDescendantInput
    >;
  };

  export type RegionClosureUpdateWithWhereUniqueWithoutDescendantInput = {
    where: RegionClosureWhereUniqueInput;
    data: XOR<
      RegionClosureUpdateWithoutDescendantInput,
      RegionClosureUncheckedUpdateWithoutDescendantInput
    >;
  };

  export type RegionClosureUpdateManyWithWhereWithoutDescendantInput = {
    where: RegionClosureScalarWhereInput;
    data: XOR<
      RegionClosureUpdateManyMutationInput,
      RegionClosureUncheckedUpdateManyWithoutDescendantInput
    >;
  };

  export type RegionCreateWithoutAncestorsInput = {
    id?: string;
    code: string;
    name: string;
    level: number;
    meta?: InputJsonValue | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    parent?: RegionCreateNestedOneWithoutChildrenInput;
    children?: RegionCreateNestedManyWithoutParentInput;
    itemsManual?: ContentItemCreateNestedManyWithoutRegionManualInput;
    itemsEffective?: ContentItemCreateNestedManyWithoutRegionEffectiveInput;
    descendants?: RegionClosureCreateNestedManyWithoutDescendantInput;
  };

  export type RegionUncheckedCreateWithoutAncestorsInput = {
    id?: string;
    code: string;
    name: string;
    level: number;
    parentId?: string | null;
    meta?: InputJsonValue | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    children?: RegionUncheckedCreateNestedManyWithoutParentInput;
    itemsManual?: ContentItemUncheckedCreateNestedManyWithoutRegionManualInput;
    itemsEffective?: ContentItemUncheckedCreateNestedManyWithoutRegionEffectiveInput;
    descendants?: RegionClosureUncheckedCreateNestedManyWithoutDescendantInput;
  };

  export type RegionCreateOrConnectWithoutAncestorsInput = {
    where: RegionWhereUniqueInput;
    create: XOR<
      RegionCreateWithoutAncestorsInput,
      RegionUncheckedCreateWithoutAncestorsInput
    >;
  };

  export type RegionCreateWithoutDescendantsInput = {
    id?: string;
    code: string;
    name: string;
    level: number;
    meta?: InputJsonValue | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    parent?: RegionCreateNestedOneWithoutChildrenInput;
    children?: RegionCreateNestedManyWithoutParentInput;
    itemsManual?: ContentItemCreateNestedManyWithoutRegionManualInput;
    itemsEffective?: ContentItemCreateNestedManyWithoutRegionEffectiveInput;
    ancestors?: RegionClosureCreateNestedManyWithoutAncestorInput;
  };

  export type RegionUncheckedCreateWithoutDescendantsInput = {
    id?: string;
    code: string;
    name: string;
    level: number;
    parentId?: string | null;
    meta?: InputJsonValue | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    children?: RegionUncheckedCreateNestedManyWithoutParentInput;
    itemsManual?: ContentItemUncheckedCreateNestedManyWithoutRegionManualInput;
    itemsEffective?: ContentItemUncheckedCreateNestedManyWithoutRegionEffectiveInput;
    ancestors?: RegionClosureUncheckedCreateNestedManyWithoutAncestorInput;
  };

  export type RegionCreateOrConnectWithoutDescendantsInput = {
    where: RegionWhereUniqueInput;
    create: XOR<
      RegionCreateWithoutDescendantsInput,
      RegionUncheckedCreateWithoutDescendantsInput
    >;
  };

  export type RegionUpsertWithoutAncestorsInput = {
    update: XOR<
      RegionUpdateWithoutAncestorsInput,
      RegionUncheckedUpdateWithoutAncestorsInput
    >;
    create: XOR<
      RegionCreateWithoutAncestorsInput,
      RegionUncheckedCreateWithoutAncestorsInput
    >;
    where?: RegionWhereInput;
  };

  export type RegionUpdateToOneWithWhereWithoutAncestorsInput = {
    where?: RegionWhereInput;
    data: XOR<
      RegionUpdateWithoutAncestorsInput,
      RegionUncheckedUpdateWithoutAncestorsInput
    >;
  };

  export type RegionUpdateWithoutAncestorsInput = {
    code?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    level?: IntFieldUpdateOperationsInput | number;
    meta?: InputJsonValue | InputJsonValue | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    parent?: RegionUpdateOneWithoutChildrenNestedInput;
    children?: RegionUpdateManyWithoutParentNestedInput;
    itemsManual?: ContentItemUpdateManyWithoutRegionManualNestedInput;
    itemsEffective?: ContentItemUpdateManyWithoutRegionEffectiveNestedInput;
    descendants?: RegionClosureUpdateManyWithoutDescendantNestedInput;
  };

  export type RegionUncheckedUpdateWithoutAncestorsInput = {
    code?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    level?: IntFieldUpdateOperationsInput | number;
    parentId?: NullableStringFieldUpdateOperationsInput | string | null;
    meta?: InputJsonValue | InputJsonValue | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    children?: RegionUncheckedUpdateManyWithoutParentNestedInput;
    itemsManual?: ContentItemUncheckedUpdateManyWithoutRegionManualNestedInput;
    itemsEffective?: ContentItemUncheckedUpdateManyWithoutRegionEffectiveNestedInput;
    descendants?: RegionClosureUncheckedUpdateManyWithoutDescendantNestedInput;
  };

  export type RegionUpsertWithoutDescendantsInput = {
    update: XOR<
      RegionUpdateWithoutDescendantsInput,
      RegionUncheckedUpdateWithoutDescendantsInput
    >;
    create: XOR<
      RegionCreateWithoutDescendantsInput,
      RegionUncheckedCreateWithoutDescendantsInput
    >;
    where?: RegionWhereInput;
  };

  export type RegionUpdateToOneWithWhereWithoutDescendantsInput = {
    where?: RegionWhereInput;
    data: XOR<
      RegionUpdateWithoutDescendantsInput,
      RegionUncheckedUpdateWithoutDescendantsInput
    >;
  };

  export type RegionUpdateWithoutDescendantsInput = {
    code?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    level?: IntFieldUpdateOperationsInput | number;
    meta?: InputJsonValue | InputJsonValue | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    parent?: RegionUpdateOneWithoutChildrenNestedInput;
    children?: RegionUpdateManyWithoutParentNestedInput;
    itemsManual?: ContentItemUpdateManyWithoutRegionManualNestedInput;
    itemsEffective?: ContentItemUpdateManyWithoutRegionEffectiveNestedInput;
    ancestors?: RegionClosureUpdateManyWithoutAncestorNestedInput;
  };

  export type RegionUncheckedUpdateWithoutDescendantsInput = {
    code?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    level?: IntFieldUpdateOperationsInput | number;
    parentId?: NullableStringFieldUpdateOperationsInput | string | null;
    meta?: InputJsonValue | InputJsonValue | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    children?: RegionUncheckedUpdateManyWithoutParentNestedInput;
    itemsManual?: ContentItemUncheckedUpdateManyWithoutRegionManualNestedInput;
    itemsEffective?: ContentItemUncheckedUpdateManyWithoutRegionEffectiveNestedInput;
    ancestors?: RegionClosureUncheckedUpdateManyWithoutAncestorNestedInput;
  };

  export type TopicCreateWithoutItemsInput = {
    id?: string;
    slug: string;
    title: string;
    description?: string | null;
    locale?: $Enums.Locale;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    tags?: TopicTagCreateNestedManyWithoutTopicInput;
  };

  export type TopicUncheckedCreateWithoutItemsInput = {
    id?: string;
    slug: string;
    title: string;
    description?: string | null;
    locale?: $Enums.Locale;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    tags?: TopicTagUncheckedCreateNestedManyWithoutTopicInput;
  };

  export type TopicCreateOrConnectWithoutItemsInput = {
    where: TopicWhereUniqueInput;
    create: XOR<
      TopicCreateWithoutItemsInput,
      TopicUncheckedCreateWithoutItemsInput
    >;
  };

  export type ExtractedUnitCreateWithoutItemInput = {
    id?: string;
    statementId?: string | null;
    kind: $Enums.UnitKind;
    text: string;
    spanStart: number;
    spanEnd: number;
    confidence: number;
    canonicalKey: string;
    scope?: string | null;
    timeframe?: string | null;
    interest?: $Enums.Interest;
    triage?: $Enums.Triage;
    editorNote?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    claim?: FactcheckClaimCreateNestedOneWithoutUnitsInput;
  };

  export type ExtractedUnitUncheckedCreateWithoutItemInput = {
    id?: string;
    statementId?: string | null;
    kind: $Enums.UnitKind;
    text: string;
    spanStart: number;
    spanEnd: number;
    confidence: number;
    canonicalKey: string;
    scope?: string | null;
    timeframe?: string | null;
    claimId?: string | null;
    interest?: $Enums.Interest;
    triage?: $Enums.Triage;
    editorNote?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type ExtractedUnitCreateOrConnectWithoutItemInput = {
    where: ExtractedUnitWhereUniqueInput;
    create: XOR<
      ExtractedUnitCreateWithoutItemInput,
      ExtractedUnitUncheckedCreateWithoutItemInput
    >;
  };

  export type ExtractedUnitCreateManyItemInputEnvelope = {
    data: ExtractedUnitCreateManyItemInput | ExtractedUnitCreateManyItemInput[];
  };

  export type RegionCreateWithoutItemsManualInput = {
    id?: string;
    code: string;
    name: string;
    level: number;
    meta?: InputJsonValue | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    parent?: RegionCreateNestedOneWithoutChildrenInput;
    children?: RegionCreateNestedManyWithoutParentInput;
    itemsEffective?: ContentItemCreateNestedManyWithoutRegionEffectiveInput;
    ancestors?: RegionClosureCreateNestedManyWithoutAncestorInput;
    descendants?: RegionClosureCreateNestedManyWithoutDescendantInput;
  };

  export type RegionUncheckedCreateWithoutItemsManualInput = {
    id?: string;
    code: string;
    name: string;
    level: number;
    parentId?: string | null;
    meta?: InputJsonValue | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    children?: RegionUncheckedCreateNestedManyWithoutParentInput;
    itemsEffective?: ContentItemUncheckedCreateNestedManyWithoutRegionEffectiveInput;
    ancestors?: RegionClosureUncheckedCreateNestedManyWithoutAncestorInput;
    descendants?: RegionClosureUncheckedCreateNestedManyWithoutDescendantInput;
  };

  export type RegionCreateOrConnectWithoutItemsManualInput = {
    where: RegionWhereUniqueInput;
    create: XOR<
      RegionCreateWithoutItemsManualInput,
      RegionUncheckedCreateWithoutItemsManualInput
    >;
  };

  export type RegionCreateWithoutItemsEffectiveInput = {
    id?: string;
    code: string;
    name: string;
    level: number;
    meta?: InputJsonValue | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    parent?: RegionCreateNestedOneWithoutChildrenInput;
    children?: RegionCreateNestedManyWithoutParentInput;
    itemsManual?: ContentItemCreateNestedManyWithoutRegionManualInput;
    ancestors?: RegionClosureCreateNestedManyWithoutAncestorInput;
    descendants?: RegionClosureCreateNestedManyWithoutDescendantInput;
  };

  export type RegionUncheckedCreateWithoutItemsEffectiveInput = {
    id?: string;
    code: string;
    name: string;
    level: number;
    parentId?: string | null;
    meta?: InputJsonValue | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    children?: RegionUncheckedCreateNestedManyWithoutParentInput;
    itemsManual?: ContentItemUncheckedCreateNestedManyWithoutRegionManualInput;
    ancestors?: RegionClosureUncheckedCreateNestedManyWithoutAncestorInput;
    descendants?: RegionClosureUncheckedCreateNestedManyWithoutDescendantInput;
  };

  export type RegionCreateOrConnectWithoutItemsEffectiveInput = {
    where: RegionWhereUniqueInput;
    create: XOR<
      RegionCreateWithoutItemsEffectiveInput,
      RegionUncheckedCreateWithoutItemsEffectiveInput
    >;
  };

  export type AnswerOptionCreateWithoutItemInput = {
    id?: string;
    label: string;
    value: string;
    sortOrder?: number;
    exclusive?: boolean;
    meta?: InputJsonValue | null;
  };

  export type AnswerOptionUncheckedCreateWithoutItemInput = {
    id?: string;
    label: string;
    value: string;
    sortOrder?: number;
    exclusive?: boolean;
    meta?: InputJsonValue | null;
  };

  export type AnswerOptionCreateOrConnectWithoutItemInput = {
    where: AnswerOptionWhereUniqueInput;
    create: XOR<
      AnswerOptionCreateWithoutItemInput,
      AnswerOptionUncheckedCreateWithoutItemInput
    >;
  };

  export type AnswerOptionCreateManyItemInputEnvelope = {
    data: AnswerOptionCreateManyItemInput | AnswerOptionCreateManyItemInput[];
  };

  export type ItemTagCreateWithoutItemInput = {
    id?: string;
    tag: TagCreateNestedOneWithoutItemsInput;
  };

  export type ItemTagUncheckedCreateWithoutItemInput = {
    id?: string;
    tagId: string;
  };

  export type ItemTagCreateOrConnectWithoutItemInput = {
    where: ItemTagWhereUniqueInput;
    create: XOR<
      ItemTagCreateWithoutItemInput,
      ItemTagUncheckedCreateWithoutItemInput
    >;
  };

  export type ItemTagCreateManyItemInputEnvelope = {
    data: ItemTagCreateManyItemInput | ItemTagCreateManyItemInput[];
  };

  export type TopicUpsertWithoutItemsInput = {
    update: XOR<
      TopicUpdateWithoutItemsInput,
      TopicUncheckedUpdateWithoutItemsInput
    >;
    create: XOR<
      TopicCreateWithoutItemsInput,
      TopicUncheckedCreateWithoutItemsInput
    >;
    where?: TopicWhereInput;
  };

  export type TopicUpdateToOneWithWhereWithoutItemsInput = {
    where?: TopicWhereInput;
    data: XOR<
      TopicUpdateWithoutItemsInput,
      TopicUncheckedUpdateWithoutItemsInput
    >;
  };

  export type TopicUpdateWithoutItemsInput = {
    slug?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    locale?: EnumLocaleFieldUpdateOperationsInput | $Enums.Locale;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    tags?: TopicTagUpdateManyWithoutTopicNestedInput;
  };

  export type TopicUncheckedUpdateWithoutItemsInput = {
    slug?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    locale?: EnumLocaleFieldUpdateOperationsInput | $Enums.Locale;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    tags?: TopicTagUncheckedUpdateManyWithoutTopicNestedInput;
  };

  export type ExtractedUnitUpsertWithWhereUniqueWithoutItemInput = {
    where: ExtractedUnitWhereUniqueInput;
    update: XOR<
      ExtractedUnitUpdateWithoutItemInput,
      ExtractedUnitUncheckedUpdateWithoutItemInput
    >;
    create: XOR<
      ExtractedUnitCreateWithoutItemInput,
      ExtractedUnitUncheckedCreateWithoutItemInput
    >;
  };

  export type ExtractedUnitUpdateWithWhereUniqueWithoutItemInput = {
    where: ExtractedUnitWhereUniqueInput;
    data: XOR<
      ExtractedUnitUpdateWithoutItemInput,
      ExtractedUnitUncheckedUpdateWithoutItemInput
    >;
  };

  export type ExtractedUnitUpdateManyWithWhereWithoutItemInput = {
    where: ExtractedUnitScalarWhereInput;
    data: XOR<
      ExtractedUnitUpdateManyMutationInput,
      ExtractedUnitUncheckedUpdateManyWithoutItemInput
    >;
  };

  export type ExtractedUnitScalarWhereInput = {
    AND?: ExtractedUnitScalarWhereInput | ExtractedUnitScalarWhereInput[];
    OR?: ExtractedUnitScalarWhereInput[];
    NOT?: ExtractedUnitScalarWhereInput | ExtractedUnitScalarWhereInput[];
    id?: StringFilter<"ExtractedUnit"> | string;
    itemId?: StringNullableFilter<"ExtractedUnit"> | string | null;
    statementId?: StringNullableFilter<"ExtractedUnit"> | string | null;
    kind?: EnumUnitKindFilter<"ExtractedUnit"> | $Enums.UnitKind;
    text?: StringFilter<"ExtractedUnit"> | string;
    spanStart?: IntFilter<"ExtractedUnit"> | number;
    spanEnd?: IntFilter<"ExtractedUnit"> | number;
    confidence?: FloatFilter<"ExtractedUnit"> | number;
    canonicalKey?: StringFilter<"ExtractedUnit"> | string;
    scope?: StringNullableFilter<"ExtractedUnit"> | string | null;
    timeframe?: StringNullableFilter<"ExtractedUnit"> | string | null;
    claimId?: StringNullableFilter<"ExtractedUnit"> | string | null;
    interest?: EnumInterestFilter<"ExtractedUnit"> | $Enums.Interest;
    triage?: EnumTriageFilter<"ExtractedUnit"> | $Enums.Triage;
    editorNote?: StringNullableFilter<"ExtractedUnit"> | string | null;
    createdAt?: DateTimeFilter<"ExtractedUnit"> | Date | string;
    updatedAt?: DateTimeFilter<"ExtractedUnit"> | Date | string;
  };

  export type RegionUpsertWithoutItemsManualInput = {
    update: XOR<
      RegionUpdateWithoutItemsManualInput,
      RegionUncheckedUpdateWithoutItemsManualInput
    >;
    create: XOR<
      RegionCreateWithoutItemsManualInput,
      RegionUncheckedCreateWithoutItemsManualInput
    >;
    where?: RegionWhereInput;
  };

  export type RegionUpdateToOneWithWhereWithoutItemsManualInput = {
    where?: RegionWhereInput;
    data: XOR<
      RegionUpdateWithoutItemsManualInput,
      RegionUncheckedUpdateWithoutItemsManualInput
    >;
  };

  export type RegionUpdateWithoutItemsManualInput = {
    code?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    level?: IntFieldUpdateOperationsInput | number;
    meta?: InputJsonValue | InputJsonValue | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    parent?: RegionUpdateOneWithoutChildrenNestedInput;
    children?: RegionUpdateManyWithoutParentNestedInput;
    itemsEffective?: ContentItemUpdateManyWithoutRegionEffectiveNestedInput;
    ancestors?: RegionClosureUpdateManyWithoutAncestorNestedInput;
    descendants?: RegionClosureUpdateManyWithoutDescendantNestedInput;
  };

  export type RegionUncheckedUpdateWithoutItemsManualInput = {
    code?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    level?: IntFieldUpdateOperationsInput | number;
    parentId?: NullableStringFieldUpdateOperationsInput | string | null;
    meta?: InputJsonValue | InputJsonValue | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    children?: RegionUncheckedUpdateManyWithoutParentNestedInput;
    itemsEffective?: ContentItemUncheckedUpdateManyWithoutRegionEffectiveNestedInput;
    ancestors?: RegionClosureUncheckedUpdateManyWithoutAncestorNestedInput;
    descendants?: RegionClosureUncheckedUpdateManyWithoutDescendantNestedInput;
  };

  export type RegionUpsertWithoutItemsEffectiveInput = {
    update: XOR<
      RegionUpdateWithoutItemsEffectiveInput,
      RegionUncheckedUpdateWithoutItemsEffectiveInput
    >;
    create: XOR<
      RegionCreateWithoutItemsEffectiveInput,
      RegionUncheckedCreateWithoutItemsEffectiveInput
    >;
    where?: RegionWhereInput;
  };

  export type RegionUpdateToOneWithWhereWithoutItemsEffectiveInput = {
    where?: RegionWhereInput;
    data: XOR<
      RegionUpdateWithoutItemsEffectiveInput,
      RegionUncheckedUpdateWithoutItemsEffectiveInput
    >;
  };

  export type RegionUpdateWithoutItemsEffectiveInput = {
    code?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    level?: IntFieldUpdateOperationsInput | number;
    meta?: InputJsonValue | InputJsonValue | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    parent?: RegionUpdateOneWithoutChildrenNestedInput;
    children?: RegionUpdateManyWithoutParentNestedInput;
    itemsManual?: ContentItemUpdateManyWithoutRegionManualNestedInput;
    ancestors?: RegionClosureUpdateManyWithoutAncestorNestedInput;
    descendants?: RegionClosureUpdateManyWithoutDescendantNestedInput;
  };

  export type RegionUncheckedUpdateWithoutItemsEffectiveInput = {
    code?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    level?: IntFieldUpdateOperationsInput | number;
    parentId?: NullableStringFieldUpdateOperationsInput | string | null;
    meta?: InputJsonValue | InputJsonValue | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    children?: RegionUncheckedUpdateManyWithoutParentNestedInput;
    itemsManual?: ContentItemUncheckedUpdateManyWithoutRegionManualNestedInput;
    ancestors?: RegionClosureUncheckedUpdateManyWithoutAncestorNestedInput;
    descendants?: RegionClosureUncheckedUpdateManyWithoutDescendantNestedInput;
  };

  export type AnswerOptionUpsertWithWhereUniqueWithoutItemInput = {
    where: AnswerOptionWhereUniqueInput;
    update: XOR<
      AnswerOptionUpdateWithoutItemInput,
      AnswerOptionUncheckedUpdateWithoutItemInput
    >;
    create: XOR<
      AnswerOptionCreateWithoutItemInput,
      AnswerOptionUncheckedCreateWithoutItemInput
    >;
  };

  export type AnswerOptionUpdateWithWhereUniqueWithoutItemInput = {
    where: AnswerOptionWhereUniqueInput;
    data: XOR<
      AnswerOptionUpdateWithoutItemInput,
      AnswerOptionUncheckedUpdateWithoutItemInput
    >;
  };

  export type AnswerOptionUpdateManyWithWhereWithoutItemInput = {
    where: AnswerOptionScalarWhereInput;
    data: XOR<
      AnswerOptionUpdateManyMutationInput,
      AnswerOptionUncheckedUpdateManyWithoutItemInput
    >;
  };

  export type AnswerOptionScalarWhereInput = {
    AND?: AnswerOptionScalarWhereInput | AnswerOptionScalarWhereInput[];
    OR?: AnswerOptionScalarWhereInput[];
    NOT?: AnswerOptionScalarWhereInput | AnswerOptionScalarWhereInput[];
    id?: StringFilter<"AnswerOption"> | string;
    itemId?: StringFilter<"AnswerOption"> | string;
    label?: StringFilter<"AnswerOption"> | string;
    value?: StringFilter<"AnswerOption"> | string;
    sortOrder?: IntFilter<"AnswerOption"> | number;
    exclusive?: BoolFilter<"AnswerOption"> | boolean;
    meta?: JsonNullableFilter<"AnswerOption">;
  };

  export type ItemTagUpsertWithWhereUniqueWithoutItemInput = {
    where: ItemTagWhereUniqueInput;
    update: XOR<
      ItemTagUpdateWithoutItemInput,
      ItemTagUncheckedUpdateWithoutItemInput
    >;
    create: XOR<
      ItemTagCreateWithoutItemInput,
      ItemTagUncheckedCreateWithoutItemInput
    >;
  };

  export type ItemTagUpdateWithWhereUniqueWithoutItemInput = {
    where: ItemTagWhereUniqueInput;
    data: XOR<
      ItemTagUpdateWithoutItemInput,
      ItemTagUncheckedUpdateWithoutItemInput
    >;
  };

  export type ItemTagUpdateManyWithWhereWithoutItemInput = {
    where: ItemTagScalarWhereInput;
    data: XOR<
      ItemTagUpdateManyMutationInput,
      ItemTagUncheckedUpdateManyWithoutItemInput
    >;
  };

  export type ContentItemCreateWithoutAnswerOptionsInput = {
    id?: string;
    kind: $Enums.ContentKind;
    locale?: $Enums.Locale;
    title?: string | null;
    text: string;
    richText?: string | null;
    sortOrder?: number;
    status?: $Enums.PublishStatus;
    authorName?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    publishAt?: Date | string | null;
    expireAt?: Date | string | null;
    regionMode?: $Enums.RegionMode;
    regionAuto?: InputJsonValue | null;
    validation?: InputJsonValue | null;
    meta?: InputJsonValue | null;
    topic: TopicCreateNestedOneWithoutItemsInput;
    units?: ExtractedUnitCreateNestedManyWithoutItemInput;
    regionManual?: RegionCreateNestedOneWithoutItemsManualInput;
    regionEffective?: RegionCreateNestedOneWithoutItemsEffectiveInput;
    tags?: ItemTagCreateNestedManyWithoutItemInput;
  };

  export type ContentItemUncheckedCreateWithoutAnswerOptionsInput = {
    id?: string;
    kind: $Enums.ContentKind;
    topicId: string;
    locale?: $Enums.Locale;
    title?: string | null;
    text: string;
    richText?: string | null;
    sortOrder?: number;
    status?: $Enums.PublishStatus;
    authorName?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    publishAt?: Date | string | null;
    expireAt?: Date | string | null;
    regionMode?: $Enums.RegionMode;
    regionManualId?: string | null;
    regionAuto?: InputJsonValue | null;
    regionEffectiveId?: string | null;
    validation?: InputJsonValue | null;
    meta?: InputJsonValue | null;
    units?: ExtractedUnitUncheckedCreateNestedManyWithoutItemInput;
    tags?: ItemTagUncheckedCreateNestedManyWithoutItemInput;
  };

  export type ContentItemCreateOrConnectWithoutAnswerOptionsInput = {
    where: ContentItemWhereUniqueInput;
    create: XOR<
      ContentItemCreateWithoutAnswerOptionsInput,
      ContentItemUncheckedCreateWithoutAnswerOptionsInput
    >;
  };

  export type ContentItemUpsertWithoutAnswerOptionsInput = {
    update: XOR<
      ContentItemUpdateWithoutAnswerOptionsInput,
      ContentItemUncheckedUpdateWithoutAnswerOptionsInput
    >;
    create: XOR<
      ContentItemCreateWithoutAnswerOptionsInput,
      ContentItemUncheckedCreateWithoutAnswerOptionsInput
    >;
    where?: ContentItemWhereInput;
  };

  export type ContentItemUpdateToOneWithWhereWithoutAnswerOptionsInput = {
    where?: ContentItemWhereInput;
    data: XOR<
      ContentItemUpdateWithoutAnswerOptionsInput,
      ContentItemUncheckedUpdateWithoutAnswerOptionsInput
    >;
  };

  export type ContentItemUpdateWithoutAnswerOptionsInput = {
    kind?: EnumContentKindFieldUpdateOperationsInput | $Enums.ContentKind;
    locale?: EnumLocaleFieldUpdateOperationsInput | $Enums.Locale;
    title?: NullableStringFieldUpdateOperationsInput | string | null;
    text?: StringFieldUpdateOperationsInput | string;
    richText?: NullableStringFieldUpdateOperationsInput | string | null;
    sortOrder?: IntFieldUpdateOperationsInput | number;
    status?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus;
    authorName?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    publishAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    expireAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    regionMode?: EnumRegionModeFieldUpdateOperationsInput | $Enums.RegionMode;
    regionAuto?: InputJsonValue | InputJsonValue | null;
    validation?: InputJsonValue | InputJsonValue | null;
    meta?: InputJsonValue | InputJsonValue | null;
    topic?: TopicUpdateOneRequiredWithoutItemsNestedInput;
    units?: ExtractedUnitUpdateManyWithoutItemNestedInput;
    regionManual?: RegionUpdateOneWithoutItemsManualNestedInput;
    regionEffective?: RegionUpdateOneWithoutItemsEffectiveNestedInput;
    tags?: ItemTagUpdateManyWithoutItemNestedInput;
  };

  export type ContentItemUncheckedUpdateWithoutAnswerOptionsInput = {
    kind?: EnumContentKindFieldUpdateOperationsInput | $Enums.ContentKind;
    topicId?: StringFieldUpdateOperationsInput | string;
    locale?: EnumLocaleFieldUpdateOperationsInput | $Enums.Locale;
    title?: NullableStringFieldUpdateOperationsInput | string | null;
    text?: StringFieldUpdateOperationsInput | string;
    richText?: NullableStringFieldUpdateOperationsInput | string | null;
    sortOrder?: IntFieldUpdateOperationsInput | number;
    status?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus;
    authorName?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    publishAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    expireAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    regionMode?: EnumRegionModeFieldUpdateOperationsInput | $Enums.RegionMode;
    regionManualId?: NullableStringFieldUpdateOperationsInput | string | null;
    regionAuto?: InputJsonValue | InputJsonValue | null;
    regionEffectiveId?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    validation?: InputJsonValue | InputJsonValue | null;
    meta?: InputJsonValue | InputJsonValue | null;
    units?: ExtractedUnitUncheckedUpdateManyWithoutItemNestedInput;
    tags?: ItemTagUncheckedUpdateManyWithoutItemNestedInput;
  };

  export type FactcheckClaimCreateWithoutJobInput = {
    id?: string;
    text: string;
    language?: string | null;
    topic?: string | null;
    falsifiable?: boolean;
    frames?: FactcheckClaimCreateframesInput | string[];
    rhetoricalFlags?: FactcheckClaimCreaterhetoricalFlagsInput | string[];
    canonicalKey: string;
    scope?: string | null;
    timeframe?: string | null;
    status?: $Enums.ReviewStatus;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    providerRuns?: ProviderRunCreateNestedManyWithoutClaimInput;
    evidences?: EvidenceCreateNestedManyWithoutClaimInput;
    consensus?: ConsensusRunCreateNestedOneWithoutClaimInput;
    verdictVersions?: VerdictVersionCreateNestedManyWithoutClaimInput;
    units?: ExtractedUnitCreateNestedManyWithoutClaimInput;
    finding?: FindingCreateNestedOneWithoutClaimInput;
  };

  export type FactcheckClaimUncheckedCreateWithoutJobInput = {
    id?: string;
    text: string;
    language?: string | null;
    topic?: string | null;
    falsifiable?: boolean;
    frames?: FactcheckClaimCreateframesInput | string[];
    rhetoricalFlags?: FactcheckClaimCreaterhetoricalFlagsInput | string[];
    canonicalKey: string;
    scope?: string | null;
    timeframe?: string | null;
    status?: $Enums.ReviewStatus;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    providerRuns?: ProviderRunUncheckedCreateNestedManyWithoutClaimInput;
    evidences?: EvidenceUncheckedCreateNestedManyWithoutClaimInput;
    consensus?: ConsensusRunUncheckedCreateNestedOneWithoutClaimInput;
    verdictVersions?: VerdictVersionUncheckedCreateNestedManyWithoutClaimInput;
    units?: ExtractedUnitUncheckedCreateNestedManyWithoutClaimInput;
    finding?: FindingUncheckedCreateNestedOneWithoutClaimInput;
  };

  export type FactcheckClaimCreateOrConnectWithoutJobInput = {
    where: FactcheckClaimWhereUniqueInput;
    create: XOR<
      FactcheckClaimCreateWithoutJobInput,
      FactcheckClaimUncheckedCreateWithoutJobInput
    >;
  };

  export type FactcheckClaimCreateManyJobInputEnvelope = {
    data: FactcheckClaimCreateManyJobInput | FactcheckClaimCreateManyJobInput[];
  };

  export type FactcheckResultCreateWithoutJobInput = {
    id?: string;
    verdict: string;
    rawOutput: InputJsonValue;
    createdAt?: Date | string;
  };

  export type FactcheckResultUncheckedCreateWithoutJobInput = {
    id?: string;
    verdict: string;
    rawOutput: InputJsonValue;
    createdAt?: Date | string;
  };

  export type FactcheckResultCreateOrConnectWithoutJobInput = {
    where: FactcheckResultWhereUniqueInput;
    create: XOR<
      FactcheckResultCreateWithoutJobInput,
      FactcheckResultUncheckedCreateWithoutJobInput
    >;
  };

  export type FactcheckResultCreateManyJobInputEnvelope = {
    data:
      | FactcheckResultCreateManyJobInput
      | FactcheckResultCreateManyJobInput[];
  };

  export type FactcheckClaimUpsertWithWhereUniqueWithoutJobInput = {
    where: FactcheckClaimWhereUniqueInput;
    update: XOR<
      FactcheckClaimUpdateWithoutJobInput,
      FactcheckClaimUncheckedUpdateWithoutJobInput
    >;
    create: XOR<
      FactcheckClaimCreateWithoutJobInput,
      FactcheckClaimUncheckedCreateWithoutJobInput
    >;
  };

  export type FactcheckClaimUpdateWithWhereUniqueWithoutJobInput = {
    where: FactcheckClaimWhereUniqueInput;
    data: XOR<
      FactcheckClaimUpdateWithoutJobInput,
      FactcheckClaimUncheckedUpdateWithoutJobInput
    >;
  };

  export type FactcheckClaimUpdateManyWithWhereWithoutJobInput = {
    where: FactcheckClaimScalarWhereInput;
    data: XOR<
      FactcheckClaimUpdateManyMutationInput,
      FactcheckClaimUncheckedUpdateManyWithoutJobInput
    >;
  };

  export type FactcheckClaimScalarWhereInput = {
    AND?: FactcheckClaimScalarWhereInput | FactcheckClaimScalarWhereInput[];
    OR?: FactcheckClaimScalarWhereInput[];
    NOT?: FactcheckClaimScalarWhereInput | FactcheckClaimScalarWhereInput[];
    id?: StringFilter<"FactcheckClaim"> | string;
    jobId?: StringFilter<"FactcheckClaim"> | string;
    text?: StringFilter<"FactcheckClaim"> | string;
    language?: StringNullableFilter<"FactcheckClaim"> | string | null;
    topic?: StringNullableFilter<"FactcheckClaim"> | string | null;
    falsifiable?: BoolFilter<"FactcheckClaim"> | boolean;
    frames?: StringNullableListFilter<"FactcheckClaim">;
    rhetoricalFlags?: StringNullableListFilter<"FactcheckClaim">;
    canonicalKey?: StringFilter<"FactcheckClaim"> | string;
    scope?: StringNullableFilter<"FactcheckClaim"> | string | null;
    timeframe?: StringNullableFilter<"FactcheckClaim"> | string | null;
    status?: EnumReviewStatusFilter<"FactcheckClaim"> | $Enums.ReviewStatus;
    createdAt?: DateTimeFilter<"FactcheckClaim"> | Date | string;
    updatedAt?: DateTimeFilter<"FactcheckClaim"> | Date | string;
  };

  export type FactcheckResultUpsertWithWhereUniqueWithoutJobInput = {
    where: FactcheckResultWhereUniqueInput;
    update: XOR<
      FactcheckResultUpdateWithoutJobInput,
      FactcheckResultUncheckedUpdateWithoutJobInput
    >;
    create: XOR<
      FactcheckResultCreateWithoutJobInput,
      FactcheckResultUncheckedCreateWithoutJobInput
    >;
  };

  export type FactcheckResultUpdateWithWhereUniqueWithoutJobInput = {
    where: FactcheckResultWhereUniqueInput;
    data: XOR<
      FactcheckResultUpdateWithoutJobInput,
      FactcheckResultUncheckedUpdateWithoutJobInput
    >;
  };

  export type FactcheckResultUpdateManyWithWhereWithoutJobInput = {
    where: FactcheckResultScalarWhereInput;
    data: XOR<
      FactcheckResultUpdateManyMutationInput,
      FactcheckResultUncheckedUpdateManyWithoutJobInput
    >;
  };

  export type FactcheckResultScalarWhereInput = {
    AND?: FactcheckResultScalarWhereInput | FactcheckResultScalarWhereInput[];
    OR?: FactcheckResultScalarWhereInput[];
    NOT?: FactcheckResultScalarWhereInput | FactcheckResultScalarWhereInput[];
    id?: StringFilter<"FactcheckResult"> | string;
    jobId?: StringFilter<"FactcheckResult"> | string;
    verdict?: StringFilter<"FactcheckResult"> | string;
    rawOutput?: JsonFilter<"FactcheckResult">;
    createdAt?: DateTimeFilter<"FactcheckResult"> | Date | string;
  };

  export type FactcheckJobCreateWithoutClaimsInput = {
    id?: string;
    jobId: string;
    contributionId: string;
    status: string;
    tokensUsed?: number;
    durationMs?: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    results?: FactcheckResultCreateNestedManyWithoutJobInput;
  };

  export type FactcheckJobUncheckedCreateWithoutClaimsInput = {
    id?: string;
    jobId: string;
    contributionId: string;
    status: string;
    tokensUsed?: number;
    durationMs?: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    results?: FactcheckResultUncheckedCreateNestedManyWithoutJobInput;
  };

  export type FactcheckJobCreateOrConnectWithoutClaimsInput = {
    where: FactcheckJobWhereUniqueInput;
    create: XOR<
      FactcheckJobCreateWithoutClaimsInput,
      FactcheckJobUncheckedCreateWithoutClaimsInput
    >;
  };

  export type ProviderRunCreateWithoutClaimInput = {
    id?: string;
    provider: string;
    verdict: string;
    confidence: number;
    costTokens?: number;
    latencyMs?: number;
    raw: InputJsonValue;
    createdAt?: Date | string;
  };

  export type ProviderRunUncheckedCreateWithoutClaimInput = {
    id?: string;
    provider: string;
    verdict: string;
    confidence: number;
    costTokens?: number;
    latencyMs?: number;
    raw: InputJsonValue;
    createdAt?: Date | string;
  };

  export type ProviderRunCreateOrConnectWithoutClaimInput = {
    where: ProviderRunWhereUniqueInput;
    create: XOR<
      ProviderRunCreateWithoutClaimInput,
      ProviderRunUncheckedCreateWithoutClaimInput
    >;
  };

  export type ProviderRunCreateManyClaimInputEnvelope = {
    data: ProviderRunCreateManyClaimInput | ProviderRunCreateManyClaimInput[];
  };

  export type EvidenceCreateWithoutClaimInput = {
    id?: string;
    url: string;
    domain: string;
    stance: $Enums.Stance;
    snapshotHash?: string | null;
    firstSeenAt?: Date | string | null;
    trustScore?: number | null;
  };

  export type EvidenceUncheckedCreateWithoutClaimInput = {
    id?: string;
    url: string;
    domain: string;
    stance: $Enums.Stance;
    snapshotHash?: string | null;
    firstSeenAt?: Date | string | null;
    trustScore?: number | null;
  };

  export type EvidenceCreateOrConnectWithoutClaimInput = {
    where: EvidenceWhereUniqueInput;
    create: XOR<
      EvidenceCreateWithoutClaimInput,
      EvidenceUncheckedCreateWithoutClaimInput
    >;
  };

  export type EvidenceCreateManyClaimInputEnvelope = {
    data: EvidenceCreateManyClaimInput | EvidenceCreateManyClaimInput[];
  };

  export type ConsensusRunCreateWithoutClaimInput = {
    id?: string;
    method: string;
    verdict: string;
    confidence: number;
    balanceScore: number;
    diversityIndex: number;
    providers: InputJsonValue;
    createdAt?: Date | string;
  };

  export type ConsensusRunUncheckedCreateWithoutClaimInput = {
    id?: string;
    method: string;
    verdict: string;
    confidence: number;
    balanceScore: number;
    diversityIndex: number;
    providers: InputJsonValue;
    createdAt?: Date | string;
  };

  export type ConsensusRunCreateOrConnectWithoutClaimInput = {
    where: ConsensusRunWhereUniqueInput;
    create: XOR<
      ConsensusRunCreateWithoutClaimInput,
      ConsensusRunUncheckedCreateWithoutClaimInput
    >;
  };

  export type VerdictVersionCreateWithoutClaimInput = {
    id?: string;
    verdict: string;
    confidence: number;
    asOf?: Date | string;
    supersedes?: string | null;
  };

  export type VerdictVersionUncheckedCreateWithoutClaimInput = {
    id?: string;
    verdict: string;
    confidence: number;
    asOf?: Date | string;
    supersedes?: string | null;
  };

  export type VerdictVersionCreateOrConnectWithoutClaimInput = {
    where: VerdictVersionWhereUniqueInput;
    create: XOR<
      VerdictVersionCreateWithoutClaimInput,
      VerdictVersionUncheckedCreateWithoutClaimInput
    >;
  };

  export type VerdictVersionCreateManyClaimInputEnvelope = {
    data:
      | VerdictVersionCreateManyClaimInput
      | VerdictVersionCreateManyClaimInput[];
  };

  export type ExtractedUnitCreateWithoutClaimInput = {
    id?: string;
    statementId?: string | null;
    kind: $Enums.UnitKind;
    text: string;
    spanStart: number;
    spanEnd: number;
    confidence: number;
    canonicalKey: string;
    scope?: string | null;
    timeframe?: string | null;
    interest?: $Enums.Interest;
    triage?: $Enums.Triage;
    editorNote?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    item?: ContentItemCreateNestedOneWithoutUnitsInput;
  };

  export type ExtractedUnitUncheckedCreateWithoutClaimInput = {
    id?: string;
    itemId?: string | null;
    statementId?: string | null;
    kind: $Enums.UnitKind;
    text: string;
    spanStart: number;
    spanEnd: number;
    confidence: number;
    canonicalKey: string;
    scope?: string | null;
    timeframe?: string | null;
    interest?: $Enums.Interest;
    triage?: $Enums.Triage;
    editorNote?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type ExtractedUnitCreateOrConnectWithoutClaimInput = {
    where: ExtractedUnitWhereUniqueInput;
    create: XOR<
      ExtractedUnitCreateWithoutClaimInput,
      ExtractedUnitUncheckedCreateWithoutClaimInput
    >;
  };

  export type ExtractedUnitCreateManyClaimInputEnvelope = {
    data:
      | ExtractedUnitCreateManyClaimInput
      | ExtractedUnitCreateManyClaimInput[];
  };

  export type FindingCreateWithoutClaimInput = {
    id?: string;
    summary: string;
    outcome: string;
    rationale: string;
    metrics?: InputJsonValue | null;
    comparedJurisdictions?: InputJsonValue | null;
    lastChecked?: Date | string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type FindingUncheckedCreateWithoutClaimInput = {
    id?: string;
    summary: string;
    outcome: string;
    rationale: string;
    metrics?: InputJsonValue | null;
    comparedJurisdictions?: InputJsonValue | null;
    lastChecked?: Date | string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type FindingCreateOrConnectWithoutClaimInput = {
    where: FindingWhereUniqueInput;
    create: XOR<
      FindingCreateWithoutClaimInput,
      FindingUncheckedCreateWithoutClaimInput
    >;
  };

  export type FactcheckJobUpsertWithoutClaimsInput = {
    update: XOR<
      FactcheckJobUpdateWithoutClaimsInput,
      FactcheckJobUncheckedUpdateWithoutClaimsInput
    >;
    create: XOR<
      FactcheckJobCreateWithoutClaimsInput,
      FactcheckJobUncheckedCreateWithoutClaimsInput
    >;
    where?: FactcheckJobWhereInput;
  };

  export type FactcheckJobUpdateToOneWithWhereWithoutClaimsInput = {
    where?: FactcheckJobWhereInput;
    data: XOR<
      FactcheckJobUpdateWithoutClaimsInput,
      FactcheckJobUncheckedUpdateWithoutClaimsInput
    >;
  };

  export type FactcheckJobUpdateWithoutClaimsInput = {
    jobId?: StringFieldUpdateOperationsInput | string;
    contributionId?: StringFieldUpdateOperationsInput | string;
    status?: StringFieldUpdateOperationsInput | string;
    tokensUsed?: IntFieldUpdateOperationsInput | number;
    durationMs?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    results?: FactcheckResultUpdateManyWithoutJobNestedInput;
  };

  export type FactcheckJobUncheckedUpdateWithoutClaimsInput = {
    jobId?: StringFieldUpdateOperationsInput | string;
    contributionId?: StringFieldUpdateOperationsInput | string;
    status?: StringFieldUpdateOperationsInput | string;
    tokensUsed?: IntFieldUpdateOperationsInput | number;
    durationMs?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    results?: FactcheckResultUncheckedUpdateManyWithoutJobNestedInput;
  };

  export type ProviderRunUpsertWithWhereUniqueWithoutClaimInput = {
    where: ProviderRunWhereUniqueInput;
    update: XOR<
      ProviderRunUpdateWithoutClaimInput,
      ProviderRunUncheckedUpdateWithoutClaimInput
    >;
    create: XOR<
      ProviderRunCreateWithoutClaimInput,
      ProviderRunUncheckedCreateWithoutClaimInput
    >;
  };

  export type ProviderRunUpdateWithWhereUniqueWithoutClaimInput = {
    where: ProviderRunWhereUniqueInput;
    data: XOR<
      ProviderRunUpdateWithoutClaimInput,
      ProviderRunUncheckedUpdateWithoutClaimInput
    >;
  };

  export type ProviderRunUpdateManyWithWhereWithoutClaimInput = {
    where: ProviderRunScalarWhereInput;
    data: XOR<
      ProviderRunUpdateManyMutationInput,
      ProviderRunUncheckedUpdateManyWithoutClaimInput
    >;
  };

  export type ProviderRunScalarWhereInput = {
    AND?: ProviderRunScalarWhereInput | ProviderRunScalarWhereInput[];
    OR?: ProviderRunScalarWhereInput[];
    NOT?: ProviderRunScalarWhereInput | ProviderRunScalarWhereInput[];
    id?: StringFilter<"ProviderRun"> | string;
    claimId?: StringFilter<"ProviderRun"> | string;
    provider?: StringFilter<"ProviderRun"> | string;
    verdict?: StringFilter<"ProviderRun"> | string;
    confidence?: FloatFilter<"ProviderRun"> | number;
    costTokens?: IntFilter<"ProviderRun"> | number;
    latencyMs?: IntFilter<"ProviderRun"> | number;
    raw?: JsonFilter<"ProviderRun">;
    createdAt?: DateTimeFilter<"ProviderRun"> | Date | string;
  };

  export type EvidenceUpsertWithWhereUniqueWithoutClaimInput = {
    where: EvidenceWhereUniqueInput;
    update: XOR<
      EvidenceUpdateWithoutClaimInput,
      EvidenceUncheckedUpdateWithoutClaimInput
    >;
    create: XOR<
      EvidenceCreateWithoutClaimInput,
      EvidenceUncheckedCreateWithoutClaimInput
    >;
  };

  export type EvidenceUpdateWithWhereUniqueWithoutClaimInput = {
    where: EvidenceWhereUniqueInput;
    data: XOR<
      EvidenceUpdateWithoutClaimInput,
      EvidenceUncheckedUpdateWithoutClaimInput
    >;
  };

  export type EvidenceUpdateManyWithWhereWithoutClaimInput = {
    where: EvidenceScalarWhereInput;
    data: XOR<
      EvidenceUpdateManyMutationInput,
      EvidenceUncheckedUpdateManyWithoutClaimInput
    >;
  };

  export type EvidenceScalarWhereInput = {
    AND?: EvidenceScalarWhereInput | EvidenceScalarWhereInput[];
    OR?: EvidenceScalarWhereInput[];
    NOT?: EvidenceScalarWhereInput | EvidenceScalarWhereInput[];
    id?: StringFilter<"Evidence"> | string;
    claimId?: StringFilter<"Evidence"> | string;
    url?: StringFilter<"Evidence"> | string;
    domain?: StringFilter<"Evidence"> | string;
    stance?: EnumStanceFilter<"Evidence"> | $Enums.Stance;
    snapshotHash?: StringNullableFilter<"Evidence"> | string | null;
    firstSeenAt?: DateTimeNullableFilter<"Evidence"> | Date | string | null;
    trustScore?: IntNullableFilter<"Evidence"> | number | null;
  };

  export type ConsensusRunUpsertWithoutClaimInput = {
    update: XOR<
      ConsensusRunUpdateWithoutClaimInput,
      ConsensusRunUncheckedUpdateWithoutClaimInput
    >;
    create: XOR<
      ConsensusRunCreateWithoutClaimInput,
      ConsensusRunUncheckedCreateWithoutClaimInput
    >;
    where?: ConsensusRunWhereInput;
  };

  export type ConsensusRunUpdateToOneWithWhereWithoutClaimInput = {
    where?: ConsensusRunWhereInput;
    data: XOR<
      ConsensusRunUpdateWithoutClaimInput,
      ConsensusRunUncheckedUpdateWithoutClaimInput
    >;
  };

  export type ConsensusRunUpdateWithoutClaimInput = {
    method?: StringFieldUpdateOperationsInput | string;
    verdict?: StringFieldUpdateOperationsInput | string;
    confidence?: FloatFieldUpdateOperationsInput | number;
    balanceScore?: FloatFieldUpdateOperationsInput | number;
    diversityIndex?: FloatFieldUpdateOperationsInput | number;
    providers?: InputJsonValue | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ConsensusRunUncheckedUpdateWithoutClaimInput = {
    method?: StringFieldUpdateOperationsInput | string;
    verdict?: StringFieldUpdateOperationsInput | string;
    confidence?: FloatFieldUpdateOperationsInput | number;
    balanceScore?: FloatFieldUpdateOperationsInput | number;
    diversityIndex?: FloatFieldUpdateOperationsInput | number;
    providers?: InputJsonValue | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type VerdictVersionUpsertWithWhereUniqueWithoutClaimInput = {
    where: VerdictVersionWhereUniqueInput;
    update: XOR<
      VerdictVersionUpdateWithoutClaimInput,
      VerdictVersionUncheckedUpdateWithoutClaimInput
    >;
    create: XOR<
      VerdictVersionCreateWithoutClaimInput,
      VerdictVersionUncheckedCreateWithoutClaimInput
    >;
  };

  export type VerdictVersionUpdateWithWhereUniqueWithoutClaimInput = {
    where: VerdictVersionWhereUniqueInput;
    data: XOR<
      VerdictVersionUpdateWithoutClaimInput,
      VerdictVersionUncheckedUpdateWithoutClaimInput
    >;
  };

  export type VerdictVersionUpdateManyWithWhereWithoutClaimInput = {
    where: VerdictVersionScalarWhereInput;
    data: XOR<
      VerdictVersionUpdateManyMutationInput,
      VerdictVersionUncheckedUpdateManyWithoutClaimInput
    >;
  };

  export type VerdictVersionScalarWhereInput = {
    AND?: VerdictVersionScalarWhereInput | VerdictVersionScalarWhereInput[];
    OR?: VerdictVersionScalarWhereInput[];
    NOT?: VerdictVersionScalarWhereInput | VerdictVersionScalarWhereInput[];
    id?: StringFilter<"VerdictVersion"> | string;
    claimId?: StringFilter<"VerdictVersion"> | string;
    verdict?: StringFilter<"VerdictVersion"> | string;
    confidence?: FloatFilter<"VerdictVersion"> | number;
    asOf?: DateTimeFilter<"VerdictVersion"> | Date | string;
    supersedes?: StringNullableFilter<"VerdictVersion"> | string | null;
  };

  export type ExtractedUnitUpsertWithWhereUniqueWithoutClaimInput = {
    where: ExtractedUnitWhereUniqueInput;
    update: XOR<
      ExtractedUnitUpdateWithoutClaimInput,
      ExtractedUnitUncheckedUpdateWithoutClaimInput
    >;
    create: XOR<
      ExtractedUnitCreateWithoutClaimInput,
      ExtractedUnitUncheckedCreateWithoutClaimInput
    >;
  };

  export type ExtractedUnitUpdateWithWhereUniqueWithoutClaimInput = {
    where: ExtractedUnitWhereUniqueInput;
    data: XOR<
      ExtractedUnitUpdateWithoutClaimInput,
      ExtractedUnitUncheckedUpdateWithoutClaimInput
    >;
  };

  export type ExtractedUnitUpdateManyWithWhereWithoutClaimInput = {
    where: ExtractedUnitScalarWhereInput;
    data: XOR<
      ExtractedUnitUpdateManyMutationInput,
      ExtractedUnitUncheckedUpdateManyWithoutClaimInput
    >;
  };

  export type FindingUpsertWithoutClaimInput = {
    update: XOR<
      FindingUpdateWithoutClaimInput,
      FindingUncheckedUpdateWithoutClaimInput
    >;
    create: XOR<
      FindingCreateWithoutClaimInput,
      FindingUncheckedCreateWithoutClaimInput
    >;
    where?: FindingWhereInput;
  };

  export type FindingUpdateToOneWithWhereWithoutClaimInput = {
    where?: FindingWhereInput;
    data: XOR<
      FindingUpdateWithoutClaimInput,
      FindingUncheckedUpdateWithoutClaimInput
    >;
  };

  export type FindingUpdateWithoutClaimInput = {
    summary?: StringFieldUpdateOperationsInput | string;
    outcome?: StringFieldUpdateOperationsInput | string;
    rationale?: StringFieldUpdateOperationsInput | string;
    metrics?: InputJsonValue | InputJsonValue | null;
    comparedJurisdictions?: InputJsonValue | InputJsonValue | null;
    lastChecked?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type FindingUncheckedUpdateWithoutClaimInput = {
    summary?: StringFieldUpdateOperationsInput | string;
    outcome?: StringFieldUpdateOperationsInput | string;
    rationale?: StringFieldUpdateOperationsInput | string;
    metrics?: InputJsonValue | InputJsonValue | null;
    comparedJurisdictions?: InputJsonValue | InputJsonValue | null;
    lastChecked?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type FactcheckClaimCreateWithoutProviderRunsInput = {
    id?: string;
    text: string;
    language?: string | null;
    topic?: string | null;
    falsifiable?: boolean;
    frames?: FactcheckClaimCreateframesInput | string[];
    rhetoricalFlags?: FactcheckClaimCreaterhetoricalFlagsInput | string[];
    canonicalKey: string;
    scope?: string | null;
    timeframe?: string | null;
    status?: $Enums.ReviewStatus;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    job: FactcheckJobCreateNestedOneWithoutClaimsInput;
    evidences?: EvidenceCreateNestedManyWithoutClaimInput;
    consensus?: ConsensusRunCreateNestedOneWithoutClaimInput;
    verdictVersions?: VerdictVersionCreateNestedManyWithoutClaimInput;
    units?: ExtractedUnitCreateNestedManyWithoutClaimInput;
    finding?: FindingCreateNestedOneWithoutClaimInput;
  };

  export type FactcheckClaimUncheckedCreateWithoutProviderRunsInput = {
    id?: string;
    jobId: string;
    text: string;
    language?: string | null;
    topic?: string | null;
    falsifiable?: boolean;
    frames?: FactcheckClaimCreateframesInput | string[];
    rhetoricalFlags?: FactcheckClaimCreaterhetoricalFlagsInput | string[];
    canonicalKey: string;
    scope?: string | null;
    timeframe?: string | null;
    status?: $Enums.ReviewStatus;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    evidences?: EvidenceUncheckedCreateNestedManyWithoutClaimInput;
    consensus?: ConsensusRunUncheckedCreateNestedOneWithoutClaimInput;
    verdictVersions?: VerdictVersionUncheckedCreateNestedManyWithoutClaimInput;
    units?: ExtractedUnitUncheckedCreateNestedManyWithoutClaimInput;
    finding?: FindingUncheckedCreateNestedOneWithoutClaimInput;
  };

  export type FactcheckClaimCreateOrConnectWithoutProviderRunsInput = {
    where: FactcheckClaimWhereUniqueInput;
    create: XOR<
      FactcheckClaimCreateWithoutProviderRunsInput,
      FactcheckClaimUncheckedCreateWithoutProviderRunsInput
    >;
  };

  export type FactcheckClaimUpsertWithoutProviderRunsInput = {
    update: XOR<
      FactcheckClaimUpdateWithoutProviderRunsInput,
      FactcheckClaimUncheckedUpdateWithoutProviderRunsInput
    >;
    create: XOR<
      FactcheckClaimCreateWithoutProviderRunsInput,
      FactcheckClaimUncheckedCreateWithoutProviderRunsInput
    >;
    where?: FactcheckClaimWhereInput;
  };

  export type FactcheckClaimUpdateToOneWithWhereWithoutProviderRunsInput = {
    where?: FactcheckClaimWhereInput;
    data: XOR<
      FactcheckClaimUpdateWithoutProviderRunsInput,
      FactcheckClaimUncheckedUpdateWithoutProviderRunsInput
    >;
  };

  export type FactcheckClaimUpdateWithoutProviderRunsInput = {
    text?: StringFieldUpdateOperationsInput | string;
    language?: NullableStringFieldUpdateOperationsInput | string | null;
    topic?: NullableStringFieldUpdateOperationsInput | string | null;
    falsifiable?: BoolFieldUpdateOperationsInput | boolean;
    frames?: FactcheckClaimUpdateframesInput | string[];
    rhetoricalFlags?: FactcheckClaimUpdaterhetoricalFlagsInput | string[];
    canonicalKey?: StringFieldUpdateOperationsInput | string;
    scope?: NullableStringFieldUpdateOperationsInput | string | null;
    timeframe?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumReviewStatusFieldUpdateOperationsInput | $Enums.ReviewStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    job?: FactcheckJobUpdateOneRequiredWithoutClaimsNestedInput;
    evidences?: EvidenceUpdateManyWithoutClaimNestedInput;
    consensus?: ConsensusRunUpdateOneWithoutClaimNestedInput;
    verdictVersions?: VerdictVersionUpdateManyWithoutClaimNestedInput;
    units?: ExtractedUnitUpdateManyWithoutClaimNestedInput;
    finding?: FindingUpdateOneWithoutClaimNestedInput;
  };

  export type FactcheckClaimUncheckedUpdateWithoutProviderRunsInput = {
    jobId?: StringFieldUpdateOperationsInput | string;
    text?: StringFieldUpdateOperationsInput | string;
    language?: NullableStringFieldUpdateOperationsInput | string | null;
    topic?: NullableStringFieldUpdateOperationsInput | string | null;
    falsifiable?: BoolFieldUpdateOperationsInput | boolean;
    frames?: FactcheckClaimUpdateframesInput | string[];
    rhetoricalFlags?: FactcheckClaimUpdaterhetoricalFlagsInput | string[];
    canonicalKey?: StringFieldUpdateOperationsInput | string;
    scope?: NullableStringFieldUpdateOperationsInput | string | null;
    timeframe?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumReviewStatusFieldUpdateOperationsInput | $Enums.ReviewStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    evidences?: EvidenceUncheckedUpdateManyWithoutClaimNestedInput;
    consensus?: ConsensusRunUncheckedUpdateOneWithoutClaimNestedInput;
    verdictVersions?: VerdictVersionUncheckedUpdateManyWithoutClaimNestedInput;
    units?: ExtractedUnitUncheckedUpdateManyWithoutClaimNestedInput;
    finding?: FindingUncheckedUpdateOneWithoutClaimNestedInput;
  };

  export type FactcheckClaimCreateWithoutConsensusInput = {
    id?: string;
    text: string;
    language?: string | null;
    topic?: string | null;
    falsifiable?: boolean;
    frames?: FactcheckClaimCreateframesInput | string[];
    rhetoricalFlags?: FactcheckClaimCreaterhetoricalFlagsInput | string[];
    canonicalKey: string;
    scope?: string | null;
    timeframe?: string | null;
    status?: $Enums.ReviewStatus;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    job: FactcheckJobCreateNestedOneWithoutClaimsInput;
    providerRuns?: ProviderRunCreateNestedManyWithoutClaimInput;
    evidences?: EvidenceCreateNestedManyWithoutClaimInput;
    verdictVersions?: VerdictVersionCreateNestedManyWithoutClaimInput;
    units?: ExtractedUnitCreateNestedManyWithoutClaimInput;
    finding?: FindingCreateNestedOneWithoutClaimInput;
  };

  export type FactcheckClaimUncheckedCreateWithoutConsensusInput = {
    id?: string;
    jobId: string;
    text: string;
    language?: string | null;
    topic?: string | null;
    falsifiable?: boolean;
    frames?: FactcheckClaimCreateframesInput | string[];
    rhetoricalFlags?: FactcheckClaimCreaterhetoricalFlagsInput | string[];
    canonicalKey: string;
    scope?: string | null;
    timeframe?: string | null;
    status?: $Enums.ReviewStatus;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    providerRuns?: ProviderRunUncheckedCreateNestedManyWithoutClaimInput;
    evidences?: EvidenceUncheckedCreateNestedManyWithoutClaimInput;
    verdictVersions?: VerdictVersionUncheckedCreateNestedManyWithoutClaimInput;
    units?: ExtractedUnitUncheckedCreateNestedManyWithoutClaimInput;
    finding?: FindingUncheckedCreateNestedOneWithoutClaimInput;
  };

  export type FactcheckClaimCreateOrConnectWithoutConsensusInput = {
    where: FactcheckClaimWhereUniqueInput;
    create: XOR<
      FactcheckClaimCreateWithoutConsensusInput,
      FactcheckClaimUncheckedCreateWithoutConsensusInput
    >;
  };

  export type FactcheckClaimUpsertWithoutConsensusInput = {
    update: XOR<
      FactcheckClaimUpdateWithoutConsensusInput,
      FactcheckClaimUncheckedUpdateWithoutConsensusInput
    >;
    create: XOR<
      FactcheckClaimCreateWithoutConsensusInput,
      FactcheckClaimUncheckedCreateWithoutConsensusInput
    >;
    where?: FactcheckClaimWhereInput;
  };

  export type FactcheckClaimUpdateToOneWithWhereWithoutConsensusInput = {
    where?: FactcheckClaimWhereInput;
    data: XOR<
      FactcheckClaimUpdateWithoutConsensusInput,
      FactcheckClaimUncheckedUpdateWithoutConsensusInput
    >;
  };

  export type FactcheckClaimUpdateWithoutConsensusInput = {
    text?: StringFieldUpdateOperationsInput | string;
    language?: NullableStringFieldUpdateOperationsInput | string | null;
    topic?: NullableStringFieldUpdateOperationsInput | string | null;
    falsifiable?: BoolFieldUpdateOperationsInput | boolean;
    frames?: FactcheckClaimUpdateframesInput | string[];
    rhetoricalFlags?: FactcheckClaimUpdaterhetoricalFlagsInput | string[];
    canonicalKey?: StringFieldUpdateOperationsInput | string;
    scope?: NullableStringFieldUpdateOperationsInput | string | null;
    timeframe?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumReviewStatusFieldUpdateOperationsInput | $Enums.ReviewStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    job?: FactcheckJobUpdateOneRequiredWithoutClaimsNestedInput;
    providerRuns?: ProviderRunUpdateManyWithoutClaimNestedInput;
    evidences?: EvidenceUpdateManyWithoutClaimNestedInput;
    verdictVersions?: VerdictVersionUpdateManyWithoutClaimNestedInput;
    units?: ExtractedUnitUpdateManyWithoutClaimNestedInput;
    finding?: FindingUpdateOneWithoutClaimNestedInput;
  };

  export type FactcheckClaimUncheckedUpdateWithoutConsensusInput = {
    jobId?: StringFieldUpdateOperationsInput | string;
    text?: StringFieldUpdateOperationsInput | string;
    language?: NullableStringFieldUpdateOperationsInput | string | null;
    topic?: NullableStringFieldUpdateOperationsInput | string | null;
    falsifiable?: BoolFieldUpdateOperationsInput | boolean;
    frames?: FactcheckClaimUpdateframesInput | string[];
    rhetoricalFlags?: FactcheckClaimUpdaterhetoricalFlagsInput | string[];
    canonicalKey?: StringFieldUpdateOperationsInput | string;
    scope?: NullableStringFieldUpdateOperationsInput | string | null;
    timeframe?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumReviewStatusFieldUpdateOperationsInput | $Enums.ReviewStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    providerRuns?: ProviderRunUncheckedUpdateManyWithoutClaimNestedInput;
    evidences?: EvidenceUncheckedUpdateManyWithoutClaimNestedInput;
    verdictVersions?: VerdictVersionUncheckedUpdateManyWithoutClaimNestedInput;
    units?: ExtractedUnitUncheckedUpdateManyWithoutClaimNestedInput;
    finding?: FindingUncheckedUpdateOneWithoutClaimNestedInput;
  };

  export type FactcheckClaimCreateWithoutEvidencesInput = {
    id?: string;
    text: string;
    language?: string | null;
    topic?: string | null;
    falsifiable?: boolean;
    frames?: FactcheckClaimCreateframesInput | string[];
    rhetoricalFlags?: FactcheckClaimCreaterhetoricalFlagsInput | string[];
    canonicalKey: string;
    scope?: string | null;
    timeframe?: string | null;
    status?: $Enums.ReviewStatus;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    job: FactcheckJobCreateNestedOneWithoutClaimsInput;
    providerRuns?: ProviderRunCreateNestedManyWithoutClaimInput;
    consensus?: ConsensusRunCreateNestedOneWithoutClaimInput;
    verdictVersions?: VerdictVersionCreateNestedManyWithoutClaimInput;
    units?: ExtractedUnitCreateNestedManyWithoutClaimInput;
    finding?: FindingCreateNestedOneWithoutClaimInput;
  };

  export type FactcheckClaimUncheckedCreateWithoutEvidencesInput = {
    id?: string;
    jobId: string;
    text: string;
    language?: string | null;
    topic?: string | null;
    falsifiable?: boolean;
    frames?: FactcheckClaimCreateframesInput | string[];
    rhetoricalFlags?: FactcheckClaimCreaterhetoricalFlagsInput | string[];
    canonicalKey: string;
    scope?: string | null;
    timeframe?: string | null;
    status?: $Enums.ReviewStatus;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    providerRuns?: ProviderRunUncheckedCreateNestedManyWithoutClaimInput;
    consensus?: ConsensusRunUncheckedCreateNestedOneWithoutClaimInput;
    verdictVersions?: VerdictVersionUncheckedCreateNestedManyWithoutClaimInput;
    units?: ExtractedUnitUncheckedCreateNestedManyWithoutClaimInput;
    finding?: FindingUncheckedCreateNestedOneWithoutClaimInput;
  };

  export type FactcheckClaimCreateOrConnectWithoutEvidencesInput = {
    where: FactcheckClaimWhereUniqueInput;
    create: XOR<
      FactcheckClaimCreateWithoutEvidencesInput,
      FactcheckClaimUncheckedCreateWithoutEvidencesInput
    >;
  };

  export type FactcheckClaimUpsertWithoutEvidencesInput = {
    update: XOR<
      FactcheckClaimUpdateWithoutEvidencesInput,
      FactcheckClaimUncheckedUpdateWithoutEvidencesInput
    >;
    create: XOR<
      FactcheckClaimCreateWithoutEvidencesInput,
      FactcheckClaimUncheckedCreateWithoutEvidencesInput
    >;
    where?: FactcheckClaimWhereInput;
  };

  export type FactcheckClaimUpdateToOneWithWhereWithoutEvidencesInput = {
    where?: FactcheckClaimWhereInput;
    data: XOR<
      FactcheckClaimUpdateWithoutEvidencesInput,
      FactcheckClaimUncheckedUpdateWithoutEvidencesInput
    >;
  };

  export type FactcheckClaimUpdateWithoutEvidencesInput = {
    text?: StringFieldUpdateOperationsInput | string;
    language?: NullableStringFieldUpdateOperationsInput | string | null;
    topic?: NullableStringFieldUpdateOperationsInput | string | null;
    falsifiable?: BoolFieldUpdateOperationsInput | boolean;
    frames?: FactcheckClaimUpdateframesInput | string[];
    rhetoricalFlags?: FactcheckClaimUpdaterhetoricalFlagsInput | string[];
    canonicalKey?: StringFieldUpdateOperationsInput | string;
    scope?: NullableStringFieldUpdateOperationsInput | string | null;
    timeframe?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumReviewStatusFieldUpdateOperationsInput | $Enums.ReviewStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    job?: FactcheckJobUpdateOneRequiredWithoutClaimsNestedInput;
    providerRuns?: ProviderRunUpdateManyWithoutClaimNestedInput;
    consensus?: ConsensusRunUpdateOneWithoutClaimNestedInput;
    verdictVersions?: VerdictVersionUpdateManyWithoutClaimNestedInput;
    units?: ExtractedUnitUpdateManyWithoutClaimNestedInput;
    finding?: FindingUpdateOneWithoutClaimNestedInput;
  };

  export type FactcheckClaimUncheckedUpdateWithoutEvidencesInput = {
    jobId?: StringFieldUpdateOperationsInput | string;
    text?: StringFieldUpdateOperationsInput | string;
    language?: NullableStringFieldUpdateOperationsInput | string | null;
    topic?: NullableStringFieldUpdateOperationsInput | string | null;
    falsifiable?: BoolFieldUpdateOperationsInput | boolean;
    frames?: FactcheckClaimUpdateframesInput | string[];
    rhetoricalFlags?: FactcheckClaimUpdaterhetoricalFlagsInput | string[];
    canonicalKey?: StringFieldUpdateOperationsInput | string;
    scope?: NullableStringFieldUpdateOperationsInput | string | null;
    timeframe?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumReviewStatusFieldUpdateOperationsInput | $Enums.ReviewStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    providerRuns?: ProviderRunUncheckedUpdateManyWithoutClaimNestedInput;
    consensus?: ConsensusRunUncheckedUpdateOneWithoutClaimNestedInput;
    verdictVersions?: VerdictVersionUncheckedUpdateManyWithoutClaimNestedInput;
    units?: ExtractedUnitUncheckedUpdateManyWithoutClaimNestedInput;
    finding?: FindingUncheckedUpdateOneWithoutClaimNestedInput;
  };

  export type FactcheckClaimCreateWithoutVerdictVersionsInput = {
    id?: string;
    text: string;
    language?: string | null;
    topic?: string | null;
    falsifiable?: boolean;
    frames?: FactcheckClaimCreateframesInput | string[];
    rhetoricalFlags?: FactcheckClaimCreaterhetoricalFlagsInput | string[];
    canonicalKey: string;
    scope?: string | null;
    timeframe?: string | null;
    status?: $Enums.ReviewStatus;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    job: FactcheckJobCreateNestedOneWithoutClaimsInput;
    providerRuns?: ProviderRunCreateNestedManyWithoutClaimInput;
    evidences?: EvidenceCreateNestedManyWithoutClaimInput;
    consensus?: ConsensusRunCreateNestedOneWithoutClaimInput;
    units?: ExtractedUnitCreateNestedManyWithoutClaimInput;
    finding?: FindingCreateNestedOneWithoutClaimInput;
  };

  export type FactcheckClaimUncheckedCreateWithoutVerdictVersionsInput = {
    id?: string;
    jobId: string;
    text: string;
    language?: string | null;
    topic?: string | null;
    falsifiable?: boolean;
    frames?: FactcheckClaimCreateframesInput | string[];
    rhetoricalFlags?: FactcheckClaimCreaterhetoricalFlagsInput | string[];
    canonicalKey: string;
    scope?: string | null;
    timeframe?: string | null;
    status?: $Enums.ReviewStatus;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    providerRuns?: ProviderRunUncheckedCreateNestedManyWithoutClaimInput;
    evidences?: EvidenceUncheckedCreateNestedManyWithoutClaimInput;
    consensus?: ConsensusRunUncheckedCreateNestedOneWithoutClaimInput;
    units?: ExtractedUnitUncheckedCreateNestedManyWithoutClaimInput;
    finding?: FindingUncheckedCreateNestedOneWithoutClaimInput;
  };

  export type FactcheckClaimCreateOrConnectWithoutVerdictVersionsInput = {
    where: FactcheckClaimWhereUniqueInput;
    create: XOR<
      FactcheckClaimCreateWithoutVerdictVersionsInput,
      FactcheckClaimUncheckedCreateWithoutVerdictVersionsInput
    >;
  };

  export type FactcheckClaimUpsertWithoutVerdictVersionsInput = {
    update: XOR<
      FactcheckClaimUpdateWithoutVerdictVersionsInput,
      FactcheckClaimUncheckedUpdateWithoutVerdictVersionsInput
    >;
    create: XOR<
      FactcheckClaimCreateWithoutVerdictVersionsInput,
      FactcheckClaimUncheckedCreateWithoutVerdictVersionsInput
    >;
    where?: FactcheckClaimWhereInput;
  };

  export type FactcheckClaimUpdateToOneWithWhereWithoutVerdictVersionsInput = {
    where?: FactcheckClaimWhereInput;
    data: XOR<
      FactcheckClaimUpdateWithoutVerdictVersionsInput,
      FactcheckClaimUncheckedUpdateWithoutVerdictVersionsInput
    >;
  };

  export type FactcheckClaimUpdateWithoutVerdictVersionsInput = {
    text?: StringFieldUpdateOperationsInput | string;
    language?: NullableStringFieldUpdateOperationsInput | string | null;
    topic?: NullableStringFieldUpdateOperationsInput | string | null;
    falsifiable?: BoolFieldUpdateOperationsInput | boolean;
    frames?: FactcheckClaimUpdateframesInput | string[];
    rhetoricalFlags?: FactcheckClaimUpdaterhetoricalFlagsInput | string[];
    canonicalKey?: StringFieldUpdateOperationsInput | string;
    scope?: NullableStringFieldUpdateOperationsInput | string | null;
    timeframe?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumReviewStatusFieldUpdateOperationsInput | $Enums.ReviewStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    job?: FactcheckJobUpdateOneRequiredWithoutClaimsNestedInput;
    providerRuns?: ProviderRunUpdateManyWithoutClaimNestedInput;
    evidences?: EvidenceUpdateManyWithoutClaimNestedInput;
    consensus?: ConsensusRunUpdateOneWithoutClaimNestedInput;
    units?: ExtractedUnitUpdateManyWithoutClaimNestedInput;
    finding?: FindingUpdateOneWithoutClaimNestedInput;
  };

  export type FactcheckClaimUncheckedUpdateWithoutVerdictVersionsInput = {
    jobId?: StringFieldUpdateOperationsInput | string;
    text?: StringFieldUpdateOperationsInput | string;
    language?: NullableStringFieldUpdateOperationsInput | string | null;
    topic?: NullableStringFieldUpdateOperationsInput | string | null;
    falsifiable?: BoolFieldUpdateOperationsInput | boolean;
    frames?: FactcheckClaimUpdateframesInput | string[];
    rhetoricalFlags?: FactcheckClaimUpdaterhetoricalFlagsInput | string[];
    canonicalKey?: StringFieldUpdateOperationsInput | string;
    scope?: NullableStringFieldUpdateOperationsInput | string | null;
    timeframe?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumReviewStatusFieldUpdateOperationsInput | $Enums.ReviewStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    providerRuns?: ProviderRunUncheckedUpdateManyWithoutClaimNestedInput;
    evidences?: EvidenceUncheckedUpdateManyWithoutClaimNestedInput;
    consensus?: ConsensusRunUncheckedUpdateOneWithoutClaimNestedInput;
    units?: ExtractedUnitUncheckedUpdateManyWithoutClaimNestedInput;
    finding?: FindingUncheckedUpdateOneWithoutClaimNestedInput;
  };

  export type FactcheckJobCreateWithoutResultsInput = {
    id?: string;
    jobId: string;
    contributionId: string;
    status: string;
    tokensUsed?: number;
    durationMs?: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    claims?: FactcheckClaimCreateNestedManyWithoutJobInput;
  };

  export type FactcheckJobUncheckedCreateWithoutResultsInput = {
    id?: string;
    jobId: string;
    contributionId: string;
    status: string;
    tokensUsed?: number;
    durationMs?: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    claims?: FactcheckClaimUncheckedCreateNestedManyWithoutJobInput;
  };

  export type FactcheckJobCreateOrConnectWithoutResultsInput = {
    where: FactcheckJobWhereUniqueInput;
    create: XOR<
      FactcheckJobCreateWithoutResultsInput,
      FactcheckJobUncheckedCreateWithoutResultsInput
    >;
  };

  export type FactcheckJobUpsertWithoutResultsInput = {
    update: XOR<
      FactcheckJobUpdateWithoutResultsInput,
      FactcheckJobUncheckedUpdateWithoutResultsInput
    >;
    create: XOR<
      FactcheckJobCreateWithoutResultsInput,
      FactcheckJobUncheckedCreateWithoutResultsInput
    >;
    where?: FactcheckJobWhereInput;
  };

  export type FactcheckJobUpdateToOneWithWhereWithoutResultsInput = {
    where?: FactcheckJobWhereInput;
    data: XOR<
      FactcheckJobUpdateWithoutResultsInput,
      FactcheckJobUncheckedUpdateWithoutResultsInput
    >;
  };

  export type FactcheckJobUpdateWithoutResultsInput = {
    jobId?: StringFieldUpdateOperationsInput | string;
    contributionId?: StringFieldUpdateOperationsInput | string;
    status?: StringFieldUpdateOperationsInput | string;
    tokensUsed?: IntFieldUpdateOperationsInput | number;
    durationMs?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    claims?: FactcheckClaimUpdateManyWithoutJobNestedInput;
  };

  export type FactcheckJobUncheckedUpdateWithoutResultsInput = {
    jobId?: StringFieldUpdateOperationsInput | string;
    contributionId?: StringFieldUpdateOperationsInput | string;
    status?: StringFieldUpdateOperationsInput | string;
    tokensUsed?: IntFieldUpdateOperationsInput | number;
    durationMs?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    claims?: FactcheckClaimUncheckedUpdateManyWithoutJobNestedInput;
  };

  export type ContentItemCreateWithoutUnitsInput = {
    id?: string;
    kind: $Enums.ContentKind;
    locale?: $Enums.Locale;
    title?: string | null;
    text: string;
    richText?: string | null;
    sortOrder?: number;
    status?: $Enums.PublishStatus;
    authorName?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    publishAt?: Date | string | null;
    expireAt?: Date | string | null;
    regionMode?: $Enums.RegionMode;
    regionAuto?: InputJsonValue | null;
    validation?: InputJsonValue | null;
    meta?: InputJsonValue | null;
    topic: TopicCreateNestedOneWithoutItemsInput;
    regionManual?: RegionCreateNestedOneWithoutItemsManualInput;
    regionEffective?: RegionCreateNestedOneWithoutItemsEffectiveInput;
    answerOptions?: AnswerOptionCreateNestedManyWithoutItemInput;
    tags?: ItemTagCreateNestedManyWithoutItemInput;
  };

  export type ContentItemUncheckedCreateWithoutUnitsInput = {
    id?: string;
    kind: $Enums.ContentKind;
    topicId: string;
    locale?: $Enums.Locale;
    title?: string | null;
    text: string;
    richText?: string | null;
    sortOrder?: number;
    status?: $Enums.PublishStatus;
    authorName?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    publishAt?: Date | string | null;
    expireAt?: Date | string | null;
    regionMode?: $Enums.RegionMode;
    regionManualId?: string | null;
    regionAuto?: InputJsonValue | null;
    regionEffectiveId?: string | null;
    validation?: InputJsonValue | null;
    meta?: InputJsonValue | null;
    answerOptions?: AnswerOptionUncheckedCreateNestedManyWithoutItemInput;
    tags?: ItemTagUncheckedCreateNestedManyWithoutItemInput;
  };

  export type ContentItemCreateOrConnectWithoutUnitsInput = {
    where: ContentItemWhereUniqueInput;
    create: XOR<
      ContentItemCreateWithoutUnitsInput,
      ContentItemUncheckedCreateWithoutUnitsInput
    >;
  };

  export type FactcheckClaimCreateWithoutUnitsInput = {
    id?: string;
    text: string;
    language?: string | null;
    topic?: string | null;
    falsifiable?: boolean;
    frames?: FactcheckClaimCreateframesInput | string[];
    rhetoricalFlags?: FactcheckClaimCreaterhetoricalFlagsInput | string[];
    canonicalKey: string;
    scope?: string | null;
    timeframe?: string | null;
    status?: $Enums.ReviewStatus;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    job: FactcheckJobCreateNestedOneWithoutClaimsInput;
    providerRuns?: ProviderRunCreateNestedManyWithoutClaimInput;
    evidences?: EvidenceCreateNestedManyWithoutClaimInput;
    consensus?: ConsensusRunCreateNestedOneWithoutClaimInput;
    verdictVersions?: VerdictVersionCreateNestedManyWithoutClaimInput;
    finding?: FindingCreateNestedOneWithoutClaimInput;
  };

  export type FactcheckClaimUncheckedCreateWithoutUnitsInput = {
    id?: string;
    jobId: string;
    text: string;
    language?: string | null;
    topic?: string | null;
    falsifiable?: boolean;
    frames?: FactcheckClaimCreateframesInput | string[];
    rhetoricalFlags?: FactcheckClaimCreaterhetoricalFlagsInput | string[];
    canonicalKey: string;
    scope?: string | null;
    timeframe?: string | null;
    status?: $Enums.ReviewStatus;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    providerRuns?: ProviderRunUncheckedCreateNestedManyWithoutClaimInput;
    evidences?: EvidenceUncheckedCreateNestedManyWithoutClaimInput;
    consensus?: ConsensusRunUncheckedCreateNestedOneWithoutClaimInput;
    verdictVersions?: VerdictVersionUncheckedCreateNestedManyWithoutClaimInput;
    finding?: FindingUncheckedCreateNestedOneWithoutClaimInput;
  };

  export type FactcheckClaimCreateOrConnectWithoutUnitsInput = {
    where: FactcheckClaimWhereUniqueInput;
    create: XOR<
      FactcheckClaimCreateWithoutUnitsInput,
      FactcheckClaimUncheckedCreateWithoutUnitsInput
    >;
  };

  export type ContentItemUpsertWithoutUnitsInput = {
    update: XOR<
      ContentItemUpdateWithoutUnitsInput,
      ContentItemUncheckedUpdateWithoutUnitsInput
    >;
    create: XOR<
      ContentItemCreateWithoutUnitsInput,
      ContentItemUncheckedCreateWithoutUnitsInput
    >;
    where?: ContentItemWhereInput;
  };

  export type ContentItemUpdateToOneWithWhereWithoutUnitsInput = {
    where?: ContentItemWhereInput;
    data: XOR<
      ContentItemUpdateWithoutUnitsInput,
      ContentItemUncheckedUpdateWithoutUnitsInput
    >;
  };

  export type ContentItemUpdateWithoutUnitsInput = {
    kind?: EnumContentKindFieldUpdateOperationsInput | $Enums.ContentKind;
    locale?: EnumLocaleFieldUpdateOperationsInput | $Enums.Locale;
    title?: NullableStringFieldUpdateOperationsInput | string | null;
    text?: StringFieldUpdateOperationsInput | string;
    richText?: NullableStringFieldUpdateOperationsInput | string | null;
    sortOrder?: IntFieldUpdateOperationsInput | number;
    status?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus;
    authorName?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    publishAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    expireAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    regionMode?: EnumRegionModeFieldUpdateOperationsInput | $Enums.RegionMode;
    regionAuto?: InputJsonValue | InputJsonValue | null;
    validation?: InputJsonValue | InputJsonValue | null;
    meta?: InputJsonValue | InputJsonValue | null;
    topic?: TopicUpdateOneRequiredWithoutItemsNestedInput;
    regionManual?: RegionUpdateOneWithoutItemsManualNestedInput;
    regionEffective?: RegionUpdateOneWithoutItemsEffectiveNestedInput;
    answerOptions?: AnswerOptionUpdateManyWithoutItemNestedInput;
    tags?: ItemTagUpdateManyWithoutItemNestedInput;
  };

  export type ContentItemUncheckedUpdateWithoutUnitsInput = {
    kind?: EnumContentKindFieldUpdateOperationsInput | $Enums.ContentKind;
    topicId?: StringFieldUpdateOperationsInput | string;
    locale?: EnumLocaleFieldUpdateOperationsInput | $Enums.Locale;
    title?: NullableStringFieldUpdateOperationsInput | string | null;
    text?: StringFieldUpdateOperationsInput | string;
    richText?: NullableStringFieldUpdateOperationsInput | string | null;
    sortOrder?: IntFieldUpdateOperationsInput | number;
    status?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus;
    authorName?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    publishAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    expireAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    regionMode?: EnumRegionModeFieldUpdateOperationsInput | $Enums.RegionMode;
    regionManualId?: NullableStringFieldUpdateOperationsInput | string | null;
    regionAuto?: InputJsonValue | InputJsonValue | null;
    regionEffectiveId?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    validation?: InputJsonValue | InputJsonValue | null;
    meta?: InputJsonValue | InputJsonValue | null;
    answerOptions?: AnswerOptionUncheckedUpdateManyWithoutItemNestedInput;
    tags?: ItemTagUncheckedUpdateManyWithoutItemNestedInput;
  };

  export type FactcheckClaimUpsertWithoutUnitsInput = {
    update: XOR<
      FactcheckClaimUpdateWithoutUnitsInput,
      FactcheckClaimUncheckedUpdateWithoutUnitsInput
    >;
    create: XOR<
      FactcheckClaimCreateWithoutUnitsInput,
      FactcheckClaimUncheckedCreateWithoutUnitsInput
    >;
    where?: FactcheckClaimWhereInput;
  };

  export type FactcheckClaimUpdateToOneWithWhereWithoutUnitsInput = {
    where?: FactcheckClaimWhereInput;
    data: XOR<
      FactcheckClaimUpdateWithoutUnitsInput,
      FactcheckClaimUncheckedUpdateWithoutUnitsInput
    >;
  };

  export type FactcheckClaimUpdateWithoutUnitsInput = {
    text?: StringFieldUpdateOperationsInput | string;
    language?: NullableStringFieldUpdateOperationsInput | string | null;
    topic?: NullableStringFieldUpdateOperationsInput | string | null;
    falsifiable?: BoolFieldUpdateOperationsInput | boolean;
    frames?: FactcheckClaimUpdateframesInput | string[];
    rhetoricalFlags?: FactcheckClaimUpdaterhetoricalFlagsInput | string[];
    canonicalKey?: StringFieldUpdateOperationsInput | string;
    scope?: NullableStringFieldUpdateOperationsInput | string | null;
    timeframe?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumReviewStatusFieldUpdateOperationsInput | $Enums.ReviewStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    job?: FactcheckJobUpdateOneRequiredWithoutClaimsNestedInput;
    providerRuns?: ProviderRunUpdateManyWithoutClaimNestedInput;
    evidences?: EvidenceUpdateManyWithoutClaimNestedInput;
    consensus?: ConsensusRunUpdateOneWithoutClaimNestedInput;
    verdictVersions?: VerdictVersionUpdateManyWithoutClaimNestedInput;
    finding?: FindingUpdateOneWithoutClaimNestedInput;
  };

  export type FactcheckClaimUncheckedUpdateWithoutUnitsInput = {
    jobId?: StringFieldUpdateOperationsInput | string;
    text?: StringFieldUpdateOperationsInput | string;
    language?: NullableStringFieldUpdateOperationsInput | string | null;
    topic?: NullableStringFieldUpdateOperationsInput | string | null;
    falsifiable?: BoolFieldUpdateOperationsInput | boolean;
    frames?: FactcheckClaimUpdateframesInput | string[];
    rhetoricalFlags?: FactcheckClaimUpdaterhetoricalFlagsInput | string[];
    canonicalKey?: StringFieldUpdateOperationsInput | string;
    scope?: NullableStringFieldUpdateOperationsInput | string | null;
    timeframe?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumReviewStatusFieldUpdateOperationsInput | $Enums.ReviewStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    providerRuns?: ProviderRunUncheckedUpdateManyWithoutClaimNestedInput;
    evidences?: EvidenceUncheckedUpdateManyWithoutClaimNestedInput;
    consensus?: ConsensusRunUncheckedUpdateOneWithoutClaimNestedInput;
    verdictVersions?: VerdictVersionUncheckedUpdateManyWithoutClaimNestedInput;
    finding?: FindingUncheckedUpdateOneWithoutClaimNestedInput;
  };

  export type FactcheckClaimCreateWithoutFindingInput = {
    id?: string;
    text: string;
    language?: string | null;
    topic?: string | null;
    falsifiable?: boolean;
    frames?: FactcheckClaimCreateframesInput | string[];
    rhetoricalFlags?: FactcheckClaimCreaterhetoricalFlagsInput | string[];
    canonicalKey: string;
    scope?: string | null;
    timeframe?: string | null;
    status?: $Enums.ReviewStatus;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    job: FactcheckJobCreateNestedOneWithoutClaimsInput;
    providerRuns?: ProviderRunCreateNestedManyWithoutClaimInput;
    evidences?: EvidenceCreateNestedManyWithoutClaimInput;
    consensus?: ConsensusRunCreateNestedOneWithoutClaimInput;
    verdictVersions?: VerdictVersionCreateNestedManyWithoutClaimInput;
    units?: ExtractedUnitCreateNestedManyWithoutClaimInput;
  };

  export type FactcheckClaimUncheckedCreateWithoutFindingInput = {
    id?: string;
    jobId: string;
    text: string;
    language?: string | null;
    topic?: string | null;
    falsifiable?: boolean;
    frames?: FactcheckClaimCreateframesInput | string[];
    rhetoricalFlags?: FactcheckClaimCreaterhetoricalFlagsInput | string[];
    canonicalKey: string;
    scope?: string | null;
    timeframe?: string | null;
    status?: $Enums.ReviewStatus;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    providerRuns?: ProviderRunUncheckedCreateNestedManyWithoutClaimInput;
    evidences?: EvidenceUncheckedCreateNestedManyWithoutClaimInput;
    consensus?: ConsensusRunUncheckedCreateNestedOneWithoutClaimInput;
    verdictVersions?: VerdictVersionUncheckedCreateNestedManyWithoutClaimInput;
    units?: ExtractedUnitUncheckedCreateNestedManyWithoutClaimInput;
  };

  export type FactcheckClaimCreateOrConnectWithoutFindingInput = {
    where: FactcheckClaimWhereUniqueInput;
    create: XOR<
      FactcheckClaimCreateWithoutFindingInput,
      FactcheckClaimUncheckedCreateWithoutFindingInput
    >;
  };

  export type FactcheckClaimUpsertWithoutFindingInput = {
    update: XOR<
      FactcheckClaimUpdateWithoutFindingInput,
      FactcheckClaimUncheckedUpdateWithoutFindingInput
    >;
    create: XOR<
      FactcheckClaimCreateWithoutFindingInput,
      FactcheckClaimUncheckedCreateWithoutFindingInput
    >;
    where?: FactcheckClaimWhereInput;
  };

  export type FactcheckClaimUpdateToOneWithWhereWithoutFindingInput = {
    where?: FactcheckClaimWhereInput;
    data: XOR<
      FactcheckClaimUpdateWithoutFindingInput,
      FactcheckClaimUncheckedUpdateWithoutFindingInput
    >;
  };

  export type FactcheckClaimUpdateWithoutFindingInput = {
    text?: StringFieldUpdateOperationsInput | string;
    language?: NullableStringFieldUpdateOperationsInput | string | null;
    topic?: NullableStringFieldUpdateOperationsInput | string | null;
    falsifiable?: BoolFieldUpdateOperationsInput | boolean;
    frames?: FactcheckClaimUpdateframesInput | string[];
    rhetoricalFlags?: FactcheckClaimUpdaterhetoricalFlagsInput | string[];
    canonicalKey?: StringFieldUpdateOperationsInput | string;
    scope?: NullableStringFieldUpdateOperationsInput | string | null;
    timeframe?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumReviewStatusFieldUpdateOperationsInput | $Enums.ReviewStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    job?: FactcheckJobUpdateOneRequiredWithoutClaimsNestedInput;
    providerRuns?: ProviderRunUpdateManyWithoutClaimNestedInput;
    evidences?: EvidenceUpdateManyWithoutClaimNestedInput;
    consensus?: ConsensusRunUpdateOneWithoutClaimNestedInput;
    verdictVersions?: VerdictVersionUpdateManyWithoutClaimNestedInput;
    units?: ExtractedUnitUpdateManyWithoutClaimNestedInput;
  };

  export type FactcheckClaimUncheckedUpdateWithoutFindingInput = {
    jobId?: StringFieldUpdateOperationsInput | string;
    text?: StringFieldUpdateOperationsInput | string;
    language?: NullableStringFieldUpdateOperationsInput | string | null;
    topic?: NullableStringFieldUpdateOperationsInput | string | null;
    falsifiable?: BoolFieldUpdateOperationsInput | boolean;
    frames?: FactcheckClaimUpdateframesInput | string[];
    rhetoricalFlags?: FactcheckClaimUpdaterhetoricalFlagsInput | string[];
    canonicalKey?: StringFieldUpdateOperationsInput | string;
    scope?: NullableStringFieldUpdateOperationsInput | string | null;
    timeframe?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumReviewStatusFieldUpdateOperationsInput | $Enums.ReviewStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    providerRuns?: ProviderRunUncheckedUpdateManyWithoutClaimNestedInput;
    evidences?: EvidenceUncheckedUpdateManyWithoutClaimNestedInput;
    consensus?: ConsensusRunUncheckedUpdateOneWithoutClaimNestedInput;
    verdictVersions?: VerdictVersionUncheckedUpdateManyWithoutClaimNestedInput;
    units?: ExtractedUnitUncheckedUpdateManyWithoutClaimNestedInput;
  };

  export type ContentItemCreateManyTopicInput = {
    id?: string;
    kind: $Enums.ContentKind;
    locale?: $Enums.Locale;
    title?: string | null;
    text: string;
    richText?: string | null;
    sortOrder?: number;
    status?: $Enums.PublishStatus;
    authorName?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    publishAt?: Date | string | null;
    expireAt?: Date | string | null;
    regionMode?: $Enums.RegionMode;
    regionManualId?: string | null;
    regionAuto?: InputJsonValue | null;
    regionEffectiveId?: string | null;
    validation?: InputJsonValue | null;
    meta?: InputJsonValue | null;
  };

  export type TopicTagCreateManyTopicInput = {
    id?: string;
    tagId: string;
  };

  export type ContentItemUpdateWithoutTopicInput = {
    kind?: EnumContentKindFieldUpdateOperationsInput | $Enums.ContentKind;
    locale?: EnumLocaleFieldUpdateOperationsInput | $Enums.Locale;
    title?: NullableStringFieldUpdateOperationsInput | string | null;
    text?: StringFieldUpdateOperationsInput | string;
    richText?: NullableStringFieldUpdateOperationsInput | string | null;
    sortOrder?: IntFieldUpdateOperationsInput | number;
    status?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus;
    authorName?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    publishAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    expireAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    regionMode?: EnumRegionModeFieldUpdateOperationsInput | $Enums.RegionMode;
    regionAuto?: InputJsonValue | InputJsonValue | null;
    validation?: InputJsonValue | InputJsonValue | null;
    meta?: InputJsonValue | InputJsonValue | null;
    units?: ExtractedUnitUpdateManyWithoutItemNestedInput;
    regionManual?: RegionUpdateOneWithoutItemsManualNestedInput;
    regionEffective?: RegionUpdateOneWithoutItemsEffectiveNestedInput;
    answerOptions?: AnswerOptionUpdateManyWithoutItemNestedInput;
    tags?: ItemTagUpdateManyWithoutItemNestedInput;
  };

  export type ContentItemUncheckedUpdateWithoutTopicInput = {
    kind?: EnumContentKindFieldUpdateOperationsInput | $Enums.ContentKind;
    locale?: EnumLocaleFieldUpdateOperationsInput | $Enums.Locale;
    title?: NullableStringFieldUpdateOperationsInput | string | null;
    text?: StringFieldUpdateOperationsInput | string;
    richText?: NullableStringFieldUpdateOperationsInput | string | null;
    sortOrder?: IntFieldUpdateOperationsInput | number;
    status?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus;
    authorName?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    publishAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    expireAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    regionMode?: EnumRegionModeFieldUpdateOperationsInput | $Enums.RegionMode;
    regionManualId?: NullableStringFieldUpdateOperationsInput | string | null;
    regionAuto?: InputJsonValue | InputJsonValue | null;
    regionEffectiveId?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    validation?: InputJsonValue | InputJsonValue | null;
    meta?: InputJsonValue | InputJsonValue | null;
    units?: ExtractedUnitUncheckedUpdateManyWithoutItemNestedInput;
    answerOptions?: AnswerOptionUncheckedUpdateManyWithoutItemNestedInput;
    tags?: ItemTagUncheckedUpdateManyWithoutItemNestedInput;
  };

  export type ContentItemUncheckedUpdateManyWithoutTopicInput = {
    kind?: EnumContentKindFieldUpdateOperationsInput | $Enums.ContentKind;
    locale?: EnumLocaleFieldUpdateOperationsInput | $Enums.Locale;
    title?: NullableStringFieldUpdateOperationsInput | string | null;
    text?: StringFieldUpdateOperationsInput | string;
    richText?: NullableStringFieldUpdateOperationsInput | string | null;
    sortOrder?: IntFieldUpdateOperationsInput | number;
    status?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus;
    authorName?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    publishAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    expireAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    regionMode?: EnumRegionModeFieldUpdateOperationsInput | $Enums.RegionMode;
    regionManualId?: NullableStringFieldUpdateOperationsInput | string | null;
    regionAuto?: InputJsonValue | InputJsonValue | null;
    regionEffectiveId?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    validation?: InputJsonValue | InputJsonValue | null;
    meta?: InputJsonValue | InputJsonValue | null;
  };

  export type TopicTagUpdateWithoutTopicInput = {
    tag?: TagUpdateOneRequiredWithoutTopicsNestedInput;
  };

  export type TopicTagUncheckedUpdateWithoutTopicInput = {
    tagId?: StringFieldUpdateOperationsInput | string;
  };

  export type TopicTagUncheckedUpdateManyWithoutTopicInput = {
    tagId?: StringFieldUpdateOperationsInput | string;
  };

  export type TopicTagCreateManyTagInput = {
    id?: string;
    topicId: string;
  };

  export type ItemTagCreateManyTagInput = {
    id?: string;
    itemId: string;
  };

  export type TopicTagUpdateWithoutTagInput = {
    topic?: TopicUpdateOneRequiredWithoutTagsNestedInput;
  };

  export type TopicTagUncheckedUpdateWithoutTagInput = {
    topicId?: StringFieldUpdateOperationsInput | string;
  };

  export type TopicTagUncheckedUpdateManyWithoutTagInput = {
    topicId?: StringFieldUpdateOperationsInput | string;
  };

  export type ItemTagUpdateWithoutTagInput = {
    item?: ContentItemUpdateOneRequiredWithoutTagsNestedInput;
  };

  export type ItemTagUncheckedUpdateWithoutTagInput = {
    itemId?: StringFieldUpdateOperationsInput | string;
  };

  export type ItemTagUncheckedUpdateManyWithoutTagInput = {
    itemId?: StringFieldUpdateOperationsInput | string;
  };

  export type RegionCreateManyParentInput = {
    id?: string;
    code: string;
    name: string;
    level: number;
    meta?: InputJsonValue | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type ContentItemCreateManyRegionManualInput = {
    id?: string;
    kind: $Enums.ContentKind;
    topicId: string;
    locale?: $Enums.Locale;
    title?: string | null;
    text: string;
    richText?: string | null;
    sortOrder?: number;
    status?: $Enums.PublishStatus;
    authorName?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    publishAt?: Date | string | null;
    expireAt?: Date | string | null;
    regionMode?: $Enums.RegionMode;
    regionAuto?: InputJsonValue | null;
    regionEffectiveId?: string | null;
    validation?: InputJsonValue | null;
    meta?: InputJsonValue | null;
  };

  export type ContentItemCreateManyRegionEffectiveInput = {
    id?: string;
    kind: $Enums.ContentKind;
    topicId: string;
    locale?: $Enums.Locale;
    title?: string | null;
    text: string;
    richText?: string | null;
    sortOrder?: number;
    status?: $Enums.PublishStatus;
    authorName?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    publishAt?: Date | string | null;
    expireAt?: Date | string | null;
    regionMode?: $Enums.RegionMode;
    regionManualId?: string | null;
    regionAuto?: InputJsonValue | null;
    validation?: InputJsonValue | null;
    meta?: InputJsonValue | null;
  };

  export type RegionClosureCreateManyAncestorInput = {
    id?: string;
    descendantId: string;
    depth: number;
  };

  export type RegionClosureCreateManyDescendantInput = {
    id?: string;
    ancestorId: string;
    depth: number;
  };

  export type RegionUpdateWithoutParentInput = {
    code?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    level?: IntFieldUpdateOperationsInput | number;
    meta?: InputJsonValue | InputJsonValue | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    children?: RegionUpdateManyWithoutParentNestedInput;
    itemsManual?: ContentItemUpdateManyWithoutRegionManualNestedInput;
    itemsEffective?: ContentItemUpdateManyWithoutRegionEffectiveNestedInput;
    ancestors?: RegionClosureUpdateManyWithoutAncestorNestedInput;
    descendants?: RegionClosureUpdateManyWithoutDescendantNestedInput;
  };

  export type RegionUncheckedUpdateWithoutParentInput = {
    code?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    level?: IntFieldUpdateOperationsInput | number;
    meta?: InputJsonValue | InputJsonValue | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    children?: RegionUncheckedUpdateManyWithoutParentNestedInput;
    itemsManual?: ContentItemUncheckedUpdateManyWithoutRegionManualNestedInput;
    itemsEffective?: ContentItemUncheckedUpdateManyWithoutRegionEffectiveNestedInput;
    ancestors?: RegionClosureUncheckedUpdateManyWithoutAncestorNestedInput;
    descendants?: RegionClosureUncheckedUpdateManyWithoutDescendantNestedInput;
  };

  export type RegionUncheckedUpdateManyWithoutParentInput = {
    code?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    level?: IntFieldUpdateOperationsInput | number;
    meta?: InputJsonValue | InputJsonValue | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ContentItemUpdateWithoutRegionManualInput = {
    kind?: EnumContentKindFieldUpdateOperationsInput | $Enums.ContentKind;
    locale?: EnumLocaleFieldUpdateOperationsInput | $Enums.Locale;
    title?: NullableStringFieldUpdateOperationsInput | string | null;
    text?: StringFieldUpdateOperationsInput | string;
    richText?: NullableStringFieldUpdateOperationsInput | string | null;
    sortOrder?: IntFieldUpdateOperationsInput | number;
    status?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus;
    authorName?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    publishAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    expireAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    regionMode?: EnumRegionModeFieldUpdateOperationsInput | $Enums.RegionMode;
    regionAuto?: InputJsonValue | InputJsonValue | null;
    validation?: InputJsonValue | InputJsonValue | null;
    meta?: InputJsonValue | InputJsonValue | null;
    topic?: TopicUpdateOneRequiredWithoutItemsNestedInput;
    units?: ExtractedUnitUpdateManyWithoutItemNestedInput;
    regionEffective?: RegionUpdateOneWithoutItemsEffectiveNestedInput;
    answerOptions?: AnswerOptionUpdateManyWithoutItemNestedInput;
    tags?: ItemTagUpdateManyWithoutItemNestedInput;
  };

  export type ContentItemUncheckedUpdateWithoutRegionManualInput = {
    kind?: EnumContentKindFieldUpdateOperationsInput | $Enums.ContentKind;
    topicId?: StringFieldUpdateOperationsInput | string;
    locale?: EnumLocaleFieldUpdateOperationsInput | $Enums.Locale;
    title?: NullableStringFieldUpdateOperationsInput | string | null;
    text?: StringFieldUpdateOperationsInput | string;
    richText?: NullableStringFieldUpdateOperationsInput | string | null;
    sortOrder?: IntFieldUpdateOperationsInput | number;
    status?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus;
    authorName?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    publishAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    expireAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    regionMode?: EnumRegionModeFieldUpdateOperationsInput | $Enums.RegionMode;
    regionAuto?: InputJsonValue | InputJsonValue | null;
    regionEffectiveId?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    validation?: InputJsonValue | InputJsonValue | null;
    meta?: InputJsonValue | InputJsonValue | null;
    units?: ExtractedUnitUncheckedUpdateManyWithoutItemNestedInput;
    answerOptions?: AnswerOptionUncheckedUpdateManyWithoutItemNestedInput;
    tags?: ItemTagUncheckedUpdateManyWithoutItemNestedInput;
  };

  export type ContentItemUncheckedUpdateManyWithoutRegionManualInput = {
    kind?: EnumContentKindFieldUpdateOperationsInput | $Enums.ContentKind;
    topicId?: StringFieldUpdateOperationsInput | string;
    locale?: EnumLocaleFieldUpdateOperationsInput | $Enums.Locale;
    title?: NullableStringFieldUpdateOperationsInput | string | null;
    text?: StringFieldUpdateOperationsInput | string;
    richText?: NullableStringFieldUpdateOperationsInput | string | null;
    sortOrder?: IntFieldUpdateOperationsInput | number;
    status?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus;
    authorName?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    publishAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    expireAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    regionMode?: EnumRegionModeFieldUpdateOperationsInput | $Enums.RegionMode;
    regionAuto?: InputJsonValue | InputJsonValue | null;
    regionEffectiveId?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    validation?: InputJsonValue | InputJsonValue | null;
    meta?: InputJsonValue | InputJsonValue | null;
  };

  export type ContentItemUpdateWithoutRegionEffectiveInput = {
    kind?: EnumContentKindFieldUpdateOperationsInput | $Enums.ContentKind;
    locale?: EnumLocaleFieldUpdateOperationsInput | $Enums.Locale;
    title?: NullableStringFieldUpdateOperationsInput | string | null;
    text?: StringFieldUpdateOperationsInput | string;
    richText?: NullableStringFieldUpdateOperationsInput | string | null;
    sortOrder?: IntFieldUpdateOperationsInput | number;
    status?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus;
    authorName?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    publishAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    expireAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    regionMode?: EnumRegionModeFieldUpdateOperationsInput | $Enums.RegionMode;
    regionAuto?: InputJsonValue | InputJsonValue | null;
    validation?: InputJsonValue | InputJsonValue | null;
    meta?: InputJsonValue | InputJsonValue | null;
    topic?: TopicUpdateOneRequiredWithoutItemsNestedInput;
    units?: ExtractedUnitUpdateManyWithoutItemNestedInput;
    regionManual?: RegionUpdateOneWithoutItemsManualNestedInput;
    answerOptions?: AnswerOptionUpdateManyWithoutItemNestedInput;
    tags?: ItemTagUpdateManyWithoutItemNestedInput;
  };

  export type ContentItemUncheckedUpdateWithoutRegionEffectiveInput = {
    kind?: EnumContentKindFieldUpdateOperationsInput | $Enums.ContentKind;
    topicId?: StringFieldUpdateOperationsInput | string;
    locale?: EnumLocaleFieldUpdateOperationsInput | $Enums.Locale;
    title?: NullableStringFieldUpdateOperationsInput | string | null;
    text?: StringFieldUpdateOperationsInput | string;
    richText?: NullableStringFieldUpdateOperationsInput | string | null;
    sortOrder?: IntFieldUpdateOperationsInput | number;
    status?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus;
    authorName?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    publishAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    expireAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    regionMode?: EnumRegionModeFieldUpdateOperationsInput | $Enums.RegionMode;
    regionManualId?: NullableStringFieldUpdateOperationsInput | string | null;
    regionAuto?: InputJsonValue | InputJsonValue | null;
    validation?: InputJsonValue | InputJsonValue | null;
    meta?: InputJsonValue | InputJsonValue | null;
    units?: ExtractedUnitUncheckedUpdateManyWithoutItemNestedInput;
    answerOptions?: AnswerOptionUncheckedUpdateManyWithoutItemNestedInput;
    tags?: ItemTagUncheckedUpdateManyWithoutItemNestedInput;
  };

  export type ContentItemUncheckedUpdateManyWithoutRegionEffectiveInput = {
    kind?: EnumContentKindFieldUpdateOperationsInput | $Enums.ContentKind;
    topicId?: StringFieldUpdateOperationsInput | string;
    locale?: EnumLocaleFieldUpdateOperationsInput | $Enums.Locale;
    title?: NullableStringFieldUpdateOperationsInput | string | null;
    text?: StringFieldUpdateOperationsInput | string;
    richText?: NullableStringFieldUpdateOperationsInput | string | null;
    sortOrder?: IntFieldUpdateOperationsInput | number;
    status?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus;
    authorName?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    publishAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    expireAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    regionMode?: EnumRegionModeFieldUpdateOperationsInput | $Enums.RegionMode;
    regionManualId?: NullableStringFieldUpdateOperationsInput | string | null;
    regionAuto?: InputJsonValue | InputJsonValue | null;
    validation?: InputJsonValue | InputJsonValue | null;
    meta?: InputJsonValue | InputJsonValue | null;
  };

  export type RegionClosureUpdateWithoutAncestorInput = {
    depth?: IntFieldUpdateOperationsInput | number;
    descendant?: RegionUpdateOneRequiredWithoutDescendantsNestedInput;
  };

  export type RegionClosureUncheckedUpdateWithoutAncestorInput = {
    descendantId?: StringFieldUpdateOperationsInput | string;
    depth?: IntFieldUpdateOperationsInput | number;
  };

  export type RegionClosureUncheckedUpdateManyWithoutAncestorInput = {
    descendantId?: StringFieldUpdateOperationsInput | string;
    depth?: IntFieldUpdateOperationsInput | number;
  };

  export type RegionClosureUpdateWithoutDescendantInput = {
    depth?: IntFieldUpdateOperationsInput | number;
    ancestor?: RegionUpdateOneRequiredWithoutAncestorsNestedInput;
  };

  export type RegionClosureUncheckedUpdateWithoutDescendantInput = {
    ancestorId?: StringFieldUpdateOperationsInput | string;
    depth?: IntFieldUpdateOperationsInput | number;
  };

  export type RegionClosureUncheckedUpdateManyWithoutDescendantInput = {
    ancestorId?: StringFieldUpdateOperationsInput | string;
    depth?: IntFieldUpdateOperationsInput | number;
  };

  export type ExtractedUnitCreateManyItemInput = {
    id?: string;
    statementId?: string | null;
    kind: $Enums.UnitKind;
    text: string;
    spanStart: number;
    spanEnd: number;
    confidence: number;
    canonicalKey: string;
    scope?: string | null;
    timeframe?: string | null;
    claimId?: string | null;
    interest?: $Enums.Interest;
    triage?: $Enums.Triage;
    editorNote?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type AnswerOptionCreateManyItemInput = {
    id?: string;
    label: string;
    value: string;
    sortOrder?: number;
    exclusive?: boolean;
    meta?: InputJsonValue | null;
  };

  export type ItemTagCreateManyItemInput = {
    id?: string;
    tagId: string;
  };

  export type ExtractedUnitUpdateWithoutItemInput = {
    statementId?: NullableStringFieldUpdateOperationsInput | string | null;
    kind?: EnumUnitKindFieldUpdateOperationsInput | $Enums.UnitKind;
    text?: StringFieldUpdateOperationsInput | string;
    spanStart?: IntFieldUpdateOperationsInput | number;
    spanEnd?: IntFieldUpdateOperationsInput | number;
    confidence?: FloatFieldUpdateOperationsInput | number;
    canonicalKey?: StringFieldUpdateOperationsInput | string;
    scope?: NullableStringFieldUpdateOperationsInput | string | null;
    timeframe?: NullableStringFieldUpdateOperationsInput | string | null;
    interest?: EnumInterestFieldUpdateOperationsInput | $Enums.Interest;
    triage?: EnumTriageFieldUpdateOperationsInput | $Enums.Triage;
    editorNote?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    claim?: FactcheckClaimUpdateOneWithoutUnitsNestedInput;
  };

  export type ExtractedUnitUncheckedUpdateWithoutItemInput = {
    statementId?: NullableStringFieldUpdateOperationsInput | string | null;
    kind?: EnumUnitKindFieldUpdateOperationsInput | $Enums.UnitKind;
    text?: StringFieldUpdateOperationsInput | string;
    spanStart?: IntFieldUpdateOperationsInput | number;
    spanEnd?: IntFieldUpdateOperationsInput | number;
    confidence?: FloatFieldUpdateOperationsInput | number;
    canonicalKey?: StringFieldUpdateOperationsInput | string;
    scope?: NullableStringFieldUpdateOperationsInput | string | null;
    timeframe?: NullableStringFieldUpdateOperationsInput | string | null;
    claimId?: NullableStringFieldUpdateOperationsInput | string | null;
    interest?: EnumInterestFieldUpdateOperationsInput | $Enums.Interest;
    triage?: EnumTriageFieldUpdateOperationsInput | $Enums.Triage;
    editorNote?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ExtractedUnitUncheckedUpdateManyWithoutItemInput = {
    statementId?: NullableStringFieldUpdateOperationsInput | string | null;
    kind?: EnumUnitKindFieldUpdateOperationsInput | $Enums.UnitKind;
    text?: StringFieldUpdateOperationsInput | string;
    spanStart?: IntFieldUpdateOperationsInput | number;
    spanEnd?: IntFieldUpdateOperationsInput | number;
    confidence?: FloatFieldUpdateOperationsInput | number;
    canonicalKey?: StringFieldUpdateOperationsInput | string;
    scope?: NullableStringFieldUpdateOperationsInput | string | null;
    timeframe?: NullableStringFieldUpdateOperationsInput | string | null;
    claimId?: NullableStringFieldUpdateOperationsInput | string | null;
    interest?: EnumInterestFieldUpdateOperationsInput | $Enums.Interest;
    triage?: EnumTriageFieldUpdateOperationsInput | $Enums.Triage;
    editorNote?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AnswerOptionUpdateWithoutItemInput = {
    label?: StringFieldUpdateOperationsInput | string;
    value?: StringFieldUpdateOperationsInput | string;
    sortOrder?: IntFieldUpdateOperationsInput | number;
    exclusive?: BoolFieldUpdateOperationsInput | boolean;
    meta?: InputJsonValue | InputJsonValue | null;
  };

  export type AnswerOptionUncheckedUpdateWithoutItemInput = {
    label?: StringFieldUpdateOperationsInput | string;
    value?: StringFieldUpdateOperationsInput | string;
    sortOrder?: IntFieldUpdateOperationsInput | number;
    exclusive?: BoolFieldUpdateOperationsInput | boolean;
    meta?: InputJsonValue | InputJsonValue | null;
  };

  export type AnswerOptionUncheckedUpdateManyWithoutItemInput = {
    label?: StringFieldUpdateOperationsInput | string;
    value?: StringFieldUpdateOperationsInput | string;
    sortOrder?: IntFieldUpdateOperationsInput | number;
    exclusive?: BoolFieldUpdateOperationsInput | boolean;
    meta?: InputJsonValue | InputJsonValue | null;
  };

  export type ItemTagUpdateWithoutItemInput = {
    tag?: TagUpdateOneRequiredWithoutItemsNestedInput;
  };

  export type ItemTagUncheckedUpdateWithoutItemInput = {
    tagId?: StringFieldUpdateOperationsInput | string;
  };

  export type ItemTagUncheckedUpdateManyWithoutItemInput = {
    tagId?: StringFieldUpdateOperationsInput | string;
  };

  export type FactcheckClaimCreateManyJobInput = {
    id?: string;
    text: string;
    language?: string | null;
    topic?: string | null;
    falsifiable?: boolean;
    frames?: FactcheckClaimCreateframesInput | string[];
    rhetoricalFlags?: FactcheckClaimCreaterhetoricalFlagsInput | string[];
    canonicalKey: string;
    scope?: string | null;
    timeframe?: string | null;
    status?: $Enums.ReviewStatus;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type FactcheckResultCreateManyJobInput = {
    id?: string;
    verdict: string;
    rawOutput: InputJsonValue;
    createdAt?: Date | string;
  };

  export type FactcheckClaimUpdateWithoutJobInput = {
    text?: StringFieldUpdateOperationsInput | string;
    language?: NullableStringFieldUpdateOperationsInput | string | null;
    topic?: NullableStringFieldUpdateOperationsInput | string | null;
    falsifiable?: BoolFieldUpdateOperationsInput | boolean;
    frames?: FactcheckClaimUpdateframesInput | string[];
    rhetoricalFlags?: FactcheckClaimUpdaterhetoricalFlagsInput | string[];
    canonicalKey?: StringFieldUpdateOperationsInput | string;
    scope?: NullableStringFieldUpdateOperationsInput | string | null;
    timeframe?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumReviewStatusFieldUpdateOperationsInput | $Enums.ReviewStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    providerRuns?: ProviderRunUpdateManyWithoutClaimNestedInput;
    evidences?: EvidenceUpdateManyWithoutClaimNestedInput;
    consensus?: ConsensusRunUpdateOneWithoutClaimNestedInput;
    verdictVersions?: VerdictVersionUpdateManyWithoutClaimNestedInput;
    units?: ExtractedUnitUpdateManyWithoutClaimNestedInput;
    finding?: FindingUpdateOneWithoutClaimNestedInput;
  };

  export type FactcheckClaimUncheckedUpdateWithoutJobInput = {
    text?: StringFieldUpdateOperationsInput | string;
    language?: NullableStringFieldUpdateOperationsInput | string | null;
    topic?: NullableStringFieldUpdateOperationsInput | string | null;
    falsifiable?: BoolFieldUpdateOperationsInput | boolean;
    frames?: FactcheckClaimUpdateframesInput | string[];
    rhetoricalFlags?: FactcheckClaimUpdaterhetoricalFlagsInput | string[];
    canonicalKey?: StringFieldUpdateOperationsInput | string;
    scope?: NullableStringFieldUpdateOperationsInput | string | null;
    timeframe?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumReviewStatusFieldUpdateOperationsInput | $Enums.ReviewStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    providerRuns?: ProviderRunUncheckedUpdateManyWithoutClaimNestedInput;
    evidences?: EvidenceUncheckedUpdateManyWithoutClaimNestedInput;
    consensus?: ConsensusRunUncheckedUpdateOneWithoutClaimNestedInput;
    verdictVersions?: VerdictVersionUncheckedUpdateManyWithoutClaimNestedInput;
    units?: ExtractedUnitUncheckedUpdateManyWithoutClaimNestedInput;
    finding?: FindingUncheckedUpdateOneWithoutClaimNestedInput;
  };

  export type FactcheckClaimUncheckedUpdateManyWithoutJobInput = {
    text?: StringFieldUpdateOperationsInput | string;
    language?: NullableStringFieldUpdateOperationsInput | string | null;
    topic?: NullableStringFieldUpdateOperationsInput | string | null;
    falsifiable?: BoolFieldUpdateOperationsInput | boolean;
    frames?: FactcheckClaimUpdateframesInput | string[];
    rhetoricalFlags?: FactcheckClaimUpdaterhetoricalFlagsInput | string[];
    canonicalKey?: StringFieldUpdateOperationsInput | string;
    scope?: NullableStringFieldUpdateOperationsInput | string | null;
    timeframe?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumReviewStatusFieldUpdateOperationsInput | $Enums.ReviewStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type FactcheckResultUpdateWithoutJobInput = {
    verdict?: StringFieldUpdateOperationsInput | string;
    rawOutput?: InputJsonValue | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type FactcheckResultUncheckedUpdateWithoutJobInput = {
    verdict?: StringFieldUpdateOperationsInput | string;
    rawOutput?: InputJsonValue | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type FactcheckResultUncheckedUpdateManyWithoutJobInput = {
    verdict?: StringFieldUpdateOperationsInput | string;
    rawOutput?: InputJsonValue | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ProviderRunCreateManyClaimInput = {
    id?: string;
    provider: string;
    verdict: string;
    confidence: number;
    costTokens?: number;
    latencyMs?: number;
    raw: InputJsonValue;
    createdAt?: Date | string;
  };

  export type EvidenceCreateManyClaimInput = {
    id?: string;
    url: string;
    domain: string;
    stance: $Enums.Stance;
    snapshotHash?: string | null;
    firstSeenAt?: Date | string | null;
    trustScore?: number | null;
  };

  export type VerdictVersionCreateManyClaimInput = {
    id?: string;
    verdict: string;
    confidence: number;
    asOf?: Date | string;
    supersedes?: string | null;
  };

  export type ExtractedUnitCreateManyClaimInput = {
    id?: string;
    itemId?: string | null;
    statementId?: string | null;
    kind: $Enums.UnitKind;
    text: string;
    spanStart: number;
    spanEnd: number;
    confidence: number;
    canonicalKey: string;
    scope?: string | null;
    timeframe?: string | null;
    interest?: $Enums.Interest;
    triage?: $Enums.Triage;
    editorNote?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type ProviderRunUpdateWithoutClaimInput = {
    provider?: StringFieldUpdateOperationsInput | string;
    verdict?: StringFieldUpdateOperationsInput | string;
    confidence?: FloatFieldUpdateOperationsInput | number;
    costTokens?: IntFieldUpdateOperationsInput | number;
    latencyMs?: IntFieldUpdateOperationsInput | number;
    raw?: InputJsonValue | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ProviderRunUncheckedUpdateWithoutClaimInput = {
    provider?: StringFieldUpdateOperationsInput | string;
    verdict?: StringFieldUpdateOperationsInput | string;
    confidence?: FloatFieldUpdateOperationsInput | number;
    costTokens?: IntFieldUpdateOperationsInput | number;
    latencyMs?: IntFieldUpdateOperationsInput | number;
    raw?: InputJsonValue | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ProviderRunUncheckedUpdateManyWithoutClaimInput = {
    provider?: StringFieldUpdateOperationsInput | string;
    verdict?: StringFieldUpdateOperationsInput | string;
    confidence?: FloatFieldUpdateOperationsInput | number;
    costTokens?: IntFieldUpdateOperationsInput | number;
    latencyMs?: IntFieldUpdateOperationsInput | number;
    raw?: InputJsonValue | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type EvidenceUpdateWithoutClaimInput = {
    url?: StringFieldUpdateOperationsInput | string;
    domain?: StringFieldUpdateOperationsInput | string;
    stance?: EnumStanceFieldUpdateOperationsInput | $Enums.Stance;
    snapshotHash?: NullableStringFieldUpdateOperationsInput | string | null;
    firstSeenAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    trustScore?: NullableIntFieldUpdateOperationsInput | number | null;
  };

  export type EvidenceUncheckedUpdateWithoutClaimInput = {
    url?: StringFieldUpdateOperationsInput | string;
    domain?: StringFieldUpdateOperationsInput | string;
    stance?: EnumStanceFieldUpdateOperationsInput | $Enums.Stance;
    snapshotHash?: NullableStringFieldUpdateOperationsInput | string | null;
    firstSeenAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    trustScore?: NullableIntFieldUpdateOperationsInput | number | null;
  };

  export type EvidenceUncheckedUpdateManyWithoutClaimInput = {
    url?: StringFieldUpdateOperationsInput | string;
    domain?: StringFieldUpdateOperationsInput | string;
    stance?: EnumStanceFieldUpdateOperationsInput | $Enums.Stance;
    snapshotHash?: NullableStringFieldUpdateOperationsInput | string | null;
    firstSeenAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    trustScore?: NullableIntFieldUpdateOperationsInput | number | null;
  };

  export type VerdictVersionUpdateWithoutClaimInput = {
    verdict?: StringFieldUpdateOperationsInput | string;
    confidence?: FloatFieldUpdateOperationsInput | number;
    asOf?: DateTimeFieldUpdateOperationsInput | Date | string;
    supersedes?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type VerdictVersionUncheckedUpdateWithoutClaimInput = {
    verdict?: StringFieldUpdateOperationsInput | string;
    confidence?: FloatFieldUpdateOperationsInput | number;
    asOf?: DateTimeFieldUpdateOperationsInput | Date | string;
    supersedes?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type VerdictVersionUncheckedUpdateManyWithoutClaimInput = {
    verdict?: StringFieldUpdateOperationsInput | string;
    confidence?: FloatFieldUpdateOperationsInput | number;
    asOf?: DateTimeFieldUpdateOperationsInput | Date | string;
    supersedes?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type ExtractedUnitUpdateWithoutClaimInput = {
    statementId?: NullableStringFieldUpdateOperationsInput | string | null;
    kind?: EnumUnitKindFieldUpdateOperationsInput | $Enums.UnitKind;
    text?: StringFieldUpdateOperationsInput | string;
    spanStart?: IntFieldUpdateOperationsInput | number;
    spanEnd?: IntFieldUpdateOperationsInput | number;
    confidence?: FloatFieldUpdateOperationsInput | number;
    canonicalKey?: StringFieldUpdateOperationsInput | string;
    scope?: NullableStringFieldUpdateOperationsInput | string | null;
    timeframe?: NullableStringFieldUpdateOperationsInput | string | null;
    interest?: EnumInterestFieldUpdateOperationsInput | $Enums.Interest;
    triage?: EnumTriageFieldUpdateOperationsInput | $Enums.Triage;
    editorNote?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    item?: ContentItemUpdateOneWithoutUnitsNestedInput;
  };

  export type ExtractedUnitUncheckedUpdateWithoutClaimInput = {
    itemId?: NullableStringFieldUpdateOperationsInput | string | null;
    statementId?: NullableStringFieldUpdateOperationsInput | string | null;
    kind?: EnumUnitKindFieldUpdateOperationsInput | $Enums.UnitKind;
    text?: StringFieldUpdateOperationsInput | string;
    spanStart?: IntFieldUpdateOperationsInput | number;
    spanEnd?: IntFieldUpdateOperationsInput | number;
    confidence?: FloatFieldUpdateOperationsInput | number;
    canonicalKey?: StringFieldUpdateOperationsInput | string;
    scope?: NullableStringFieldUpdateOperationsInput | string | null;
    timeframe?: NullableStringFieldUpdateOperationsInput | string | null;
    interest?: EnumInterestFieldUpdateOperationsInput | $Enums.Interest;
    triage?: EnumTriageFieldUpdateOperationsInput | $Enums.Triage;
    editorNote?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ExtractedUnitUncheckedUpdateManyWithoutClaimInput = {
    itemId?: NullableStringFieldUpdateOperationsInput | string | null;
    statementId?: NullableStringFieldUpdateOperationsInput | string | null;
    kind?: EnumUnitKindFieldUpdateOperationsInput | $Enums.UnitKind;
    text?: StringFieldUpdateOperationsInput | string;
    spanStart?: IntFieldUpdateOperationsInput | number;
    spanEnd?: IntFieldUpdateOperationsInput | number;
    confidence?: FloatFieldUpdateOperationsInput | number;
    canonicalKey?: StringFieldUpdateOperationsInput | string;
    scope?: NullableStringFieldUpdateOperationsInput | string | null;
    timeframe?: NullableStringFieldUpdateOperationsInput | string | null;
    interest?: EnumInterestFieldUpdateOperationsInput | $Enums.Interest;
    triage?: EnumTriageFieldUpdateOperationsInput | $Enums.Triage;
    editorNote?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number;
  };

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF;
}
